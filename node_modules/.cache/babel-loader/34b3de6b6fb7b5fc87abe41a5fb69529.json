{"ast":null,"code":"import { Mesh, Vector3, Color, FrontSide, RGBFormat, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, UniformsUtils, UniformsLib, ShaderMaterial, LinearFilter } from 'three';\n/**\n * Work based on :\n * http://slayvin.net : Flat mirror for three.js\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(geometry);\n    const scope = this;\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    const time = options.time !== undefined ? options.time : 0.0;\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    const side = options.side !== undefined ? options.side : FrontSide;\n    const fog = options.fog !== undefined ? options.fog : false;\n    const format = options.format !== undefined ? options.format : RGBFormat; //\n\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: 1.0\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(0x7f7f7f)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(0x555555)\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n\n}\n\nWater.prototype.isWater = true;\nexport { Water };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/objects/Water.js"],"names":["Mesh","Vector3","Color","FrontSide","RGBFormat","Plane","Matrix4","Vector4","PerspectiveCamera","WebGLRenderTarget","MathUtils","UniformsUtils","UniformsLib","ShaderMaterial","LinearFilter","Water","constructor","geometry","options","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","side","fog","format","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","mirrorCamera","parameters","minFilter","magFilter","renderTarget","isPowerOfTwo","texture","generateMipmaps","mirrorShader","uniforms","merge","value","mirrorSampler","size","vertexShader","fragmentShader","material","clone","lights","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","isWater"],"mappings":"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","sourcesContent":["import { Mesh, Vector3, Color, FrontSide, RGBFormat, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, MathUtils, UniformsUtils, UniformsLib, ShaderMaterial, LinearFilter } from 'three';\n\n/**\n * Work based on :\n * http://slayvin.net : Flat mirror for three.js\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    const scope = this;\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    const time = options.time !== undefined ? options.time : 0.0;\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    const side = options.side !== undefined ? options.side : FrontSide;\n    const fog = options.fog !== undefined ? options.fog : false;\n    const format = options.format !== undefined ? options.format : RGBFormat; //\n\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: 1.0\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(0x7f7f7f)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(0x555555)\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n\n}\n\nWater.prototype.isWater = true;\n\nexport { Water };\n"]},"metadata":{},"sourceType":"module"}