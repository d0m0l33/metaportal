{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from 'three';\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n\n\n  parse(text, path) {\n    const lines = text.split('\\n');\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue;\n      }\n\n      const pos = line.indexOf(' ');\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : '';\n      value = value.trim();\n\n      if (key === 'newmtl') {\n        // New material\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n\n}\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\n\nclass MaterialCreator {\n  constructor() {\n    let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = 'anonymous';\n    this.side = this.options.side !== undefined ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== undefined ? this.options.wrap : RepeatWrapping;\n  }\n\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n\n  setManager(value) {\n    this.manager = value;\n  }\n\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo;\n    const converted = {};\n\n    for (const mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n                save = false;\n              }\n            }\n\n            break;\n        }\n\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n\n    return converted;\n  }\n\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n\n  getAsArray() {\n    let index = 0;\n\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n\n    return this.materialsArray;\n  }\n\n  create(materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName);\n    }\n\n    return this.materials[materialName];\n  }\n\n  createMaterial_(materialName) {\n    // Create material\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return ''; // Absolute URL\n\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return; // Keep the first encountered texture\n\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === '') continue;\n\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n          params.color = new Color().fromArray(value);\n          break;\n\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = new Color().fromArray(value);\n          break;\n\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = new Color().fromArray(value);\n          break;\n\n        case 'map_kd':\n          // Diffuse texture map\n          setMapForType('map', value);\n          break;\n\n        case 'map_ks':\n          // Specular map\n          setMapForType('specularMap', value);\n          break;\n\n        case 'map_ke':\n          // Emissive map\n          setMapForType('emissiveMap', value);\n          break;\n\n        case 'norm':\n          setMapForType('normalMap', value);\n          break;\n\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n          setMapForType('bumpMap', value);\n          break;\n\n        case 'map_d':\n          // Alpha map\n          setMapForType('alphaMap', value);\n          params.transparent = true;\n          break;\n\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n          params.shininess = parseFloat(value);\n          break;\n\n        case 'd':\n          n = parseFloat(value);\n\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n\n          break;\n\n        case 'tr':\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n\n          break;\n      }\n    }\n\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf('-bm');\n\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n\n    pos = items.indexOf('-s');\n\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    pos = items.indexOf('-o');\n\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    texParams.url = items.join(' ').trim();\n    return texParams;\n  }\n\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== undefined ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== undefined) texture.mapping = mapping;\n    return texture;\n  }\n\n}\n\nexport { MTLLoader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/loaders/MTLLoader.js"],"names":["Loader","LoaderUtils","FileLoader","FrontSide","RepeatWrapping","Color","MeshPhongMaterial","Vector2","DefaultLoadingManager","TextureLoader","MTLLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","undefined","wrap","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","resolveURL","test","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","repeat","copy","scale","offset","wrapS","wrapT","n","color","fromArray","specular","emissive","transparent","shininess","opacity","invertTrProperty","matParams","items","bumpScale","splice","set","join","mapping","getHandler","texture"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, FrontSide, RepeatWrapping, Color, MeshPhongMaterial, Vector2, DefaultLoadingManager, TextureLoader } from 'three';\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n\n\n  parse(text, path) {\n    const lines = text.split('\\n');\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n\n      if (line.length === 0 || line.charAt(0) === '#') {\n        // Blank line or comment ignore\n        continue;\n      }\n\n      const pos = line.indexOf(' ');\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : '';\n      value = value.trim();\n\n      if (key === 'newmtl') {\n        // New material\n        info = {\n          name: value\n        };\n        materialsInfo[value] = info;\n      } else {\n        if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n\n}\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\n\nclass MaterialCreator {\n  constructor(baseUrl = '', options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = 'anonymous';\n    this.side = this.options.side !== undefined ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== undefined ? this.options.wrap : RepeatWrapping;\n  }\n\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n\n  setManager(value) {\n    this.manager = value;\n  }\n\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo;\n    const converted = {};\n\n    for (const mn in materialsInfo) {\n      // Convert materials info into normalized form based on options\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n\n        switch (lprop) {\n          case 'kd':\n          case 'ka':\n          case 'ks':\n            // Diffuse color (color under white light) using RGB values\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                // ignore\n                save = false;\n              }\n            }\n\n            break;\n        }\n\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n\n    return converted;\n  }\n\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n\n  getAsArray() {\n    let index = 0;\n\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n\n    return this.materialsArray;\n  }\n\n  create(materialName) {\n    if (this.materials[materialName] === undefined) {\n      this.createMaterial_(materialName);\n    }\n\n    return this.materials[materialName];\n  }\n\n  createMaterial_(materialName) {\n    // Create material\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== 'string' || url === '') return ''; // Absolute URL\n\n      if (/^https?:\\/\\//i.test(url)) return url;\n      return baseUrl + url;\n    }\n\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return; // Keep the first encountered texture\n\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === '') continue;\n\n      switch (prop.toLowerCase()) {\n        // Ns is material specular exponent\n        case 'kd':\n          // Diffuse color (color under white light) using RGB values\n          params.color = new Color().fromArray(value);\n          break;\n\n        case 'ks':\n          // Specular color (color when light is reflected from shiny surface) using RGB values\n          params.specular = new Color().fromArray(value);\n          break;\n\n        case 'ke':\n          // Emissive using RGB values\n          params.emissive = new Color().fromArray(value);\n          break;\n\n        case 'map_kd':\n          // Diffuse texture map\n          setMapForType('map', value);\n          break;\n\n        case 'map_ks':\n          // Specular map\n          setMapForType('specularMap', value);\n          break;\n\n        case 'map_ke':\n          // Emissive map\n          setMapForType('emissiveMap', value);\n          break;\n\n        case 'norm':\n          setMapForType('normalMap', value);\n          break;\n\n        case 'map_bump':\n        case 'bump':\n          // Bump texture map\n          setMapForType('bumpMap', value);\n          break;\n\n        case 'map_d':\n          // Alpha map\n          setMapForType('alphaMap', value);\n          params.transparent = true;\n          break;\n\n        case 'ns':\n          // The specular exponent (defines the focus of the specular highlight)\n          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n          params.shininess = parseFloat(value);\n          break;\n\n        case 'd':\n          n = parseFloat(value);\n\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n\n          break;\n\n        case 'tr':\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n\n          break;\n      }\n    }\n\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf('-bm');\n\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n\n    pos = items.indexOf('-s');\n\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    pos = items.indexOf('-o');\n\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4); // we expect 3 parameters here!\n    }\n\n    texParams.url = items.join(' ').trim();\n    return texParams;\n  }\n\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== undefined ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== undefined) texture.mapping = mapping;\n    return texture;\n  }\n\n}\n\nexport { MTLLoader };\n"]},"metadata":{},"sourceType":"module"}