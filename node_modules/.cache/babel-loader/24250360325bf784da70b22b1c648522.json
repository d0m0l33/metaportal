{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferAttribute, BufferGeometry } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\n\nclass EdgeSplitModifier {\n  constructor() {\n    var _this = this;\n\n    _defineProperty(this, \"A\", new Vector3());\n\n    _defineProperty(this, \"B\", new Vector3());\n\n    _defineProperty(this, \"C\", new Vector3());\n\n    _defineProperty(this, \"positions\", []);\n\n    _defineProperty(this, \"normals\", new Float32Array());\n\n    _defineProperty(this, \"indexes\", []);\n\n    _defineProperty(this, \"pointToIndexMap\", []);\n\n    _defineProperty(this, \"splitIndexes\", []);\n\n    _defineProperty(this, \"oldNormals\", []);\n\n    _defineProperty(this, \"computeNormals\", () => {\n      this.normals = new Float32Array(this.indexes.length * 3);\n\n      for (let i = 0; i < this.indexes.length; i += 3) {\n        let index = this.indexes[i];\n        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 1];\n        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 2];\n        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        this.C.sub(this.B);\n        this.A.sub(this.B);\n        const normal = this.C.cross(this.A).normalize();\n\n        for (let j = 0; j < 3; j++) {\n          this.normals[3 * (i + j)] = normal.x;\n          this.normals[3 * (i + j) + 1] = normal.y;\n          this.normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    });\n\n    _defineProperty(this, \"mapPositionsToIndexes\", () => {\n      this.pointToIndexMap = Array(this.positions.length / 3);\n\n      for (let i = 0; i < this.indexes.length; i++) {\n        const index = this.indexes[i];\n\n        if (this.pointToIndexMap[index] == null) {\n          this.pointToIndexMap[index] = [];\n        }\n\n        this.pointToIndexMap[index].push(i);\n      }\n    });\n\n    _defineProperty(this, \"edgeSplitToGroups\", (indexes, cutOff, firstIndex) => {\n      this.A.set(this.normals[3 * firstIndex], this.normals[3 * firstIndex + 1], this.normals[3 * firstIndex + 2]).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n\n      for (let j of indexes) {\n        if (j !== firstIndex) {\n          this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();\n\n          if (this.B.dot(this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n\n      return result;\n    });\n\n    _defineProperty(this, \"edgeSplit\", function (indexes, cutOff) {\n      let original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (indexes.length === 0) return;\n      const groupResults = [];\n\n      for (let index of indexes) {\n        groupResults.push(_this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n\n      let result = groupResults[0];\n\n      for (let groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n\n      if (original != null) {\n        _this.splitIndexes.push({\n          original,\n          indexes: result.currentGroup\n        });\n      }\n\n      if (result.splitGroup.length) {\n        _this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    });\n\n    _defineProperty(this, \"modify\", function (geometry, cutOffAngle) {\n      let tryKeepNormals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      let hadNormals = false;\n\n      if (geometry.attributes.normal) {\n        hadNormals = true;\n        geometry = geometry.clone();\n\n        if (tryKeepNormals === true && geometry.index !== null) {\n          _this.oldNormals = geometry.attributes.normal.array;\n        }\n\n        geometry.deleteAttribute('normal');\n      }\n\n      if (geometry.index == null) {\n        if (BufferGeometryUtils === undefined) {\n          throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n        }\n\n        geometry = mergeVertices(geometry);\n      }\n\n      _this.indexes = geometry.index.array;\n      _this.positions = geometry.getAttribute('position').array;\n\n      _this.computeNormals();\n\n      _this.mapPositionsToIndexes();\n\n      _this.splitIndexes = [];\n\n      for (let vertexIndexes of _this.pointToIndexMap) {\n        _this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n      }\n\n      const newAttributes = {};\n\n      for (let name of Object.keys(geometry.attributes)) {\n        const oldAttribute = geometry.attributes[name]; // @ts-ignore\n\n        const newArray = new oldAttribute.array.constructor((_this.indexes.length + _this.splitIndexes.length) * oldAttribute.itemSize);\n        newArray.set(oldAttribute.array);\n        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n      }\n\n      const newIndexes = new Uint32Array(_this.indexes.length);\n      newIndexes.set(_this.indexes);\n\n      for (let i = 0; i < _this.splitIndexes.length; i++) {\n        const split = _this.splitIndexes[i];\n        const index = _this.indexes[split.original];\n\n        for (let attribute of Object.values(newAttributes)) {\n          for (let j = 0; j < attribute.itemSize; j++) {\n            // @ts-expect-error ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n            attribute.array[(_this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n          }\n        }\n\n        for (let j of split.indexes) {\n          newIndexes[j] = _this.indexes.length + i;\n        }\n      }\n\n      geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(newIndexes, 1));\n\n      for (let name of Object.keys(newAttributes)) {\n        geometry.setAttribute(name, newAttributes[name]);\n      }\n\n      if (hadNormals) {\n        geometry.computeVertexNormals();\n\n        if (_this.oldNormals !== null) {\n          const changedNormals = new Array(_this.oldNormals.length / 3).fill(false);\n\n          for (let splitData of _this.splitIndexes) changedNormals[splitData.original] = true;\n\n          for (let i = 0; i < changedNormals.length; i++) {\n            if (changedNormals[i] === false) {\n              for (let j = 0; j < 3; j++) {\n                // @ts-expect-error ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n                geometry.attributes.normal.array[3 * i + j] = _this.oldNormals[3 * i + j];\n              }\n            }\n          }\n        }\n      }\n\n      return geometry;\n    });\n  }\n\n}\n\nexport { EdgeSplitModifier };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/modifiers/EdgeSplitModifier.js"],"names":["_defineProperty","Vector3","BufferAttribute","BufferGeometry","BufferGeometryUtils","mergeVertices","EdgeSplitModifier","constructor","Float32Array","normals","indexes","length","i","index","A","set","positions","B","C","sub","normal","cross","normalize","j","x","y","z","pointToIndexMap","Array","push","cutOff","firstIndex","result","splitGroup","currentGroup","dot","original","groupResults","edgeSplitToGroups","groupResult","splitIndexes","edgeSplit","geometry","cutOffAngle","tryKeepNormals","hadNormals","attributes","clone","oldNormals","array","deleteAttribute","undefined","getAttribute","computeNormals","mapPositionsToIndexes","vertexIndexes","Math","cos","newAttributes","name","Object","keys","oldAttribute","newArray","itemSize","normalized","newIndexes","Uint32Array","split","attribute","values","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferAttribute, BufferGeometry } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\n\nclass EdgeSplitModifier {\n  constructor() {\n    _defineProperty(this, \"A\", new Vector3());\n\n    _defineProperty(this, \"B\", new Vector3());\n\n    _defineProperty(this, \"C\", new Vector3());\n\n    _defineProperty(this, \"positions\", []);\n\n    _defineProperty(this, \"normals\", new Float32Array());\n\n    _defineProperty(this, \"indexes\", []);\n\n    _defineProperty(this, \"pointToIndexMap\", []);\n\n    _defineProperty(this, \"splitIndexes\", []);\n\n    _defineProperty(this, \"oldNormals\", []);\n\n    _defineProperty(this, \"computeNormals\", () => {\n      this.normals = new Float32Array(this.indexes.length * 3);\n\n      for (let i = 0; i < this.indexes.length; i += 3) {\n        let index = this.indexes[i];\n        this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 1];\n        this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        index = this.indexes[i + 2];\n        this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2]);\n        this.C.sub(this.B);\n        this.A.sub(this.B);\n        const normal = this.C.cross(this.A).normalize();\n\n        for (let j = 0; j < 3; j++) {\n          this.normals[3 * (i + j)] = normal.x;\n          this.normals[3 * (i + j) + 1] = normal.y;\n          this.normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    });\n\n    _defineProperty(this, \"mapPositionsToIndexes\", () => {\n      this.pointToIndexMap = Array(this.positions.length / 3);\n\n      for (let i = 0; i < this.indexes.length; i++) {\n        const index = this.indexes[i];\n\n        if (this.pointToIndexMap[index] == null) {\n          this.pointToIndexMap[index] = [];\n        }\n\n        this.pointToIndexMap[index].push(i);\n      }\n    });\n\n    _defineProperty(this, \"edgeSplitToGroups\", (indexes, cutOff, firstIndex) => {\n      this.A.set(this.normals[3 * firstIndex], this.normals[3 * firstIndex + 1], this.normals[3 * firstIndex + 2]).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n\n      for (let j of indexes) {\n        if (j !== firstIndex) {\n          this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize();\n\n          if (this.B.dot(this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n\n      return result;\n    });\n\n    _defineProperty(this, \"edgeSplit\", (indexes, cutOff, original = null) => {\n      if (indexes.length === 0) return;\n      const groupResults = [];\n\n      for (let index of indexes) {\n        groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n\n      let result = groupResults[0];\n\n      for (let groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n\n      if (original != null) {\n        this.splitIndexes.push({\n          original,\n          indexes: result.currentGroup\n        });\n      }\n\n      if (result.splitGroup.length) {\n        this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    });\n\n    _defineProperty(this, \"modify\", (geometry, cutOffAngle, tryKeepNormals = true) => {\n      let hadNormals = false;\n\n      if (geometry.attributes.normal) {\n        hadNormals = true;\n        geometry = geometry.clone();\n\n        if (tryKeepNormals === true && geometry.index !== null) {\n          this.oldNormals = geometry.attributes.normal.array;\n        }\n\n        geometry.deleteAttribute('normal');\n      }\n\n      if (geometry.index == null) {\n        if (BufferGeometryUtils === undefined) {\n          throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n        }\n\n        geometry = mergeVertices(geometry);\n      }\n\n      this.indexes = geometry.index.array;\n      this.positions = geometry.getAttribute('position').array;\n      this.computeNormals();\n      this.mapPositionsToIndexes();\n      this.splitIndexes = [];\n\n      for (let vertexIndexes of this.pointToIndexMap) {\n        this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n      }\n\n      const newAttributes = {};\n\n      for (let name of Object.keys(geometry.attributes)) {\n        const oldAttribute = geometry.attributes[name]; // @ts-ignore\n\n        const newArray = new oldAttribute.array.constructor((this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize);\n        newArray.set(oldAttribute.array);\n        newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n      }\n\n      const newIndexes = new Uint32Array(this.indexes.length);\n      newIndexes.set(this.indexes);\n\n      for (let i = 0; i < this.splitIndexes.length; i++) {\n        const split = this.splitIndexes[i];\n        const index = this.indexes[split.original];\n\n        for (let attribute of Object.values(newAttributes)) {\n          for (let j = 0; j < attribute.itemSize; j++) {\n            // @ts-expect-error ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n            attribute.array[(this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n          }\n        }\n\n        for (let j of split.indexes) {\n          newIndexes[j] = this.indexes.length + i;\n        }\n      }\n\n      geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(newIndexes, 1));\n\n      for (let name of Object.keys(newAttributes)) {\n        geometry.setAttribute(name, newAttributes[name]);\n      }\n\n      if (hadNormals) {\n        geometry.computeVertexNormals();\n\n        if (this.oldNormals !== null) {\n          const changedNormals = new Array(this.oldNormals.length / 3).fill(false);\n\n          for (let splitData of this.splitIndexes) changedNormals[splitData.original] = true;\n\n          for (let i = 0; i < changedNormals.length; i++) {\n            if (changedNormals[i] === false) {\n              for (let j = 0; j < 3; j++) {\n                // @ts-expect-error ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n                geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j];\n              }\n            }\n          }\n        }\n      }\n\n      return geometry;\n    });\n  }\n\n}\n\nexport { EdgeSplitModifier };\n"]},"metadata":{},"sourceType":"module"}