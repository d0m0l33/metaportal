import { EqualityChecker, GetState, PartialState, SetState, State, StateListener, StateSelector, StateSliceListener, StoreApi } from './vanilla';
declare type DevtoolsType = {
    prefix: string;
    subscribe: (dispatch: any) => () => void;
    unsubscribe: () => void;
    send: (action: string, state: any) => void;
    init: (state: any) => void;
    error: (payload: any) => void;
};
export declare type StoreApiWithRedux<T extends State, A extends {
    type: unknown;
}> = StoreApi<T & {
    dispatch: (a: A) => A;
}> & {
    dispatch: (a: A) => A;
};
export declare const redux: <S extends object, A extends {
    type: unknown;
}>(reducer: (state: S, action: A) => S, initial: S) => (set: SetState<S & {
    dispatch: (a: A) => A;
}>, get: GetState<S & {
    dispatch: (a: A) => A;
}>, api: StoreApi<S & {
    dispatch: (a: A) => A;
}> & {
    dispatch: (a: A) => A;
} & {
    devtools?: DevtoolsType | undefined;
}) => S & {
    dispatch: (a: A) => A;
};
export declare type NamedSet<T extends State> = {
    <K1 extends keyof T, K2 extends keyof T = K1, K3 extends keyof T = K2, K4 extends keyof T = K3>(partial: PartialState<T, K1, K2, K3, K4>, replace?: boolean, name?: string): void;
};
export declare type StoreApiWithDevtools<T extends State> = StoreApi<T> & {
    setState: NamedSet<T>;
    devtools?: DevtoolsType;
};
export declare const devtools: <S extends object, CustomSetState extends SetState<S>, CustomGetState extends GetState<S>, CustomStoreApi extends StoreApi<S>>(fn: (set: NamedSet<S>, get: CustomGetState, api: CustomStoreApi) => S, options?: string | {
    name?: string | undefined;
    serialize?: {
        options: boolean | {
            date?: boolean;
            regex?: boolean;
            undefined?: boolean;
            nan?: boolean;
            infinity?: boolean;
            error?: boolean;
            symbol?: boolean;
            map?: boolean;
            set?: boolean;
        };
    } | undefined;
} | undefined) => (set: CustomSetState, get: CustomGetState, api: CustomStoreApi & StoreApi<S> & {
    setState: NamedSet<S>;
    devtools?: DevtoolsType | undefined;
} & {
    dispatch?: unknown;
}) => S;
export declare type StoreApiWithSubscribeWithSelector<T extends State> = Omit<StoreApi<T>, 'subscribe'> & {
    subscribe: {
        (listener: StateListener<T>): () => void;
        <StateSlice>(selector: StateSelector<T, StateSlice>, listener: StateSliceListener<StateSlice>, options?: {
            equalityFn?: EqualityChecker<StateSlice>;
            fireImmediately?: boolean;
        }): () => void;
    };
};
export declare const subscribeWithSelector: <S extends object, CustomSetState extends SetState<S>, CustomGetState extends GetState<S>, CustomStoreApi extends StoreApi<S>>(fn: (set: CustomSetState, get: CustomGetState, api: CustomStoreApi) => S) => (set: CustomSetState, get: CustomGetState, api: Omit<CustomStoreApi, "subscribe"> & Omit<StoreApi<S>, "subscribe"> & {
    subscribe: {
        (listener: StateListener<S>): () => void;
        <StateSlice>(selector: StateSelector<S, StateSlice>, listener: StateSliceListener<StateSlice>, options?: {
            equalityFn?: EqualityChecker<StateSlice> | undefined;
            fireImmediately?: boolean | undefined;
        } | undefined): () => void;
    };
}) => S;
declare type Combine<T, U> = Omit<T, keyof U> & U;
export declare const combine: <PrimaryState extends object, SecondaryState extends object>(initialState: PrimaryState, create: (set: SetState<PrimaryState> & NamedSet<PrimaryState>, get: GetState<PrimaryState>, api: StoreApi<PrimaryState>) => SecondaryState) => (set: SetState<Combine<PrimaryState, SecondaryState>>, get: GetState<Combine<PrimaryState, SecondaryState>>, api: StoreApi<Combine<PrimaryState, SecondaryState>>) => Combine<PrimaryState, SecondaryState>;
declare type DeepPartial<T extends Object> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
export declare type StateStorage = {
    getItem: (name: string) => string | null | Promise<string | null>;
    setItem: (name: string, value: string) => void | Promise<void>;
    removeItem?: (name: string) => void | Promise<void>;
};
declare type StorageValue<S> = {
    state: DeepPartial<S>;
    version?: number;
};
export declare type PersistOptions<S, PersistedState extends Partial<S> = Partial<S>> = {
    /** Name of the storage (must be unique) */
    name: string;
    /**
     * A function returning a storage.
     * The storage must fit `window.localStorage`'s api (or an async version of it).
     * For example the storage could be `AsyncStorage` from React Native.
     *
     * @default () => localStorage
     */
    getStorage?: () => StateStorage;
    /**
     * Use a custom serializer.
     * The returned string will be stored in the storage.
     *
     * @default JSON.stringify
     */
    serialize?: (state: StorageValue<S>) => string | Promise<string>;
    /**
     * Use a custom deserializer.
     * Must return an object matching StorageValue<State>
     *
     * @param str The storage's current value.
     * @default JSON.parse
     */
    deserialize?: (str: string) => StorageValue<PersistedState> | Promise<StorageValue<PersistedState>>;
    /**
     * Prevent some items from being stored.
     *
     * @deprecated This options is deprecated and will be removed in the next version. Please use the `partialize` option instead.
     */
    blacklist?: (keyof S)[];
    /**
     * Only store the listed properties.
     *
     * @deprecated This options is deprecated and will be removed in the next version. Please use the `partialize` option instead.
     */
    whitelist?: (keyof S)[];
    /**
     * Filter the persisted value.
     *
     * @params state The state's value
     */
    partialize?: (state: S) => DeepPartial<S>;
    /**
     * A function returning another (optional) function.
     * The main function will be called before the state rehydration.
     * The returned function will be called after the state rehydration or when an error occurred.
     */
    onRehydrateStorage?: (state: S) => ((state?: S, error?: Error) => void) | void;
    /**
     * If the stored state's version mismatch the one specified here, the storage will not be used.
     * This is useful when adding a breaking change to your store.
     */
    version?: number;
    /**
     * A function to perform persisted state migration.
     * This function will be called when persisted state versions mismatch with the one specified here.
     */
    migrate?: (persistedState: any, version: number) => S | Promise<S>;
    /**
     * A function to perform custom hydration merges when combining the stored state with the current one.
     * By default, this function does a shallow merge.
     */
    merge?: (persistedState: any, currentState: S) => S;
};
declare type PersistListener<S> = (state: S) => void;
export declare type StoreApiWithPersist<S extends State> = StoreApi<S> & {
    persist: {
        setOptions: (options: Partial<PersistOptions<S>>) => void;
        clearStorage: () => void;
        rehydrate: () => Promise<void>;
        hasHydrated: () => boolean;
        onHydrate: (fn: PersistListener<S>) => () => void;
        onFinishHydration: (fn: PersistListener<S>) => () => void;
    };
};
export declare const persist: <S extends object, CustomSetState extends SetState<S>, CustomGetState extends GetState<S>, CustomStoreApi extends StoreApi<S>>(config: (set: CustomSetState, get: CustomGetState, api: CustomStoreApi) => S, baseOptions: PersistOptions<S, Partial<S>>) => (set: CustomSetState, get: CustomGetState, api: CustomStoreApi & StoreApi<S> & {
    persist: {
        setOptions: (options: Partial<PersistOptions<S, Partial<S>>>) => void;
        clearStorage: () => void;
        rehydrate: () => Promise<void>;
        hasHydrated: () => boolean;
        onHydrate: (fn: PersistListener<S>) => () => void;
        onFinishHydration: (fn: PersistListener<S>) => () => void;
    };
}) => S;
export {};
