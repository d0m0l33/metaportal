"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");const t=new e.Vector3,n=new e.Vector3;function r(e){return/primitive/i.test(e)||"Subpart"===e}class a{constructor(e,t){this.line=e,this.lineLength=e.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=t}seekNonSpace(){for(;this.currentCharIndex<this.lineLength;){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const e=this.currentCharIndex++;for(;this.currentCharIndex<this.lineLength&&(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar);)this.currentCharIndex++;const t=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(e,t)}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}function o(e,t){return e.colourCode===t.colourCode?0:e.colourCode<t.colourCode?-1:1}function i(t,n,r){t.sort(o);const a=[],i=[],s=[],l=new e.BufferGeometry;let c=null,u=0,d=0;for(let e=0,r=t.length;e<r;e++){const r=t[e],o=r.v0,h=r.v1;if(a.push(o.x,o.y,o.z,h.x,h.y,h.z),3===n){a.push(r.v2.x,r.v2.y,r.v2.z);const e=r.n0||r.faceNormal,t=r.n1||r.faceNormal,n=r.n2||r.faceNormal;i.push(e.x,e.y,e.z),i.push(t.x,t.y,t.z),i.push(n.x,n.y,n.z)}c!==r.material?(null!==c&&l.addGroup(u,d,s.length-1),s.push(r.material),c=r.material,u=e*n,d=n):d+=n}d>0&&l.addGroup(u,1/0,s.length-1),l.setAttribute("position",new e.Float32BufferAttribute(a,3)),3===n&&l.setAttribute("normal",new e.Float32BufferAttribute(i,3));let h=null;if(2===n?h=new e.LineSegments(l,s):3===n&&(h=new e.Mesh(l,s)),r){h.isConditionalLine=!0;const n=new Float32Array(3*t.length*2),r=new Float32Array(3*t.length*2),a=new Float32Array(3*t.length*2);for(let e=0,o=t.length;e<o;e++){const o=t[e],i=o.c0,s=o.c1,l=o.v0,c=o.v1,u=3*e*2;n[u+0]=i.x,n[u+1]=i.y,n[u+2]=i.z,n[u+3]=i.x,n[u+4]=i.y,n[u+5]=i.z,r[u+0]=s.x,r[u+1]=s.y,r[u+2]=s.z,r[u+3]=s.x,r[u+4]=s.y,r[u+5]=s.z,a[u+0]=c.x-l.x,a[u+1]=c.y-l.y,a[u+2]=c.z-l.z,a[u+3]=c.x-l.x,a[u+4]=c.y-l.y,a[u+5]=c.z-l.z}l.setAttribute("control0",new e.BufferAttribute(n,3,!1)),l.setAttribute("control1",new e.BufferAttribute(r,3,!1)),l.setAttribute("direction",new e.BufferAttribute(a,3,!1))}return h}class s extends e.Loader{constructor(e){super(e),this.parseScopesStack=null,this.materials=[],this.subobjectCache={},this.fileMap=null,this.setMaterials([this.parseColourMetaDirective(new a("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333")),this.parseColourMetaDirective(new a("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))]),this.separateObjects=!1,this.smoothNormals=!0}load(t,n,r,a){this.fileMap||(this.fileMap={});const o=this,i=new e.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(function(e){o.processObject(e,n,null,t)}),r,a)}parse(e,t,n){this.processObject(e,n,null,t)}setMaterials(e){return this.parseScopesStack=[],this.newParseScopeLevel(e),this.getCurrentParseScope().isFromParse=!1,this.materials=e,this}setFileMap(e){return this.fileMap=e,this}newParseScopeLevel(t){const n={};if(t)for(let e=0,r=t.length;e<r;e++){const r=t[e];n[r.userData.code]=r}const r=this.getCurrentParseScope(),a={lib:n,url:null,subobjects:null,numSubobjects:0,subobjectIndex:0,inverted:!1,category:null,keywords:null,currentFileName:null,mainColourCode:r?r.mainColourCode:"16",mainEdgeColourCode:r?r.mainEdgeColourCode:"24",currentMatrix:new e.Matrix4,matrix:new e.Matrix4,isFromParse:!0,triangles:null,lineSegments:null,conditionalSegments:null,startingConstructionStep:!1};return this.parseScopesStack.push(a),a}removeScopeLevel(){return this.parseScopesStack.pop(),this}addMaterial(e){const t=this.getCurrentParseScope().lib;return t[e.userData.code]||this.materials.push(e),t[e.userData.code]=e,this}getMaterial(e){if(e.startsWith("0x2")){const t=e.substring(3);return this.parseColourMetaDirective(new a("Direct_Color_"+t+" CODE -1 VALUE #"+t+" EDGE #"+t))}for(let t=this.parseScopesStack.length-1;t>=0;t--){const n=this.parseScopesStack[t].lib[e];if(n)return n}return null}getParentParseScope(){return this.parseScopesStack.length>1?this.parseScopesStack[this.parseScopesStack.length-2]:null}getCurrentParseScope(){return this.parseScopesStack.length>0?this.parseScopesStack[this.parseScopesStack.length-1]:null}parseColourMetaDirective(t){let n=null,r=16711935,o=16711935,i=1,s=!1,l=0,c=0,u=!0,d=null;const h=t.getToken();if(!h)throw'LDrawLoader: Material name was expected after "!COLOUR tag'+t.getLineNumberString()+".";let p=null;for(;p=t.getToken(),p;)switch(p.toUpperCase()){case"CODE":n=t.getToken();break;case"VALUE":if(r=t.getToken(),r.startsWith("0x"))r="#"+r.substring(2);else if(!r.startsWith("#"))throw"LDrawLoader: Invalid colour while parsing material"+t.getLineNumberString()+".";break;case"EDGE":if(o=t.getToken(),o.startsWith("0x"))o="#"+o.substring(2);else if(!o.startsWith("#")){if(d=this.getMaterial(o),!d)throw"LDrawLoader: Invalid edge colour while parsing material"+t.getLineNumberString()+".";d=d.userData.edgeMaterial}break;case"ALPHA":if(i=parseInt(t.getToken()),isNaN(i))throw"LDrawLoader: Invalid alpha value in material definition"+t.getLineNumberString()+".";i=Math.max(0,Math.min(1,i/255)),i<1&&(s=!0);break;case"LUMINANCE":if(l=parseInt(t.getToken()),isNaN(l))throw"LDrawLoader: Invalid luminance value in material definition"+a.getLineNumberString()+".";l=Math.max(0,Math.min(1,l/255));break;case"CHROME":c=1;break;case"PEARLESCENT":c=2;break;case"RUBBER":c=3;break;case"MATTE_METALLIC":c=4;break;case"METAL":c=5;break;case"MATERIAL":t.setToEnd();break;default:throw'LDrawLoader: Unknown token "'+p+'" while parsing material'+t.getLineNumberString()+"."}let g=null;switch(c){case 0:g=new e.MeshStandardMaterial({color:r,roughness:.3,envMapIntensity:.3,metalness:0});break;case 2:const t=new e.Color(r),n=t.getHSL({h:0,s:0,l:0});n.h=(n.h+.5)%1,n.l=Math.min(1,n.l+.7*(1-n.l)),t.setHSL(n.h,n.s,n.l),g=new e.MeshPhongMaterial({color:r,specular:t,shininess:10,reflectivity:.3});break;case 1:g=new e.MeshStandardMaterial({color:r,roughness:0,metalness:1});break;case 3:g=new e.MeshStandardMaterial({color:r,roughness:.9,metalness:0}),u=!1;break;case 4:g=new e.MeshStandardMaterial({color:r,roughness:.8,metalness:.4});break;case 5:g=new e.MeshStandardMaterial({color:r,roughness:.2,metalness:.85})}return g.transparent=s,g.premultipliedAlpha=!0,g.opacity=i,g.depthWrite=!s,g.polygonOffset=!0,g.polygonOffsetFactor=1,g.userData.canHaveEnvMap=u,0!==l&&g.emissive.set(g.color).multiplyScalar(l),d||(d=new e.LineBasicMaterial({color:o,transparent:s,opacity:i,depthWrite:!s}),d.userData.code=n,d.name=h+" - Edge",d.userData.canHaveEnvMap=!1,d.userData.conditionalEdgeMaterial=new e.ShaderMaterial({vertexShader:"\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t",fragmentShader:"\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t",uniforms:e.UniformsUtils.merge([e.UniformsLib.fog,{diffuse:{value:new e.Color(o)},opacity:{value:i}}]),fog:!0,transparent:s,depthWrite:!s}),d.userData.conditionalEdgeMaterial.userData.canHaveEnvMap=!1),g.userData.code=n,g.name=h,g.userData.edgeMaterial=d,g}objectParse(o){const i=this.getParentParseScope(),s=i.mainColourCode,l=i.mainEdgeColourCode,c=this.getCurrentParseScope();let u,d,h;const p=[];let g=null,m=null;-1!==o.indexOf("\r\n")&&(o=o.replace(/\r\n/g,"\n"));const f=o.split("\n"),b=f.length;let v=!1,C=null,S=null,x=!1,w=!0,k=!1,M=!0,L="",y=!1;const D=this;function N(e,t){let n=e.getToken();t||"16"!==n||(n=s),t&&"24"===n&&(n=l);const r=D.getMaterial(n);if(!r)throw'LDrawLoader: Unknown colour code "'+n+'" is used'+e.getLineNumberString()+" but it was not defined previously.";return r}function E(t){const n=new e.Vector3(parseFloat(t.getToken()),parseFloat(t.getToken()),parseFloat(t.getToken()));return D.separateObjects||n.applyMatrix4(c.currentMatrix),n}for(let o=0;o<b;o++){const s=f[o];if(0===s.length)continue;if(v){s.startsWith("0 FILE ")?(this.subobjectCache[C.toLowerCase()]=S,C=s.substring(7),S=""):S+=s+"\n";continue}const l=new a(s,o+1);if(l.seekNonSpace(),l.isAtTheEnd())continue;const b=l.getToken();let F,T,j,_,O,A,I,P,V,z;switch(b){case"0":const a=l.getToken();if(a)switch(a){case"!LDRAW_ORG":L=l.getToken(),c.triangles=[],c.lineSegments=[],c.conditionalSegments=[],c.type=L;(!i.isFromParse||D.separateObjects&&!r(L))&&(c.groupObject=new e.Group,c.groupObject.userData.startingConstructionStep=c.startingConstructionStep),c.matrix.determinant()<0&&(D.separateObjects&&r(L)||!D.separateObjects)&&(c.inverted=!c.inverted),u=c.triangles,d=c.lineSegments,h=c.conditionalSegments;break;case"!COLOUR":F=this.parseColourMetaDirective(l),F?this.addMaterial(F):console.warn("LDrawLoader: Error parsing material"+l.getLineNumberString());break;case"!CATEGORY":g=l.getToken();break;case"!KEYWORDS":const t=l.getRemainingString().split(",");t.length>0&&(m||(m=[]),t.forEach((function(e){m.push(e.trim())})));break;case"FILE":o>0&&(v=!0,C=l.getRemainingString(),S="",x=!1,w=!0);break;case"BFC":for(;!l.isAtTheEnd();){const e=l.getToken();switch(e){case"CERTIFY":case"NOCERTIFY":x="CERTIFY"===e,w=!0;break;case"CW":case"CCW":w="CCW"===e;break;case"INVERTNEXT":k=!0;break;case"CLIP":case"NOCLIP":M="CLIP"===e;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+e+'" is unknown.')}}break;case"STEP":y=!0}break;case"1":F=N(l);const s=parseFloat(l.getToken()),f=parseFloat(l.getToken()),R=parseFloat(l.getToken()),W=parseFloat(l.getToken()),$=parseFloat(l.getToken()),U=parseFloat(l.getToken()),G=parseFloat(l.getToken()),H=parseFloat(l.getToken()),B=parseFloat(l.getToken()),q=parseFloat(l.getToken()),Y=parseFloat(l.getToken()),K=parseFloat(l.getToken()),X=(new e.Matrix4).set(W,$,U,s,G,H,B,f,q,Y,K,R,0,0,0,1);let J=l.getRemainingString().trim().replace(/\\/g,"/");D.fileMap[J]?J=D.fileMap[J]:J.startsWith("s/")?J="parts/"+J:J.startsWith("48/")&&(J="p/"+J),p.push({material:F,matrix:X,fileName:J,originalFileName:J,locationState:0,url:null,triedLowerCase:!1,inverted:k!==c.inverted,startingConstructionStep:y}),k=!1;break;case"2":F=N(l,!0),T={material:F.userData.edgeMaterial,colourCode:F.userData.code,v0:E(l),v1:E(l)},d.push(T);break;case"5":F=N(l,!0),T={material:F.userData.edgeMaterial.userData.conditionalEdgeMaterial,colourCode:F.userData.code,v0:E(l),v1:E(l),c0:E(l),c1:E(l)},h.push(T);break;case"3":F=N(l),j=c.inverted,_=w!==j,O=!x||!M,!0===_?(A=E(l),I=E(l),P=E(l)):(P=E(l),I=E(l),A=E(l)),t.subVectors(I,A),n.subVectors(P,I),z=(new e.Vector3).crossVectors(t,n).normalize(),u.push({material:F,colourCode:F.userData.code,v0:A,v1:I,v2:P,faceNormal:z,n0:null,n1:null,n2:null}),!0===O&&u.push({material:F,colourCode:F.userData.code,v0:A,v1:P,v2:I,faceNormal:z,n0:null,n1:null,n2:null});break;case"4":F=N(l),j=c.inverted,_=w!==j,O=!x||!M,!0===_?(A=E(l),I=E(l),P=E(l),V=E(l)):(V=E(l),P=E(l),I=E(l),A=E(l)),t.subVectors(I,A),n.subVectors(P,I),z=(new e.Vector3).crossVectors(t,n).normalize(),u.push({material:F,colourCode:F.userData.code,v0:A,v1:I,v2:P,faceNormal:z,n0:null,n1:null,n2:null}),u.push({material:F,colourCode:F.userData.code,v0:A,v1:P,v2:V,faceNormal:z,n0:null,n1:null,n2:null}),!0===O&&(u.push({material:F,colourCode:F.userData.code,v0:A,v1:P,v2:I,faceNormal:z,n0:null,n1:null,n2:null}),u.push({material:F,colourCode:F.userData.code,v0:A,v1:V,v2:P,faceNormal:z,n0:null,n1:null,n2:null}));break;default:throw'LDrawLoader: Unknown line type "'+b+'"'+l.getLineNumberString()+"."}}v&&(this.subobjectCache[C.toLowerCase()]=S),c.category=g,c.keywords=m,c.subobjects=p,c.numSubobjects=p.length,c.subobjectIndex=0}computeConstructionSteps(e){let t=0;e.traverse((e=>{e.isGroup&&(e.userData.startingConstructionStep&&t++,e.userData.constructionStep=t)})),e.userData.numConstructionSteps=t+1}processObject(a,o,s,l){const c=this,u=c.newParseScopeLevel();u.url=l;const d=c.getParentParseScope();s&&(u.currentMatrix.multiplyMatrices(d.currentMatrix,s.matrix),u.matrix.copy(s.matrix),u.inverted=s.inverted,u.startingConstructionStep=s.startingConstructionStep);let h=d.currentFileName;null!==h&&(h=d.currentFileName.toLowerCase()),void 0===c.subobjectCache[h]&&(c.subobjectCache[h]=a),c.objectParse(a);let p=0;function g(){if(p++,p===u.subobjects.length+1)!function(){c.smoothNormals&&"Part"===u.type&&function(e,t){function n(e){return`${~~(100*e.x)},${~~(100*e.y)},${~~(100*e.z)}`}function r(e,t){return`${n(e)}_${n(t)}`}const a=new Set,o={},i={},s=[];for(let e=0,n=t.length;e<n;e++){const n=t[e],o=n.v0,i=n.v1;a.add(r(o,i)),a.add(r(i,o))}for(let t=0,n=e.length;t<n;t++){const n=e[t];for(let e=0,t=3;e<t;e++){const t=(e+1)%3,s=r(n[`v${e}`],n[`v${t}`]);a.has(s)||(o[s]=n,i[s]=n)}}for(;;){const e=Object.keys(o);if(0===e.length)break;let t=0;const n=[i[e[0]]];for(;t<n.length;){const e=n[t];t++;const a=e.faceNormal;null===e.n0&&(e.n0=a.clone(),s.push(e.n0)),null===e.n1&&(e.n1=a.clone(),s.push(e.n1)),null===e.n2&&(e.n2=a.clone(),s.push(e.n2));for(let t=0,a=3;t<a;t++){const a=t,s=(t+1)%3,l=e[`v${a}`],c=e[`v${s}`];delete o[r(l,c)];const u=r(c,l),d=i[u];if(d){if(Math.abs(d.faceNormal.dot(e.faceNormal))<.25)continue;u in o&&(n.push(d),delete o[u]);for(let t=0,n=3;t<n;t++){const n=t,o=(t+1)%3;if(r(d[`v${n}`],d[`v${o}`])===u){if(null===d[`n${n}`]){const t=e[`n${s}`];d[`n${n}`]=t,t.add(d.faceNormal)}if(null===d[`n${o}`]){const t=e[`n${a}`];d[`n${o}`]=t,t.add(d.faceNormal)}break}}}}}}for(let e=0,t=s.length;e<t;e++)s[e].normalize()}(u.triangles,u.lineSegments);const e=!d.isFromParse;if(c.separateObjects&&!r(u.type)||e){const e=u.groupObject;u.triangles.length>0&&e.add(i(u.triangles,3)),u.lineSegments.length>0&&e.add(i(u.lineSegments,2)),u.conditionalSegments.length>0&&e.add(i(u.conditionalSegments,2,!0)),d.groupObject&&(e.name=u.fileName,e.userData.category=u.category,e.userData.keywords=u.keywords,u.matrix.decompose(e.position,e.quaternion,e.scale),d.groupObject.add(e))}else{const e=c.separateObjects,r=d.lineSegments,a=d.conditionalSegments,o=d.triangles,i=u.lineSegments,s=u.conditionalSegments,l=u.triangles;for(let t=0,n=i.length;t<n;t++){const n=i[t];e&&(n.v0.applyMatrix4(u.matrix),n.v1.applyMatrix4(u.matrix)),r.push(n)}for(let t=0,n=s.length;t<n;t++){const n=s[t];e&&(n.v0.applyMatrix4(u.matrix),n.v1.applyMatrix4(u.matrix),n.c0.applyMatrix4(u.matrix),n.c1.applyMatrix4(u.matrix)),a.push(n)}for(let r=0,a=l.length;r<a;r++){const a=l[r];e&&(a.v0=a.v0.clone().applyMatrix4(u.matrix),a.v1=a.v1.clone().applyMatrix4(u.matrix),a.v2=a.v2.clone().applyMatrix4(u.matrix),t.subVectors(a.v1,a.v0),n.subVectors(a.v2,a.v1),a.faceNormal.crossVectors(t,n).normalize()),o.push(a)}}c.removeScopeLevel(),d.isFromParse||c.computeConstructionSteps(u.groupObject);o&&o(u.groupObject)}();else{const e=u.subobjects[u.subobjectIndex];Promise.resolve().then((function(){m(e)})),u.subobjectIndex++}}function m(t){u.mainColourCode=t.material.userData.code,u.mainEdgeColourCode=t.material.userData.edgeMaterial.userData.code,u.currentFileName=t.originalFileName;const n=c.subobjectCache[t.originalFileName.toLowerCase()];if(n)return void c.processObject(n,(function(e){f(e,t),g()}),t,l);let r=t.fileName,a=6;switch(t.locationState){case 0:a=t.locationState+1;break;case 1:r="parts/"+r,a=t.locationState+1;break;case 2:r="p/"+r,a=t.locationState+1;break;case 3:r="models/"+r,a=t.locationState+1;break;case 4:r=l.substring(0,l.lastIndexOf("/")+1)+r,a=t.locationState+1;break;case 5:t.triedLowerCase?a=6:(t.fileName=t.fileName.toLowerCase(),r=t.fileName,t.triedLowerCase=!0,a=0);break;case 6:return void console.warn('LDrawLoader: Subobject "'+t.originalFileName+'" could not be found.')}t.locationState=a,t.url=r;const o=new e.FileLoader(c.manager);o.setPath(c.path),o.setRequestHeader(c.requestHeader),o.setWithCredentials(c.withCredentials),o.load(r,(function(e){c.processObject(e,(function(e){f(e,t),g()}),t,l)}),void 0,(function(e){!function(e,t){m(t)}(0,t)}),t)}function f(e,t){null!==e?c.fileMap[t.originalFileName]=t.url:m(t)}g()}}exports.LDrawLoader=s;
