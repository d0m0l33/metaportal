{"ast":null,"code":"import { Vector3, Matrix4 } from 'three';\nconst inverseProjectionMatrix = new Matrix4();\n\nclass Frustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n    }\n  }\n\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(v => {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(v => {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\n      }\n    });\n    return this.vertices;\n  }\n\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new Frustum());\n    }\n\n    target.length = breaks.length;\n\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n\n      if (i === breaks - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n\n}\n\nexport default Frustum;","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/csm/Frustum.js"],"names":["Vector3","Matrix4","inverseProjectionMatrix","Frustum","constructor","data","vertices","near","far","projectionMatrix","undefined","setFromProjectionMatrix","maxFar","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","split","breaks","target","length","push","i","cascade","j","lerpVectors","toSpace","cameraMatrix"],"mappings":"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","sourcesContent":["import { Vector3, Matrix4 } from 'three';\n\nconst inverseProjectionMatrix = new Matrix4();\nclass Frustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n    }\n  }\n\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(v => {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(v => {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\n      }\n    });\n    return this.vertices;\n  }\n\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new Frustum());\n    }\n\n    target.length = breaks.length;\n\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n\n      if (i === breaks - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n\n}\n\nexport default Frustum;\n"]},"metadata":{},"sourceType":"module"}