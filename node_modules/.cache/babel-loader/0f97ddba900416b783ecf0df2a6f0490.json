{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\nimport { getValidBadges, parseResponseForItems } from './BadgeHelper';\nimport { ChainId, useEthers } from '@usedapp/core';\nimport { getTransactionsFor } from './TransactionsAPI';\nimport { BADGE_LIST, DEFAULT_BADGELIST } from './Badges';\nexport function useBadgeList(signerAddress, overrideChainId, tags) {\n  _s();\n\n  const {\n    account,\n    chainId\n  } = useEthers();\n  const adjustedChainId = chainId === 31337 ? ChainId.Mainnet : chainId;\n  console.log('chainId : ', chainId);\n  const [badges, setBadges] = useState();\n  useEffect(() => {\n    getTransactionsFor(signerAddress, adjustedChainId).then(async response => {\n      if (response) {\n        const transactionItems = parseResponseForItems(response);\n        console.log(transactionItems);\n\n        if (transactionItems) {\n          const badges = getValidBadges(BADGE_LIST, transactionItems);\n          badges.push(DEFAULT_BADGELIST[0]);\n          badges.push(DEFAULT_BADGELIST[1]);\n          setBadges(badges);\n        } else {\n          // should do something with this case\n          // in theory there should always be the defalt badge\n          // if an account is connected\n          setBadges(undefined);\n        }\n      } else {\n        const errorMessage = 'Couldnt fetch transaction data';\n        return Promise.reject(new Error(errorMessage));\n      }\n    }).catch(err => {\n      console.log(err);\n      setBadges(undefined);\n    });\n  }, [account, chainId]);\n  return badges;\n}\n\n_s(useBadgeList, \"za+HcmNLDupZP+UeVLievoaZZ4E=\", false, function () {\n  return [useEthers];\n});","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/src/portalHooks/useBadgeList.ts"],"names":["useEffect","useState","getValidBadges","parseResponseForItems","ChainId","useEthers","getTransactionsFor","BADGE_LIST","DEFAULT_BADGELIST","useBadgeList","signerAddress","overrideChainId","tags","account","chainId","adjustedChainId","Mainnet","console","log","badges","setBadges","then","response","transactionItems","push","undefined","errorMessage","Promise","reject","Error","catch","err"],"mappings":";;AACA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,SAASC,cAAT,EAAyBC,qBAAzB,QAAsD,eAAtD;AACA,SAASC,OAAT,EAAkBC,SAAlB,QAAmC,eAAnC;AACA,SAASC,kBAAT,QAAmC,mBAAnC;AAEA,SAASC,UAAT,EAAqBC,iBAArB,QAA8C,UAA9C;AAIA,OAAO,SAASC,YAAT,CAAsBC,aAAtB,EAA4DC,eAA5D,EAAuFC,IAAvF,EAAwG;AAAA;;AAC7G,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAuBT,SAAS,EAAtC;AACA,QAAMU,eAAe,GAAGD,OAAO,KAAK,KAAZ,GAAoBV,OAAO,CAACY,OAA5B,GAAsCF,OAA9D;AAEAG,EAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAAyBJ,OAAzB;AACA,QAAM,CAACK,MAAD,EAASC,SAAT,IAAsBnB,QAAQ,EAApC;AACAD,EAAAA,SAAS,CAAC,MAAM;AACdM,IAAAA,kBAAkB,CAACI,aAAD,EAAgBK,eAAhB,CAAlB,CACGM,IADH,CACQ,MAAOC,QAAP,IAAoB;AACxB,UAAIA,QAAJ,EAAc;AACV,cAAMC,gBAAgB,GAAGpB,qBAAqB,CAACmB,QAAD,CAA9C;AACAL,QAAAA,OAAO,CAACC,GAAR,CAAYK,gBAAZ;;AACA,YAAGA,gBAAH,EAAqB;AACjB,gBAAMJ,MAAM,GAAGjB,cAAc,CAACK,UAAD,EAAYgB,gBAAZ,CAA7B;AACAJ,UAAAA,MAAM,CAACK,IAAP,CAAYhB,iBAAiB,CAAC,CAAD,CAA7B;AACAW,UAAAA,MAAM,CAACK,IAAP,CAAYhB,iBAAiB,CAAC,CAAD,CAA7B;AAEAY,UAAAA,SAAS,CAACD,MAAD,CAAT;AACH,SAND,MAMO;AACH;AACA;AACA;AACAC,UAAAA,SAAS,CAACK,SAAD,CAAT;AACH;AACJ,OAfD,MAeO;AACL,cAAMC,YAAY,GAAG,gCAArB;AACA,eAAOC,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAUH,YAAV,CAAf,CAAP;AACD;AACF,KArBH,EAsBGI,KAtBH,CAsBUC,GAAD,IAAS;AACdd,MAAAA,OAAO,CAACC,GAAR,CAAYa,GAAZ;AACAX,MAAAA,SAAS,CAACK,SAAD,CAAT;AACD,KAzBH;AA0BD,GA3BQ,EA2BN,CAACZ,OAAD,EAASC,OAAT,CA3BM,CAAT;AA4BA,SAAOK,MAAP;AACD;;GAnCeV,Y;UACeJ,S","sourcesContent":["import axios, { AxiosResponse } from 'axios'\nimport { useEffect, useState } from 'react'\nimport { getValidBadges, parseResponseForItems } from './BadgeHelper'\nimport { ChainId, useEthers } from '@usedapp/core'\nimport { getTransactionsFor } from './TransactionsAPI'\nimport { Badge } from './BadgeHelperTypes'\nimport { BADGE_LIST, DEFAULT_BADGELIST } from './Badges'\n\n\n\nexport function useBadgeList(signerAddress: string|null|undefined, overrideChainId?: ChainId, tags?: string[]) {\n  const { account, chainId } = useEthers();\n  const adjustedChainId = chainId === 31337 ? ChainId.Mainnet : chainId;\n\n  console.log('chainId : ',chainId)\n  const [badges, setBadges] = useState<Badge[]>()\n  useEffect(() => {\n    getTransactionsFor(signerAddress, adjustedChainId)\n      .then(async (response) => {\n        if (response) {\n            const transactionItems = parseResponseForItems(response);\n            console.log(transactionItems)\n            if(transactionItems) {\n                const badges = getValidBadges(BADGE_LIST,transactionItems);\n                badges.push(DEFAULT_BADGELIST[0]);\n                badges.push(DEFAULT_BADGELIST[1]);\n\n                setBadges(badges);\n            } else {\n                // should do something with this case\n                // in theory there should always be the defalt badge\n                // if an account is connected\n                setBadges(undefined);\n            }\n        } else {\n          const errorMessage = 'Couldnt fetch transaction data';\n          return Promise.reject(new Error(errorMessage))\n        }\n      })\n      .catch((err) => {\n        console.log(err)\n        setBadges(undefined)\n      })\n  }, [account,chainId])\n  return badges\n}\n"]},"metadata":{},"sourceType":"module"}