{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from 'three';\n\nclass ColladaExporter {\n  constructor() {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"geometryInfo\", void 0);\n\n    _defineProperty(this, \"materialMap\", void 0);\n\n    _defineProperty(this, \"imageMap\", void 0);\n\n    _defineProperty(this, \"textures\", void 0);\n\n    _defineProperty(this, \"libraryImages\", void 0);\n\n    _defineProperty(this, \"libraryGeometries\", void 0);\n\n    _defineProperty(this, \"libraryEffects\", void 0);\n\n    _defineProperty(this, \"libraryMaterials\", void 0);\n\n    _defineProperty(this, \"canvas\", void 0);\n\n    _defineProperty(this, \"ctx\", void 0);\n\n    _defineProperty(this, \"transMat\", void 0);\n\n    _defineProperty(this, \"getFuncs\", ['getX', 'getY', 'getZ', 'getW']);\n\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = new WeakMap();\n    this.materialMap = new WeakMap();\n    this.imageMap = new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n\n  parse(object, onDone) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.options = { ...this.options,\n      ...options\n    };\n\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.');\n      return null;\n    }\n\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.');\n      return null;\n    }\n\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.');\n      return null;\n    }\n\n    if (this.options.textureDirectory !== '') {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n    }\n\n    if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    }\n\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : ''}</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${this.libraryImages.join('')}</library_images>`;\n    dae += `<library_effects>${this.libraryEffects.join('')}</library_effects>`;\n    dae += `<library_materials>${this.libraryMaterials.join('')}</library_materials>`;\n    dae += `<library_geometries>${this.libraryGeometries.join('')}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += '</COLLADA>';\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res));\n    }\n\n    return res;\n  } // Convert the urdf xml into a well-formatted, indented format\n\n\n  format(urdf) {\n    var _urdf$match$map$join, _urdf$match;\n\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : '';\n\n    let tagnum = 0;\n    return (_urdf$match$map$join = (_urdf$match = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) === null || _urdf$match === void 0 ? void 0 : _urdf$match.map(tag => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n\n      const res = `${pad('  ', tagnum)}${tag}`;\n\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n\n      return res;\n    }).join('\\n')) != null ? _urdf$match$map$join : '';\n  } // Convert an image into a png format for saving\n\n\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n\n    return buf;\n  }\n\n  imageToData(image, ext) {\n    var _this$ctx;\n\n    this.canvas = this.canvas || document.createElement('canvas');\n    this.ctx = this.ctx || this.canvas.getContext('2d');\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_this$ctx = this.ctx) === null || _this$ctx === void 0 ? void 0 : _this$ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n    return this.base64ToBuffer(base64data);\n  } // gets the attribute array. Generate a new array if the attribute is interleaved\n\n\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      // use the typed array constructor to save on memory\n      const TypedArrayConstructor = attr.array.constructor; // @ts-expect-error\n\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n\n      return arr;\n    } else {\n      return attr.array;\n    }\n  } // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n\n\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor; // @ts-expect-error\n\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  } // Returns the string for a geometry's attribute\n\n\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? `${`<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join('')}</accessor></technique_common></source>` : '';\n    return res;\n  } // Returns the string for a node's transform information\n\n\n  getTransform(o) {\n    // ensure the object's matrix is up to date\n    // before saving the transform\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return `<matrix>${this.transMat.toArray().join(' ')}</matrix>`;\n  } // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n\n\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n\n    if (!info) {\n      // convert the geometry to bufferGeometry if it isn't already\n      const bufferGeometry = g;\n\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`;\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n        start: 0,\n        count: indexCount,\n        materialIndex: 0\n      }];\n      const gname = g.name ? ` name=\"${g.name}\"` : '';\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`; // define the geometry node and the vertices for the geometry\n\n      const posName = `${meshid}-position`;\n      const vertName = `${meshid}-vertices`;\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`; // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n      // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n      // models with attributes that share an offset.\n      // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n      // serialize normals\n\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n\n      if ('normal' in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`;\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n      } // serialize uvs\n\n\n      if ('uv' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n      } // serialize lightmap uvs\n\n\n      if ('uv2' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float');\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n      } // serialize colors\n\n\n      if ('color' in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`;\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n      }\n\n      let indexArray = null;\n\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i;\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n        gnode += triangleInputs;\n        gnode += `<p>${subarr.join(' ')}</p>`;\n        gnode += '</triangles>';\n      }\n\n      gnode += '</mesh></geometry>';\n      this.libraryGeometries.push(gnode);\n      info = {\n        meshid,\n        bufferGeometry\n      };\n      this.geometryInfo.set(g, info);\n    }\n\n    return info;\n  } // Process the given texture into the image library\n  // Returns the image library\n\n\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`;\n      const ext = 'png';\n      const name = tex.name || texid;\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n\n      if (this.options.version === '1.5.0') {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;\n      } else {\n        // version image node 1.4.1\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;\n      }\n\n      imageNode += '</image>';\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n\n    return texid;\n  } // Process the given material into the material and effect libraries\n  // Returns the material id\n\n\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`;\n      let type = 'phong';\n\n      if (m instanceof MeshLambertMaterial) {\n        type = 'lambert';\n      } else if (m instanceof MeshBasicMaterial) {\n        type = 'constant';\n\n        if (m.map !== null) {\n          // The Collada spec does not support diffuse texture maps with the\n          // constant shader type.\n          // mrdoob/three.js#15469\n          console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n        }\n      }\n\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n\n        let transparencyNode = '';\n\n        if (m.transparent) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'}</transparent>`;\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== 'constant' ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ''}${type !== 'constant' ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>` : ''}${type === 'phong' ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : ''}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ''}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ''}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ''}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ''}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : ''}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : '';\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n\n    return matid;\n  } // Recursively process the object into a scene\n\n\n  processObject(o) {\n    let node = `<node name=\"${o.name}\">`;\n    node += this.getTransform(o);\n    new Mesh();\n\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      // function returns the id associated with the mesh and a \"BufferGeometry\" version\n      // of the geometry in case it's not a geometry.\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n      let matids = null;\n      let matidsArray; // get a list of materials to bind to the sub groups of the geometry.\n      // If the amount of subgroups is greater than the materials, than reuse\n      // the materials.\n\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join('')}</technique_common></bind_material>` : '')}</instance_geometry>`;\n    }\n\n    o.children.forEach(c => node += this.processObject(c));\n    node += '</node>';\n    return node;\n  }\n\n}\n\nexport { ColladaExporter };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/exporters/ColladaExporter.js"],"names":["_defineProperty","InterleavedBufferAttribute","Matrix4","MeshLambertMaterial","MeshBasicMaterial","MeshPhongMaterial","Color","DoubleSide","Mesh","ColladaExporter","constructor","options","version","author","textureDirectory","upAxis","unitName","unitMeter","geometryInfo","WeakMap","materialMap","imageMap","textures","libraryImages","libraryGeometries","libraryEffects","libraryMaterials","canvas","ctx","transMat","parse","object","onDone","match","console","error","replace","warn","libraryVisualScenes","processObject","specLink","dae","Date","toISOString","join","res","data","format","requestAnimationFrame","urdf","_urdf$match$map$join","_urdf$match","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","ch","num","tagnum","map","tag","test","base64ToBuffer","str","b","atob","buf","Uint8Array","length","i","l","charCodeAt","imageToData","image","ext","_this$ctx","document","createElement","getContext","width","SVGAnimatedLength","height","drawImage","base64data","toDataURL","attrBufferToArray","attr","isInterleavedBufferAttribute","TypedArrayConstructor","array","arr","count","itemSize","size","j","getFuncs","subArray","st","ct","Array","isArray","slice","buffer","BYTES_PER_ELEMENT","getAttribute","name","params","type","Math","floor","n","getTransform","o","updateMatrix","copy","matrix","transpose","toArray","processGeometry","g","info","get","bufferGeometry","isBufferGeometry","Error","meshid","indexCount","index","attributes","position","groups","start","materialIndex","gname","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","uv2","colName","color","indexArray","group","subarr","polycount","push","set","processTexture","tex","texid","imageNode","directory","original","processMaterial","m","matid","emissive","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","materialName","materialNode","node","isMesh","geometry","geomInfo","matids","matidsArray","mat","material","materials","fill","_","id","children","forEach","c"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from 'three';\n\nclass ColladaExporter {\n  constructor() {\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"geometryInfo\", void 0);\n\n    _defineProperty(this, \"materialMap\", void 0);\n\n    _defineProperty(this, \"imageMap\", void 0);\n\n    _defineProperty(this, \"textures\", void 0);\n\n    _defineProperty(this, \"libraryImages\", void 0);\n\n    _defineProperty(this, \"libraryGeometries\", void 0);\n\n    _defineProperty(this, \"libraryEffects\", void 0);\n\n    _defineProperty(this, \"libraryMaterials\", void 0);\n\n    _defineProperty(this, \"canvas\", void 0);\n\n    _defineProperty(this, \"ctx\", void 0);\n\n    _defineProperty(this, \"transMat\", void 0);\n\n    _defineProperty(this, \"getFuncs\", ['getX', 'getY', 'getZ', 'getW']);\n\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = new WeakMap();\n    this.materialMap = new WeakMap();\n    this.imageMap = new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n\n  parse(object, onDone, options = {}) {\n    this.options = { ...this.options,\n      ...options\n    };\n\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.');\n      return null;\n    }\n\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.');\n      return null;\n    }\n\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.');\n      return null;\n    }\n\n    if (this.options.textureDirectory !== '') {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n    }\n\n    if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    }\n\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : ''}</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${this.libraryImages.join('')}</library_images>`;\n    dae += `<library_effects>${this.libraryEffects.join('')}</library_effects>`;\n    dae += `<library_materials>${this.libraryMaterials.join('')}</library_materials>`;\n    dae += `<library_geometries>${this.libraryGeometries.join('')}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += '</COLLADA>';\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res));\n    }\n\n    return res;\n  } // Convert the urdf xml into a well-formatted, indented format\n\n\n  format(urdf) {\n    var _urdf$match$map$join, _urdf$match;\n\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : '';\n\n    let tagnum = 0;\n    return (_urdf$match$map$join = (_urdf$match = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) === null || _urdf$match === void 0 ? void 0 : _urdf$match.map(tag => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n\n      const res = `${pad('  ', tagnum)}${tag}`;\n\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n\n      return res;\n    }).join('\\n')) != null ? _urdf$match$map$join : '';\n  } // Convert an image into a png format for saving\n\n\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n\n    return buf;\n  }\n\n  imageToData(image, ext) {\n    var _this$ctx;\n\n    this.canvas = this.canvas || document.createElement('canvas');\n    this.ctx = this.ctx || this.canvas.getContext('2d');\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_this$ctx = this.ctx) === null || _this$ctx === void 0 ? void 0 : _this$ctx.drawImage(image, 0, 0); // Get the base64 encoded data\n\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, ''); // Convert to a uint8 array\n\n    return this.base64ToBuffer(base64data);\n  } // gets the attribute array. Generate a new array if the attribute is interleaved\n\n\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      // use the typed array constructor to save on memory\n      const TypedArrayConstructor = attr.array.constructor; // @ts-expect-error\n\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n\n      return arr;\n    } else {\n      return attr.array;\n    }\n  } // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n\n\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor; // @ts-expect-error\n\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  } // Returns the string for a geometry's attribute\n\n\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? `${`<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join('')}</accessor></technique_common></source>` : '';\n    return res;\n  } // Returns the string for a node's transform information\n\n\n  getTransform(o) {\n    // ensure the object's matrix is up to date\n    // before saving the transform\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return `<matrix>${this.transMat.toArray().join(' ')}</matrix>`;\n  } // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n\n\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n\n    if (!info) {\n      // convert the geometry to bufferGeometry if it isn't already\n      const bufferGeometry = g;\n\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`;\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n        start: 0,\n        count: indexCount,\n        materialIndex: 0\n      }];\n      const gname = g.name ? ` name=\"${g.name}\"` : '';\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`; // define the geometry node and the vertices for the geometry\n\n      const posName = `${meshid}-position`;\n      const vertName = `${meshid}-vertices`;\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float');\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`; // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n      // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n      // models with attributes that share an offset.\n      // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n      // serialize normals\n\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n\n      if ('normal' in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`;\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float');\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n      } // serialize uvs\n\n\n      if ('uv' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float');\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n      } // serialize lightmap uvs\n\n\n      if ('uv2' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float');\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n      } // serialize colors\n\n\n      if ('color' in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`;\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8');\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n      }\n\n      let indexArray = null;\n\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i;\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n        gnode += triangleInputs;\n        gnode += `<p>${subarr.join(' ')}</p>`;\n        gnode += '</triangles>';\n      }\n\n      gnode += '</mesh></geometry>';\n      this.libraryGeometries.push(gnode);\n      info = {\n        meshid,\n        bufferGeometry\n      };\n      this.geometryInfo.set(g, info);\n    }\n\n    return info;\n  } // Process the given texture into the image library\n  // Returns the image library\n\n\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`;\n      const ext = 'png';\n      const name = tex.name || texid;\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n\n      if (this.options.version === '1.5.0') {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;\n      } else {\n        // version image node 1.4.1\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;\n      }\n\n      imageNode += '</image>';\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n\n    return texid;\n  } // Process the given material into the material and effect libraries\n  // Returns the material id\n\n\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`;\n      let type = 'phong';\n\n      if (m instanceof MeshLambertMaterial) {\n        type = 'lambert';\n      } else if (m instanceof MeshBasicMaterial) {\n        type = 'constant';\n\n        if (m.map !== null) {\n          // The Collada spec does not support diffuse texture maps with the\n          // constant shader type.\n          // mrdoob/three.js#15469\n          console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n        }\n      }\n\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0; // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n\n        let transparencyNode = '';\n\n        if (m.transparent) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'}</transparent>`;\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== 'constant' ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : ''}${type !== 'constant' ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>` : ''}${type === 'phong' ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : ''}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : ''}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : ''}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : ''}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : ''}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : ''}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : '';\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n\n    return matid;\n  } // Recursively process the object into a scene\n\n\n  processObject(o) {\n    let node = `<node name=\"${o.name}\">`;\n    node += this.getTransform(o);\n    new Mesh();\n\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      // function returns the id associated with the mesh and a \"BufferGeometry\" version\n      // of the geometry in case it's not a geometry.\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry; // ids of the materials to bind to the geometry\n\n      let matids = null;\n      let matidsArray; // get a list of materials to bind to the sub groups of the geometry.\n      // If the amount of subgroups is greater than the materials, than reuse\n      // the materials.\n\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join('')}</technique_common></bind_material>` : '')}</instance_geometry>`;\n    }\n\n    o.children.forEach(c => node += this.processObject(c));\n    node += '</node>';\n    return node;\n  }\n\n}\n\nexport { ColladaExporter };\n"]},"metadata":{},"sourceType":"module"}