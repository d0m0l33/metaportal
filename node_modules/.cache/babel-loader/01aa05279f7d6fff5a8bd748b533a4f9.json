{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, RGBAFormat, RGBFormat, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { createToken, Lexer, CstParser } from 'chevrotain';\n\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data, path) {\n    const nodeMap = {};\n\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n      const lexingResult = lexer.lex(data);\n      parser.input = lexingResult.tokens; // parsing\n\n      const cstOutput = parser.vrml();\n\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error('THREE.VRMLLoader: Parsing errors detected.');\n      } // actions\n\n\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n\n    function createTokens() {\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n      'Inline', 'LOD', 'Switch', // special groups\n      'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n      'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n      'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n      'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n      'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n      'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n      'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n      'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ]; //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier\n      }); //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n      });\n      const HexLiteral = createToken({\n        name: 'HexLiteral',\n        pattern: /0[xX][0-9a-fA-F]+/\n      });\n      const NumberLiteral = createToken({\n        name: 'NumberLiteral',\n        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n      });\n      const TrueLiteral = createToken({\n        name: 'TrueLiteral',\n        pattern: /TRUE/\n      });\n      const FalseLiteral = createToken({\n        name: 'FalseLiteral',\n        pattern: /FALSE/\n      });\n      const NullLiteral = createToken({\n        name: 'NullLiteral',\n        pattern: /NULL/\n      });\n      const LSquare = createToken({\n        name: 'LSquare',\n        pattern: /\\[/\n      });\n      const RSquare = createToken({\n        name: 'RSquare',\n        pattern: /]/\n      });\n      const LCurly = createToken({\n        name: 'LCurly',\n        pattern: /{/\n      });\n      const RCurly = createToken({\n        name: 'RCurly',\n        pattern: /}/\n      });\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n      }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n      });\n      const tokens = [WhiteSpace, // keywords appear before the Identifier\n      NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n      Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n      const tokenVocabulary = {};\n\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n\n      return {\n        tokens: tokens,\n        tokenVocabulary: tokenVocabulary\n      };\n    }\n\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function (ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data.nodes.push(this.visit(node));\n          }\n\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data.routes.push(this.visit(route));\n            }\n          }\n\n          return data;\n        },\n        version: function (ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function (ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data.fields.push(this.visit(field));\n            }\n          } // DEF\n\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0]);\n          }\n\n          return data;\n        },\n        field: function (ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result; // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          } // MFValue\n\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n\n          data.type = result.type;\n          data.values = result.values;\n          return data;\n        },\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function (ctx) {\n          return {\n            USE: (ctx.Identifier || ctx.NodeName)[0].image\n          };\n        },\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        route: function (ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data;\n        }\n      });\n\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n\n        if (ctx.node) {\n          field.type = 'node';\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n\n        if (ctx.use) {\n          field.type = 'use';\n\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n\n        if (ctx.StringLiteral) {\n          field.type = 'string';\n\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n          }\n        }\n\n        if (ctx.NumberLiteral) {\n          field.type = 'number';\n\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n\n        if (ctx.HexLiteral) {\n          field.type = 'hex';\n\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean';\n\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === 'TRUE') field.values.push(true);\n          }\n        }\n\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean';\n\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === 'FALSE') field.values.push(false);\n          }\n        }\n\n        if (ctx.NullLiteral) {\n          field.type = 'null';\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null);\n          });\n        }\n\n        return field;\n      }\n\n      return new VRMLToASTVisitor();\n    }\n\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n      const nodes = tree.nodes;\n      const scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      } // second iteration: build nodes\n\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D) scene.add(object);\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n      }\n\n      return scene;\n    }\n\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n\n        if (field.type === 'node') {\n          const fieldValues = field.values;\n\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n\n    function getNode(node) {\n      // handle case where a node refers to a different one\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n\n      if (node.build !== undefined) return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    } // node builder\n\n\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n\n      switch (nodeName) {\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node);\n          break;\n\n        case 'Background':\n          build = buildBackgroundNode(node);\n          break;\n\n        case 'Shape':\n          build = buildShapeNode(node);\n          break;\n\n        case 'Appearance':\n          build = buildAppearanceNode(node);\n          break;\n\n        case 'Material':\n          build = buildMaterialNode(node);\n          break;\n\n        case 'ImageTexture':\n          build = buildImageTextureNode(node);\n          break;\n\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node);\n          break;\n\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node);\n          break;\n\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node);\n          break;\n\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node);\n          break;\n\n        case 'PointSet':\n          build = buildPointSetNode(node);\n          break;\n\n        case 'Box':\n          build = buildBoxNode(node);\n          break;\n\n        case 'Cone':\n          build = buildConeNode(node);\n          break;\n\n        case 'Cylinder':\n          build = buildCylinderNode(node);\n          break;\n\n        case 'Sphere':\n          build = buildSphereNode(node);\n          break;\n\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node);\n          break;\n\n        case 'Extrusion':\n          build = buildExtrusionNode(node);\n          break;\n\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node);\n          break;\n\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node);\n          break;\n\n        case 'Anchor':\n        case 'Billboard':\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n        case 'Text':\n        case 'FontStyle':\n        case 'MovieTexture':\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break;\n\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n          break;\n      }\n\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF;\n      }\n\n      return build;\n    }\n\n    function buildGroupingNode(node) {\n      const object = new Group(); //\n\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break;\n\n          case 'bboxSize':\n            // field not supported\n            break;\n\n          case 'center':\n            // field not supported\n            break;\n\n          case 'children':\n            parseFieldChildren(fieldValues, object);\n            break;\n\n          case 'collide':\n            // field not supported\n            break;\n\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'scaleOrientation':\n            // field not supported\n            break;\n\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'proxy':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return object;\n    }\n\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues;\n            break;\n\n          case 'groundColor':\n            groundColor = fieldValues;\n            break;\n\n          case 'backUrl':\n            // field not supported\n            break;\n\n          case 'bottomUrl':\n            // field not supported\n            break;\n\n          case 'frontUrl':\n            // field not supported\n            break;\n\n          case 'leftUrl':\n            // field not supported\n            break;\n\n          case 'rightUrl':\n            // field not supported\n            break;\n\n          case 'topUrl':\n            // field not supported\n            break;\n\n          case 'skyAngle':\n            skyAngle = fieldValues;\n            break;\n\n          case 'skyColor':\n            skyColor = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const radius = 10000; // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({\n          fog: false,\n          side: BackSide,\n          depthWrite: false,\n          depthTest: false\n        });\n\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      } // ground\n\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      } // render background group first\n\n\n      group.renderOrder = -Infinity;\n      return group;\n    }\n\n    function buildShapeNode(node) {\n      const fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({\n        color: 0x000000\n      });\n      let geometry;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build 3D object\n\n\n      let object;\n\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n\n        if (type === 'points') {\n          // points\n          const pointsMaterial = new PointsMaterial({\n            color: 0xffffff\n          });\n\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === 'line') {\n          // lines\n          const lineMaterial = new LineBasicMaterial({\n            color: 0xffffff\n          });\n\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          // consider meshes\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          } // check for vertex colors\n\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true;\n          }\n\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false;\n      }\n\n      return object;\n    }\n\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess) material.shininess = materialData.shininess;\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0) material.transparent = true;\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n              material = new MeshBasicMaterial({\n                color: 0x000000\n              });\n            }\n\n            break;\n\n          case 'texture':\n            const textureNode = fieldValues[0];\n\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode);\n              }\n            }\n\n            break;\n\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // only apply texture transform data if a texture was defined\n\n\n      if (material.map) {\n        // respect VRML lighting model\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1; // ignore transparency\n\n              break;\n\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff); // ignore material color\n\n              break;\n\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff); // ignore material color\n\n              material.opacity = 1; // ignore transparency\n\n              break;\n          }\n\n          delete material.map.__type;\n        } // apply texture transform\n\n\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n\n      return material;\n    }\n\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break;\n\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'shininess':\n            materialData.shininess = fieldValues[0];\n            break;\n\n          case 'specularColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'transparency':\n            materialData.transparency = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return materialData;\n    }\n\n    function parseHexColor(hex, textureType, color) {\n      let value;\n\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          break;\n\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt('0x' + hex.substring(4, 6));\n          break;\n\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          break;\n\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = parseInt('0x' + hex.substring(8, 10));\n          break;\n      }\n    }\n\n    function getTextureType(num_components) {\n      let type;\n\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n      }\n\n      return type;\n    }\n\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const useAlpha = num_components === 2 || num_components === 4;\n            const textureType = getTextureType(num_components);\n            const size = (useAlpha === true ? 4 : 3) * (width * height);\n            const data = new Uint8Array(size);\n            const color = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n\n              if (useAlpha === true) {\n                const stride = k * 4;\n                data[stride + 0] = color.r;\n                data[stride + 1] = color.g;\n                data[stride + 2] = color.b;\n                data[stride + 3] = color.a;\n              } else {\n                const stride = k * 3;\n                data[stride + 0] = color.r;\n                data[stride + 1] = color.g;\n                data[stride + 2] = color.b;\n              }\n            }\n\n            texture = new DataTexture(data, width, height, useAlpha === true ? RGBAFormat : RGBFormat);\n            texture.__type = textureType; // needed for material modifications\n\n            break;\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n\n      return texture;\n    }\n\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0];\n            if (url) texture = textureLoader.load(url);\n            break;\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n\n      return texture;\n    }\n\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          case 'rotation':\n            transformData.rotation = fieldValues[0];\n            break;\n\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return transformData;\n    }\n\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0];\n            break;\n\n          case 'info':\n            worldInfo.info = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return worldInfo;\n    }\n\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true,\n          solid = true,\n          creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true,\n          normalPerVertex = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          case 'normal':\n            const normalNode = fieldValues[0];\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n\n            break;\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'convex':\n            // field not supported\n            break;\n\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'normalIndex':\n            normalIndex = fieldValues;\n            break;\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.');\n        return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n      }\n\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          // consider face normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build lines\n\n\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n            const expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n            const flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            const expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          }\n        }\n      } //\n\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      geometry._type = 'line';\n      return geometry;\n    }\n\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n      if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n      geometry._type = 'points';\n      return geometry;\n    }\n\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n\n    function buildConeNode(node) {\n      let radius = 1,\n          height = 2,\n          openEnded = false;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0];\n            break;\n\n          case 'bottomRadius':\n            radius = fieldValues[0];\n            break;\n\n          case 'height':\n            height = fieldValues[0];\n            break;\n\n          case 'side':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n\n    function buildCylinderNode(node) {\n      let radius = 1,\n          height = 2;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break;\n\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n\n          case 'height':\n            height = fieldValues[0];\n            break;\n\n          case 'side':\n            // field not supported\n            break;\n\n          case 'top':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'normal':\n            const normalNode = fieldValues[0];\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n\n            break;\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n\n            break;\n\n          case 'height':\n            height = fieldValues;\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'xDimension':\n            xDimension = fieldValues[0];\n            break;\n\n          case 'xSpacing':\n            xSpacing = fieldValues[0];\n            break;\n\n          case 'zDimension':\n            zDimension = fieldValues[0];\n            break;\n\n          case 'zSpacing':\n            zSpacing = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // vertex data\n\n\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n          const index = i * xDimension + j; // vertices\n\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z); // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          } // normals\n\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          } // uvs\n\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      } // indices\n\n\n      const indices = [];\n\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension; // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      } //\n\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute; // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2]; // one color per quad\n\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      } // normal attribute\n\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2]; // one normal per quad\n\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      } // build geometry\n\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute);\n      geometry.setAttribute('uv', uvAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0];\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'convex':\n            // field not supported\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'crossSection':\n            crossSection = fieldValues;\n            break;\n\n          case 'endCap':\n            endCap = fieldValues[0];\n            break;\n\n          case 'orientation':\n            orientation = fieldValues;\n            break;\n\n          case 'scale':\n            scale = fieldValues;\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'spine':\n            spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1]; // scale\n\n          vertex.multiply(scaling); // rotate\n\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion); // translate\n\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      } // indices\n\n\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      } // triangulate cap\n\n\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        } // begin cap\n\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        } // end cap\n\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n            } else {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n            }\n          }\n        }\n      }\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // no uvs yet\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    } // helper functions\n\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D) owner.add(object);\n      }\n    }\n\n    function triangulateFaceIndex(index, ccw) {\n      const indices = []; // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n\n      return indices;\n    }\n\n    function triangulateFaceData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n\n      return triangulatedData;\n    }\n\n    function flattenData(data, index) {\n      const flattenData = [];\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        flattenData.push(x, y, z);\n      }\n\n      return flattenData;\n    }\n\n    function expandLineIndex(index) {\n      const indices = [];\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n\n      return indices;\n    }\n\n    function expandLineData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n\n      return triangulatedData;\n    }\n\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize);\n          uvB.fromArray(data, b * itemSize);\n          uvC.fromArray(data, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data, a * itemSize);\n          vB.fromArray(data, b * itemSize);\n          vC.fromArray(data, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n\n      return new Float32BufferAttribute(array, itemSize);\n    }\n\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n\n      return new Float32BufferAttribute(array, 3);\n    }\n\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n\n      return new Float32BufferAttribute(array, 3);\n    }\n\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n          index2 = 0;\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n\n    const ab = new Vector3();\n    const cb = new Vector3();\n\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {}; // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n        if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n        if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      } // compute vertex normals and build final geometry\n\n\n      const normals = [];\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n\n      return new Float32BufferAttribute(normals, 3);\n    }\n\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n\n      return normal.normalize();\n    }\n\n    function toColorArray(colors) {\n      const array = [];\n\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n\n      return array;\n    }\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n\n\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      } // generate vertex colors\n\n\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n\n          if (topDown === true) {\n            // interpolation for sky color\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            // interpolation for ground color\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n\n      geometry.setAttribute('color', colorAttribute);\n    } //\n\n\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n    } // create JSON representing the tree structure of the VRML asset\n\n\n    const tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree);\n    return scene;\n  }\n\n}\n\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error('THREE.VRMLLexer: Lexing errors detected.');\n    }\n\n    return lexingResult;\n  }\n\n}\n\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary['Version'];\n    const LCurly = tokenVocabulary['LCurly'];\n    const RCurly = tokenVocabulary['RCurly'];\n    const LSquare = tokenVocabulary['LSquare'];\n    const RSquare = tokenVocabulary['RSquare'];\n    const Identifier = tokenVocabulary['Identifier'];\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    const StringLiteral = tokenVocabulary['StringLiteral'];\n    const HexLiteral = tokenVocabulary['HexLiteral'];\n    const NumberLiteral = tokenVocabulary['NumberLiteral'];\n    const TrueLiteral = tokenVocabulary['TrueLiteral'];\n    const FalseLiteral = tokenVocabulary['FalseLiteral'];\n    const NullLiteral = tokenVocabulary['NullLiteral'];\n    const DEF = tokenVocabulary['DEF'];\n    const USE = tokenVocabulary['USE'];\n    const ROUTE = tokenVocabulary['ROUTE'];\n    const TO = tokenVocabulary['TO'];\n    const NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n\n}\n\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n\n}\n\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/loaders/VRMLLoader.js"],"names":["Loader","LoaderUtils","FileLoader","Vector3","Vector2","TextureLoader","Scene","Object3D","Group","SphereGeometry","MeshBasicMaterial","BackSide","Mesh","PointsMaterial","Points","LineBasicMaterial","LineSegments","FrontSide","DoubleSide","MeshPhongMaterial","Color","DataTexture","RGBAFormat","RGBFormat","BufferGeometry","Float32BufferAttribute","BoxGeometry","ConeGeometry","CylinderGeometry","Quaternion","ShapeUtils","BufferAttribute","RepeatWrapping","ClampToEdgeWrapping","createToken","Lexer","CstParser","VRMLLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","RouteIdentifier","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","call","validateVisitor","prototype","Object","assign","create","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree","scene","buildNodeMap","object","getNode","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","undefined","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","skyMaterial","fog","side","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","geometry","attributes","_type","pointsMaterial","isMeshPhongMaterial","copy","emissive","lineMaterial","_solid","visible","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","parseHexColor","hex","textureType","value","INTENSITY","parseInt","r","g","b","substring","a","getTextureType","num_components","texture","wrapS","wrapT","width","height","useAlpha","size","Uint8Array","k","stride","textureLoader","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","triangulatedCoordIndex","triangulateFaceIndex","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","positionAttribute","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","x","y","z","openEnded","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","normalize","nA","weightedNormal","nB","nC","vector","angleTo","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","Float32Array","count","getX","fromBufferAttribute","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","resourcePath","setCrossOrigin","crossOrigin","indexOf","inputText","tokenize","$","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, RGBAFormat, RGBFormat, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { createToken, Lexer, CstParser } from 'chevrotain';\n\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data, path) {\n    const nodeMap = {};\n\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n      const lexingResult = lexer.lex(data);\n      parser.input = lexingResult.tokens; // parsing\n\n      const cstOutput = parser.vrml();\n\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error('THREE.VRMLLoader: Parsing errors detected.');\n      } // actions\n\n\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n\n    function createTokens() {\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n      'Inline', 'LOD', 'Switch', // special groups\n      'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n      'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n      'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n      'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n      'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n      'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n      'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n      'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ]; //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier\n      }); //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n      });\n      const HexLiteral = createToken({\n        name: 'HexLiteral',\n        pattern: /0[xX][0-9a-fA-F]+/\n      });\n      const NumberLiteral = createToken({\n        name: 'NumberLiteral',\n        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n      });\n      const TrueLiteral = createToken({\n        name: 'TrueLiteral',\n        pattern: /TRUE/\n      });\n      const FalseLiteral = createToken({\n        name: 'FalseLiteral',\n        pattern: /FALSE/\n      });\n      const NullLiteral = createToken({\n        name: 'NullLiteral',\n        pattern: /NULL/\n      });\n      const LSquare = createToken({\n        name: 'LSquare',\n        pattern: /\\[/\n      });\n      const RSquare = createToken({\n        name: 'RSquare',\n        pattern: /]/\n      });\n      const LCurly = createToken({\n        name: 'LCurly',\n        pattern: /{/\n      });\n      const RCurly = createToken({\n        name: 'RCurly',\n        pattern: /}/\n      });\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n      }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED // eslint-disable-line no-undef\n\n      });\n      const tokens = [WhiteSpace, // keywords appear before the Identifier\n      NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n      Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n      const tokenVocabulary = {};\n\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n\n      return {\n        tokens: tokens,\n        tokenVocabulary: tokenVocabulary\n      };\n    }\n\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function (ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data.nodes.push(this.visit(node));\n          }\n\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data.routes.push(this.visit(route));\n            }\n          }\n\n          return data;\n        },\n        version: function (ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function (ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data.fields.push(this.visit(field));\n            }\n          } // DEF\n\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0]);\n          }\n\n          return data;\n        },\n        field: function (ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result; // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          } // MFValue\n\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n\n          data.type = result.type;\n          data.values = result.values;\n          return data;\n        },\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function (ctx) {\n          return {\n            USE: (ctx.Identifier || ctx.NodeName)[0].image\n          };\n        },\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        route: function (ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data;\n        }\n      });\n\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n\n        if (ctx.node) {\n          field.type = 'node';\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n\n        if (ctx.use) {\n          field.type = 'use';\n\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n\n        if (ctx.StringLiteral) {\n          field.type = 'string';\n\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n          }\n        }\n\n        if (ctx.NumberLiteral) {\n          field.type = 'number';\n\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n\n        if (ctx.HexLiteral) {\n          field.type = 'hex';\n\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean';\n\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === 'TRUE') field.values.push(true);\n          }\n        }\n\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean';\n\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === 'FALSE') field.values.push(false);\n          }\n        }\n\n        if (ctx.NullLiteral) {\n          field.type = 'null';\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null);\n          });\n        }\n\n        return field;\n      }\n\n      return new VRMLToASTVisitor();\n    }\n\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n      const nodes = tree.nodes;\n      const scene = new Scene(); // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      } // second iteration: build nodes\n\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D) scene.add(object);\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object;\n      }\n\n      return scene;\n    }\n\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n\n        if (field.type === 'node') {\n          const fieldValues = field.values;\n\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n\n    function getNode(node) {\n      // handle case where a node refers to a different one\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n\n      if (node.build !== undefined) return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    } // node builder\n\n\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n\n      switch (nodeName) {\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node);\n          break;\n\n        case 'Background':\n          build = buildBackgroundNode(node);\n          break;\n\n        case 'Shape':\n          build = buildShapeNode(node);\n          break;\n\n        case 'Appearance':\n          build = buildAppearanceNode(node);\n          break;\n\n        case 'Material':\n          build = buildMaterialNode(node);\n          break;\n\n        case 'ImageTexture':\n          build = buildImageTextureNode(node);\n          break;\n\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node);\n          break;\n\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node);\n          break;\n\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node);\n          break;\n\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node);\n          break;\n\n        case 'PointSet':\n          build = buildPointSetNode(node);\n          break;\n\n        case 'Box':\n          build = buildBoxNode(node);\n          break;\n\n        case 'Cone':\n          build = buildConeNode(node);\n          break;\n\n        case 'Cylinder':\n          build = buildCylinderNode(node);\n          break;\n\n        case 'Sphere':\n          build = buildSphereNode(node);\n          break;\n\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node);\n          break;\n\n        case 'Extrusion':\n          build = buildExtrusionNode(node);\n          break;\n\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node);\n          break;\n\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node);\n          break;\n\n        case 'Anchor':\n        case 'Billboard':\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n        case 'Text':\n        case 'FontStyle':\n        case 'MovieTexture':\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break;\n\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n          break;\n      }\n\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF;\n      }\n\n      return build;\n    }\n\n    function buildGroupingNode(node) {\n      const object = new Group(); //\n\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break;\n\n          case 'bboxSize':\n            // field not supported\n            break;\n\n          case 'center':\n            // field not supported\n            break;\n\n          case 'children':\n            parseFieldChildren(fieldValues, object);\n            break;\n\n          case 'collide':\n            // field not supported\n            break;\n\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'scaleOrientation':\n            // field not supported\n            break;\n\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'proxy':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return object;\n    }\n\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues;\n            break;\n\n          case 'groundColor':\n            groundColor = fieldValues;\n            break;\n\n          case 'backUrl':\n            // field not supported\n            break;\n\n          case 'bottomUrl':\n            // field not supported\n            break;\n\n          case 'frontUrl':\n            // field not supported\n            break;\n\n          case 'leftUrl':\n            // field not supported\n            break;\n\n          case 'rightUrl':\n            // field not supported\n            break;\n\n          case 'topUrl':\n            // field not supported\n            break;\n\n          case 'skyAngle':\n            skyAngle = fieldValues;\n            break;\n\n          case 'skyColor':\n            skyColor = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const radius = 10000; // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({\n          fog: false,\n          side: BackSide,\n          depthWrite: false,\n          depthTest: false\n        });\n\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      } // ground\n\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      } // render background group first\n\n\n      group.renderOrder = -Infinity;\n      return group;\n    }\n\n    function buildShapeNode(node) {\n      const fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({\n        color: 0x000000\n      });\n      let geometry;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build 3D object\n\n\n      let object;\n\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n\n        if (type === 'points') {\n          // points\n          const pointsMaterial = new PointsMaterial({\n            color: 0xffffff\n          });\n\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === 'line') {\n          // lines\n          const lineMaterial = new LineBasicMaterial({\n            color: 0xffffff\n          });\n\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true;\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          // consider meshes\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          } // check for vertex colors\n\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true;\n          }\n\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false;\n      }\n\n      return object;\n    }\n\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess) material.shininess = materialData.shininess;\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0) material.transparent = true;\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n              material = new MeshBasicMaterial({\n                color: 0x000000\n              });\n            }\n\n            break;\n\n          case 'texture':\n            const textureNode = fieldValues[0];\n\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode);\n              }\n            }\n\n            break;\n\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // only apply texture transform data if a texture was defined\n\n\n      if (material.map) {\n        // respect VRML lighting model\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1; // ignore transparency\n\n              break;\n\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff); // ignore material color\n\n              break;\n\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff); // ignore material color\n\n              material.opacity = 1; // ignore transparency\n\n              break;\n          }\n\n          delete material.map.__type;\n        } // apply texture transform\n\n\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n\n      return material;\n    }\n\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break;\n\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'shininess':\n            materialData.shininess = fieldValues[0];\n            break;\n\n          case 'specularColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n\n          case 'transparency':\n            materialData.transparency = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return materialData;\n    }\n\n    function parseHexColor(hex, textureType, color) {\n      let value;\n\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          break;\n\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt('0x' + hex.substring(4, 6));\n          break;\n\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          break;\n\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4));\n          color.g = parseInt('0x' + hex.substring(4, 6));\n          color.b = parseInt('0x' + hex.substring(6, 8));\n          color.a = parseInt('0x' + hex.substring(8, 10));\n          break;\n      }\n    }\n\n    function getTextureType(num_components) {\n      let type;\n\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n      }\n\n      return type;\n    }\n\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const useAlpha = num_components === 2 || num_components === 4;\n            const textureType = getTextureType(num_components);\n            const size = (useAlpha === true ? 4 : 3) * (width * height);\n            const data = new Uint8Array(size);\n            const color = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n\n              if (useAlpha === true) {\n                const stride = k * 4;\n                data[stride + 0] = color.r;\n                data[stride + 1] = color.g;\n                data[stride + 2] = color.b;\n                data[stride + 3] = color.a;\n              } else {\n                const stride = k * 3;\n                data[stride + 0] = color.r;\n                data[stride + 1] = color.g;\n                data[stride + 2] = color.b;\n              }\n            }\n\n            texture = new DataTexture(data, width, height, useAlpha === true ? RGBAFormat : RGBFormat);\n            texture.__type = textureType; // needed for material modifications\n\n            break;\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n\n      return texture;\n    }\n\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0];\n            if (url) texture = textureLoader.load(url);\n            break;\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n\n      return texture;\n    }\n\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          case 'rotation':\n            transformData.rotation = fieldValues[0];\n            break;\n\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return transformData;\n    }\n\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0];\n            break;\n\n          case 'info':\n            worldInfo.info = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      return worldInfo;\n    }\n\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true,\n          solid = true,\n          creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true,\n          normalPerVertex = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          case 'normal':\n            const normalNode = fieldValues[0];\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n\n            break;\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'convex':\n            // field not supported\n            break;\n\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'normalIndex':\n            normalIndex = fieldValues;\n            break;\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.');\n        return new BufferGeometry(); // handle VRML files with incomplete geometry definition\n      }\n\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          // consider face normals\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          case 'colorIndex':\n            colorIndex = fieldValues;\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'coordIndex':\n            coordIndex = fieldValues;\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // build lines\n\n\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n            const expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n            const flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n            const expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n          }\n        }\n      } //\n\n\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute('position', positionAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n      geometry._type = 'line';\n      return geometry;\n    }\n\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'coord':\n            const coordNode = fieldValues[0];\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3));\n      if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n      geometry._type = 'points';\n      return geometry;\n    }\n\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n\n    function buildConeNode(node) {\n      let radius = 1,\n          height = 2,\n          openEnded = false;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0];\n            break;\n\n          case 'bottomRadius':\n            radius = fieldValues[0];\n            break;\n\n          case 'height':\n            height = fieldValues[0];\n            break;\n\n          case 'side':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n\n    function buildCylinderNode(node) {\n      let radius = 1,\n          height = 2;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break;\n\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n\n          case 'height':\n            height = fieldValues[0];\n            break;\n\n          case 'side':\n            // field not supported\n            break;\n\n          case 'top':\n            // field not supported\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0];\n\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n\n            break;\n\n          case 'normal':\n            const normalNode = fieldValues[0];\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n\n            break;\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0];\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n\n            break;\n\n          case 'height':\n            height = fieldValues;\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0];\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0];\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'xDimension':\n            xDimension = fieldValues[0];\n            break;\n\n          case 'xSpacing':\n            xSpacing = fieldValues[0];\n            break;\n\n          case 'zDimension':\n            zDimension = fieldValues[0];\n            break;\n\n          case 'zSpacing':\n            zSpacing = fieldValues[0];\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      } // vertex data\n\n\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n          const index = i * xDimension + j; // vertices\n\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z); // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          } // normals\n\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          } // uvs\n\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      } // indices\n\n\n      const indices = [];\n\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension; // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      } //\n\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute; // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2]; // one color per quad\n\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      } // normal attribute\n\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2]; // one normal per quad\n\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      } // build geometry\n\n\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute);\n      geometry.setAttribute('uv', uvAttribute);\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    }\n\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0];\n            break;\n\n          case 'ccw':\n            ccw = fieldValues[0];\n            break;\n\n          case 'convex':\n            // field not supported\n            break;\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0];\n            break;\n\n          case 'crossSection':\n            crossSection = fieldValues;\n            break;\n\n          case 'endCap':\n            endCap = fieldValues[0];\n            break;\n\n          case 'orientation':\n            orientation = fieldValues;\n            break;\n\n          case 'scale':\n            scale = fieldValues;\n            break;\n\n          case 'solid':\n            solid = fieldValues[0];\n            break;\n\n          case 'spine':\n            spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n            break;\n        }\n      }\n\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1]; // scale\n\n          vertex.multiply(scaling); // rotate\n\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion); // translate\n\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      } // indices\n\n\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      } // triangulate cap\n\n\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        } // begin cap\n\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        } // end cap\n\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n            } else {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n            }\n          }\n        }\n      }\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute('position', positionAttribute);\n      geometry.setAttribute('normal', normalAttribute); // no uvs yet\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid;\n      geometry._type = 'mesh';\n      return geometry;\n    } // helper functions\n\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D) owner.add(object);\n      }\n    }\n\n    function triangulateFaceIndex(index, ccw) {\n      const indices = []; // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n\n      return indices;\n    }\n\n    function triangulateFaceData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n\n      return triangulatedData;\n    }\n\n    function flattenData(data, index) {\n      const flattenData = [];\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        flattenData.push(x, y, z);\n      }\n\n      return flattenData;\n    }\n\n    function expandLineIndex(index) {\n      const indices = [];\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n\n      return indices;\n    }\n\n    function expandLineData(data, index) {\n      const triangulatedData = [];\n      let start = 0;\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data[stride];\n        const y = data[stride + 1];\n        const z = data[stride + 2];\n        triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n\n      return triangulatedData;\n    }\n\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize);\n          uvB.fromArray(data, b * itemSize);\n          uvC.fromArray(data, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data, a * itemSize);\n          vB.fromArray(data, b * itemSize);\n          vC.fromArray(data, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n\n      return new Float32BufferAttribute(array, itemSize);\n    }\n\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n\n      return new Float32BufferAttribute(array, 3);\n    }\n\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n\n      return new Float32BufferAttribute(array, 3);\n    }\n\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n          index2 = 0;\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n\n    const ab = new Vector3();\n    const cb = new Vector3();\n\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {}; // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n        if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n        if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      } // compute vertex normals and build final geometry\n\n\n      const normals = [];\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n\n      return new Float32BufferAttribute(normals, 3);\n    }\n\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n\n      return normal.normalize();\n    }\n\n    function toColorArray(colors) {\n      const array = [];\n\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n\n      return array;\n    }\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n\n\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      } // generate vertex colors\n\n\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n\n          if (topDown === true) {\n            // interpolation for sky color\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            // interpolation for ground color\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n\n      geometry.setAttribute('color', colorAttribute);\n    } //\n\n\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n    } // create JSON representing the tree structure of the VRML asset\n\n\n    const tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree);\n    return scene;\n  }\n\n}\n\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error('THREE.VRMLLexer: Lexing errors detected.');\n    }\n\n    return lexingResult;\n  }\n\n}\n\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary['Version'];\n    const LCurly = tokenVocabulary['LCurly'];\n    const RCurly = tokenVocabulary['RCurly'];\n    const LSquare = tokenVocabulary['LSquare'];\n    const RSquare = tokenVocabulary['RSquare'];\n    const Identifier = tokenVocabulary['Identifier'];\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    const StringLiteral = tokenVocabulary['StringLiteral'];\n    const HexLiteral = tokenVocabulary['HexLiteral'];\n    const NumberLiteral = tokenVocabulary['NumberLiteral'];\n    const TrueLiteral = tokenVocabulary['TrueLiteral'];\n    const FalseLiteral = tokenVocabulary['FalseLiteral'];\n    const NullLiteral = tokenVocabulary['NullLiteral'];\n    const DEF = tokenVocabulary['DEF'];\n    const USE = tokenVocabulary['USE'];\n    const ROUTE = tokenVocabulary['ROUTE'];\n    const TO = tokenVocabulary['TO'];\n    const NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n\n}\n\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n\n}\n\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\n\nexport { VRMLLoader };\n"]},"metadata":{},"sourceType":"module"}