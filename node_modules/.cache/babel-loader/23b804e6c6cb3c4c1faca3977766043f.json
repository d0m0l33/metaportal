{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { DataTexture, RGBFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three'; // Original src: https://github.com/zz85/threejs-path-flow\n\nconst BITS = 3;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\n\nconst initSplineTexture = function () {\n  let numberOfCurves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\n\n\nconst updateSplineTexture = function (texture, splineCurve) {\n  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n};\n\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = BITS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * BITS + i + 0] = x;\n  data[index * BITS + i + 1] = y;\n  data[index * BITS + i + 2] = z;\n};\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\n\n\nfunction getUniforms(splineTexture) {\n  const uniforms = {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n  return uniforms;\n}\n\nfunction modifyShader(material, uniforms) {\n  let numberOfCurves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader =\n    /* glsl */\n    `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t` // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\n    /* glsl */\n    `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace('#include <project_vertex>',\n    /* glsl */\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\n * A helper class for making meshes bend aroudn curves\n */\n\n\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh) {\n    let numberOfCurves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _defineProperty(this, \"curveArray\", void 0);\n\n    _defineProperty(this, \"curveLengthArray\", void 0);\n\n    _defineProperty(this, \"object3D\", void 0);\n\n    _defineProperty(this, \"splineTexure\", void 0);\n\n    _defineProperty(this, \"uniforms\", void 0);\n\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse(child => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n\n}\n\nconst matrix = new Matrix4();\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\n\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    super(mesh, curveCount);\n\n    _defineProperty(this, \"offsets\", void 0);\n\n    _defineProperty(this, \"whichCurve\", void 0);\n\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n\n\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n\n\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n\n\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n\n}\n\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/modifiers/CurveModifier.js"],"names":["_defineProperty","DataTexture","RGBFormat","FloatType","RepeatWrapping","NearestFilter","Mesh","InstancedMesh","Matrix4","DynamicDrawUsage","BITS","TEXTURE_WIDTH","TEXTURE_HEIGHT","initSplineTexture","numberOfCurves","dataArray","Float32Array","dataTexture","wrapS","wrapT","magFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","getUniforms","splineTexture","uniforms","spineTexture","value","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","replace","Flow","constructor","mesh","obj3D","clone","splineTexure","traverse","child","curveArray","Array","curveLengthArray","object3D","updateCurve","curve","length","Error","curveLength","getLength","moveAlongCurve","amount","matrix","InstancedFlow","count","curveCount","geometry","instanceMatrix","setUsage","offsets","fill","whichCurve","writeChanges","makeTranslation","setMatrixAt","moveIndividualAlongCurve","setCurve","curveNo","isNaN"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { DataTexture, RGBFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three';\n\n// Original src: https://github.com/zz85/threejs-path-flow\nconst BITS = 3;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nconst initSplineTexture = (numberOfCurves = 1) => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\n\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n};\n\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = BITS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * BITS + i + 0] = x;\n  data[index * BITS + i + 1] = y;\n  data[index * BITS + i + 2] = z;\n};\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nfunction getUniforms(splineTexture) {\n  const uniforms = {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n  return uniforms;\n}\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader =\n    /* glsl */\n    `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t` // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\n    /* glsl */\n    `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace('#include <project_vertex>',\n    /* glsl */\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\n * A helper class for making meshes bend aroudn curves\n */\n\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    _defineProperty(this, \"curveArray\", void 0);\n\n    _defineProperty(this, \"curveLengthArray\", void 0);\n\n    _defineProperty(this, \"object3D\", void 0);\n\n    _defineProperty(this, \"splineTexure\", void 0);\n\n    _defineProperty(this, \"uniforms\", void 0);\n\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse(child => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n\n}\nconst matrix = new Matrix4();\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\n\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    super(mesh, curveCount);\n\n    _defineProperty(this, \"offsets\", void 0);\n\n    _defineProperty(this, \"whichCurve\", void 0);\n\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n\n\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n\n\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n\n\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n\n}\n\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };\n"]},"metadata":{},"sourceType":"module"}