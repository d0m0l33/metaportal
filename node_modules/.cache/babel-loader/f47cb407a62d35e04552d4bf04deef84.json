{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getProdType = exports.PROD_TYPE = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar interpreter_1 = require(\"./interpreter\");\n\nvar rest_1 = require(\"./rest\");\n\nvar tokens_1 = require(\"../../scan/tokens\");\n\nvar gast_public_1 = require(\"./gast/gast_public\");\n\nvar gast_visitor_public_1 = require(\"./gast/gast_visitor_public\");\n\nvar PROD_TYPE;\n\n(function (PROD_TYPE) {\n  PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));\n\nfunction getProdType(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_public_1.Option) {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof gast_public_1.Repetition) {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof gast_public_1.RepetitionMandatory) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof gast_public_1.Alternation) {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.getProdType = getProdType;\n\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n\nexports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\n\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\n\nexports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;\n\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n  var numOfAlts = alts.length;\n  var areAllOneTokenLookahead = (0, utils_1.every)(alts, function (currAlt) {\n    return (0, utils_1.every)(currAlt, function (currPath) {\n      return currPath.length === 1;\n    });\n  }); // This version takes into account the predicates as well.\n\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (orAlts) {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      var predicates = (0, utils_1.map)(orAlts, function (currAlt) {\n        return currAlt.GATE;\n      });\n\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        var currPredicate = predicates[t];\n\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    var singleTokenAlts = (0, utils_1.map)(alts, function (currAlt) {\n      return (0, utils_1.flatten)(currAlt);\n    });\n    var choiceToAlt_1 = (0, utils_1.reduce)(singleTokenAlts, function (result, currAlt, idx) {\n      (0, utils_1.forEach)(currAlt, function (currTokType) {\n        if (!(0, utils_1.has)(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n\n        (0, utils_1.forEach)(currTokType.categoryMatches, function (currExtendingType) {\n          if (!(0, utils_1.has)(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, []);\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n\n    return function () {\n      var nextToken = this.LA(1);\n      return choiceToAlt_1[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function () {\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  }\n}\n\nexports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;\n\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n  var areAllOneTokenLookahead = (0, utils_1.every)(alt, function (currPath) {\n    return currPath.length === 1;\n  });\n  var numOfPaths = alt.length; // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    var singleTokensTypes = (0, utils_1.flatten)(alt);\n\n    if (singleTokensTypes.length === 1 && (0, utils_1.isEmpty)(singleTokensTypes[0].categoryMatches)) {\n      var expectedTokenType = singleTokensTypes[0];\n      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n      return function () {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n      };\n    } else {\n      var choiceToAlt_2 = (0, utils_1.reduce)(singleTokensTypes, function (result, currTokType, idx) {\n        result[currTokType.tokenTypeIdx] = true;\n        (0, utils_1.forEach)(currTokType.categoryMatches, function (currExtendingType) {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function () {\n        var nextToken = this.LA(1);\n        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function () {\n      nextPath: for (var j = 0; j < numOfPaths; j++) {\n        var currPath = alt[j];\n        var currPathLength = currPath.length;\n\n        for (var i = 0; i < currPathLength; i++) {\n          var nextToken = this.LA(i + 1);\n\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        } // found a full path that matches.\n\n\n        return true;\n      } // none of the paths matched\n\n\n      return false;\n    };\n  }\n}\n\nexports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;\n\nvar RestDefinitionFinderWalker =\n/** @class */\nfunction (_super) {\n  __extends(RestDefinitionFinderWalker, _super);\n\n  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n    var _this = _super.call(this) || this;\n\n    _this.topProd = topProd;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    return _this;\n  }\n\n  RestDefinitionFinderWalker.prototype.startWalking = function () {\n    this.walk(this.topProd);\n    return this.restDef;\n  };\n\n  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    } // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n\n\n    return false;\n  };\n\n  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return RestDefinitionFinderWalker;\n}(rest_1.RestWalker);\n/**\n * Returns the definition of a target production in a top level level rule.\n */\n\n\nvar InsideDefinitionFinderVisitor =\n/** @class */\nfunction (_super) {\n  __extends(InsideDefinitionFinderVisitor, _super);\n\n  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n    var _this = _super.call(this) || this;\n\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    _this.targetRef = targetRef;\n    _this.result = [];\n    return _this;\n  }\n\n  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  };\n\n  return InsideDefinitionFinderVisitor;\n}(gast_visitor_public_1.GAstVisitor);\n\nfunction initializeArrayOfArrays(size) {\n  var result = new Array(size);\n\n  for (var i = 0; i < size; i++) {\n    result[i] = [];\n  }\n\n  return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\n\n\nfunction pathToHashKeys(path) {\n  var keys = [\"\"];\n\n  for (var i = 0; i < path.length; i++) {\n    var tokType = path[i];\n    var longerKeys = [];\n\n    for (var j = 0; j < keys.length; j++) {\n      var currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n\n      for (var t = 0; t < tokType.categoryMatches.length; t++) {\n        var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n\n    keys = longerKeys;\n  }\n\n  return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\n\n\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n\n    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n\n    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      var searchKey = searchPathKeys[searchIdx];\n\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  } // None of the SearchPathKeys were found in any of the other alternatives\n\n\n  return true;\n}\n\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n  var partialAlts = (0, utils_1.map)(altsDefs, function (currAlt) {\n    return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);\n  });\n  var finalResult = initializeArrayOfArrays(partialAlts.length);\n  var altsHashes = (0, utils_1.map)(partialAlts, function (currAltPaths) {\n    var dict = {};\n    (0, utils_1.forEach)(currAltPaths, function (item) {\n      var keys = pathToHashKeys(item.partialPath);\n      (0, utils_1.forEach)(keys, function (currKey) {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  var newData = partialAlts; // maxLookahead loop\n\n  for (var pathLength = 1; pathLength <= k; pathLength++) {\n    var currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n\n    var _loop_1 = function (altIdx) {\n      var currAltPathsAndSuffixes = currDataset[altIdx]; // paths in current alternative loop\n\n      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        var prefixKeys = pathToHashKeys(currPathPrefix);\n        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx); // End of the line for this path.\n\n        if (isUnique || (0, utils_1.isEmpty)(suffixDef) || currPathPrefix.length === k) {\n          var currAltResult = finalResult[altIdx]; // TODO: Can we implement a containsPath using Maps/Dictionaries?\n\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix); // Update all new  keys for the current path.\n\n            for (var j = 0; j < prefixKeys.length; j++) {\n              var currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        } // Expand longer paths\n        else {\n          var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes); // Update keys for new known paths\n\n          (0, utils_1.forEach)(newPartialPathsAndSuffixes, function (item) {\n            var prefixKeys = pathToHashKeys(item.partialPath);\n            (0, utils_1.forEach)(prefixKeys, function (key) {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }; // alternatives loop\n\n\n    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      _loop_1(altIdx);\n    }\n  }\n\n  return finalResult;\n}\n\nexports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;\n\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\n\nexports.getLookaheadPathsForOr = getLookaheadPathsForOr;\n\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  var insideDef = insideDefVisitor.result;\n  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  var afterDef = afterDefWalker.startWalking();\n  var insideFlat = new gast_public_1.Alternative({\n    definition: insideDef\n  });\n  var afterFlat = new gast_public_1.Alternative({\n    definition: afterDef\n  });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\n\nexports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;\n\nfunction containsPath(alternative, searchPath) {\n  compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n    var otherPath = alternative[i];\n\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n\n    for (var j = 0; j < otherPath.length; j++) {\n      var searchTok = searchPath[j];\n      var otherTok = otherPath[j];\n      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nexports.containsPath = containsPath;\n\nfunction isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && (0, utils_1.every)(prefix, function (tokType, idx) {\n    var otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\n\nexports.isStrictPrefixOfPath = isStrictPrefixOfPath;\n\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n  return (0, utils_1.every)(lookAheadPaths, function (singleAltPaths) {\n    return (0, utils_1.every)(singleAltPaths, function (singlePath) {\n      return (0, utils_1.every)(singlePath, function (token) {\n        return (0, utils_1.isEmpty)(token.categoryMatches);\n      });\n    });\n  });\n}\n\nexports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;","map":{"version":3,"sources":["../../../../src/parse/grammar/lookahead.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AASA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAIA,IAAA,aAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAWA,IAAA,qBAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAQA,IAAY,SAAZ;;AAAA,CAAA,UAAY,SAAZ,EAAqB;AACnB,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,sBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,sBAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,qCAAA,CAAA,GAAA,CAAA,CAAA,GAAA,qCAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,2BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,2BAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AACD,CAPD,EAAY,SAAS,GAAT,OAAA,CAAA,SAAA,KAAA,OAAA,CAAA,SAAA,GAAS,EAAT,CAAZ;;AASA,SAAgB,WAAhB,CAA4B,IAA5B,EAA6C;AAC3C;AACA,MAAI,IAAI,YAAY,aAAA,CAAA,MAApB,EAA4B;AAC1B,WAAO,SAAS,CAAC,MAAjB;AACD,GAFD,MAEO,IAAI,IAAI,YAAY,aAAA,CAAA,UAApB,EAAgC;AACrC,WAAO,SAAS,CAAC,UAAjB;AACD,GAFM,MAEA,IAAI,IAAI,YAAY,aAAA,CAAA,mBAApB,EAAyC;AAC9C,WAAO,SAAS,CAAC,oBAAjB;AACD,GAFM,MAEA,IAAI,IAAI,YAAY,aAAA,CAAA,gCAApB,EAAsD;AAC3D,WAAO,SAAS,CAAC,mCAAjB;AACD,GAFM,MAEA,IAAI,IAAI,YAAY,aAAA,CAAA,uBAApB,EAA6C;AAClD,WAAO,SAAS,CAAC,yBAAjB;AACD,GAFM,MAEA,IAAI,IAAI,YAAY,aAAA,CAAA,WAApB,EAAiC;AACtC,WAAO,SAAS,CAAC,WAAjB;AACD,GAFM,MAEA;AACL,UAAM,KAAK,CAAC,sBAAD,CAAX;AACD;AACF;;AAjBD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAmBA,SAAgB,uBAAhB,CACE,UADF,EAEE,WAFF,EAGE,YAHF,EAIE,aAJF,EAKE,oBALF,EAME,aANF,EAMyB;AAEvB,MAAM,cAAc,GAAG,sBAAsB,CAC3C,UAD2C,EAE3C,WAF2C,EAG3C,YAH2C,CAA7C;AAMA,MAAM,YAAY,GAAG,yBAAyB,CAAC,cAAD,CAAzB,GACjB,QAAA,CAAA,kCADiB,GAEjB,QAAA,CAAA,sBAFJ;AAIA,SAAO,aAAa,CAClB,cADkB,EAElB,aAFkB,EAGlB,YAHkB,EAIlB,oBAJkB,CAApB;AAMD;;AAxBD,OAAA,CAAA,uBAAA,GAAA,uBAAA;AA0BA;;;;;;;;;;;AAWG;;AACH,SAAgB,iCAAhB,CACE,UADF,EAEE,WAFF,EAGE,CAHF,EAIE,oBAJF,EAKE,QALF,EAME,gBANF,EAM+E;AAE7E,MAAM,cAAc,GAAG,gCAAgC,CACrD,UADqD,EAErD,WAFqD,EAGrD,QAHqD,EAIrD,CAJqD,CAAvD;AAOA,MAAM,YAAY,GAAG,yBAAyB,CAAC,cAAD,CAAzB,GACjB,QAAA,CAAA,kCADiB,GAEjB,QAAA,CAAA,sBAFJ;AAIA,SAAO,gBAAgB,CAAC,cAAc,CAAC,CAAD,CAAf,EAAoB,YAApB,EAAkC,oBAAlC,CAAvB;AACD;;AApBD,OAAA,CAAA,iCAAA,GAAA,iCAAA;;AAwBA,SAAgB,8BAAhB,CACE,IADF,EAEE,aAFF,EAGE,YAHF,EAIE,oBAJF,EAI+B;AAE7B,MAAM,SAAS,GAAG,IAAI,CAAC,MAAvB;AACA,MAAM,uBAAuB,GAAG,CAAA,GAAA,OAAA,CAAA,KAAA,EAAM,IAAN,EAAY,UAAC,OAAD,EAAQ;AAClD,WAAO,CAAA,GAAA,OAAA,CAAA,KAAA,EAAM,OAAN,EAAe,UAAC,QAAD,EAAS;AAC7B,aAAO,QAAQ,CAAC,MAAT,KAAoB,CAA3B;AACD,KAFM,CAAP;AAGD,GAJ+B,CAAhC,CAH6B,CAS7B;;AACA,MAAI,aAAJ,EAAmB;AACjB;;AAEG;AACH,WAAO,UAAU,MAAV,EAA+B;AACpC;AACA;AACA;AACA,UAAM,UAAU,GAAgB,CAAA,GAAA,OAAA,CAAA,GAAA,EAAI,MAAJ,EAAY,UAAC,OAAD,EAAQ;AAAK,eAAA,OAAO,CAAP,IAAA;AAAY,OAArC,CAAhC;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAApB,EAA+B,CAAC,EAAhC,EAAoC;AAClC,YAAM,OAAO,GAAG,IAAI,CAAC,CAAD,CAApB;AACA,YAAM,cAAc,GAAG,OAAO,CAAC,MAA/B;AAEA,YAAM,aAAa,GAAG,UAAU,CAAC,CAAD,CAAhC;;AACA,YAAI,aAAa,KAAK,SAAlB,IAA+B,aAAa,CAAC,IAAd,CAAmB,IAAnB,MAA6B,KAAhE,EAAuE;AACrE;AACA;AACD;;AACD,QAAA,QAAQ,EAAE,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,CAAC,EAArC,EAAyC;AACjD,cAAM,QAAQ,GAAG,OAAO,CAAC,CAAD,CAAxB;AACA,cAAM,cAAc,GAAG,QAAQ,CAAC,MAAhC;;AACA,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,CAAC,EAArC,EAAyC;AACvC,gBAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,CAAlB;;AACA,gBAAI,YAAY,CAAC,SAAD,EAAY,QAAQ,CAAC,CAAD,CAApB,CAAZ,KAAyC,KAA7C,EAAoD;AAClD;AACA;AACA,uBAAS,QAAT;AACD;AACF,WAVgD,CAWjD;AACA;;;AACA,iBAAO,CAAP;AACD,SAvBiC,CAwBlC;AACA;;AACD,OAhCmC,CAiCpC;;;AACA,aAAO,SAAP;AACD,KAnCD;AAoCD,GAxCD,MAwCO,IAAI,uBAAuB,IAAI,CAAC,oBAAhC,EAAsD;AAC3D;AACA;AACA,QAAM,eAAe,GAAG,CAAA,GAAA,OAAA,CAAA,GAAA,EAAI,IAAJ,EAAU,UAAC,OAAD,EAAQ;AACxC,aAAO,CAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,OAAR,CAAP;AACD,KAFuB,CAAxB;AAIA,QAAM,aAAW,GAAG,CAAA,GAAA,OAAA,CAAA,MAAA,EAClB,eADkB,EAElB,UAAC,MAAD,EAAS,OAAT,EAAkB,GAAlB,EAAqB;AACnB,OAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,OAAR,EAAiB,UAAC,WAAD,EAAY;AAC3B,YAAI,CAAC,CAAA,GAAA,OAAA,CAAA,GAAA,EAAI,MAAJ,EAAY,WAAW,CAAC,YAAxB,CAAL,EAA4C;AAC1C,UAAA,MAAM,CAAC,WAAW,CAAC,YAAb,CAAN,GAAmC,GAAnC;AACD;;AACD,SAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,WAAW,CAAC,eAApB,EAAqC,UAAC,iBAAD,EAAkB;AACrD,cAAI,CAAC,CAAA,GAAA,OAAA,CAAA,GAAA,EAAI,MAAJ,EAAY,iBAAZ,CAAL,EAAqC;AACnC,YAAA,MAAM,CAAC,iBAAD,CAAN,GAA4B,GAA5B;AACD;AACF,SAJD;AAKD,OATD;AAUA,aAAO,MAAP;AACD,KAdiB,EAelB,EAfkB,CAApB;AAkBA;;AAEG;;AACH,WAAO,YAAA;AACL,UAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAR,CAAlB;AACA,aAAO,aAAW,CAAC,SAAS,CAAC,YAAX,CAAlB;AACD,KAHD;AAID,GAhCM,MAgCA;AACL;AACA;;AACA;;AAEG;AACH,WAAO,YAAA;AACL,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAApB,EAA+B,CAAC,EAAhC,EAAoC;AAClC,YAAM,OAAO,GAAG,IAAI,CAAC,CAAD,CAApB;AACA,YAAM,cAAc,GAAG,OAAO,CAAC,MAA/B;;AACA,QAAA,QAAQ,EAAE,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,CAAC,EAArC,EAAyC;AACjD,cAAM,QAAQ,GAAG,OAAO,CAAC,CAAD,CAAxB;AACA,cAAM,cAAc,GAAG,QAAQ,CAAC,MAAhC;;AACA,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,CAAC,EAArC,EAAyC;AACvC,gBAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,CAAlB;;AACA,gBAAI,YAAY,CAAC,SAAD,EAAY,QAAQ,CAAC,CAAD,CAApB,CAAZ,KAAyC,KAA7C,EAAoD;AAClD;AACA;AACA,uBAAS,QAAT;AACD;AACF,WAVgD,CAWjD;AACA;;;AACA,iBAAO,CAAP;AACD,SAjBiC,CAkBlC;AACA;;AACD,OArBI,CAsBL;;;AACA,aAAO,SAAP;AACD,KAxBD;AAyBD;AACF;;AAtHD,OAAA,CAAA,8BAAA,GAAA,8BAAA;;AAwHA,SAAgB,uCAAhB,CACE,GADF,EAEE,YAFF,EAGE,oBAHF,EAG+B;AAE7B,MAAM,uBAAuB,GAAG,CAAA,GAAA,OAAA,CAAA,KAAA,EAAM,GAAN,EAAW,UAAC,QAAD,EAAS;AAClD,WAAO,QAAQ,CAAC,MAAT,KAAoB,CAA3B;AACD,GAF+B,CAAhC;AAIA,MAAM,UAAU,GAAG,GAAG,CAAC,MAAvB,CAN6B,CAQ7B;AACA;;AACA,MAAI,uBAAuB,IAAI,CAAC,oBAAhC,EAAsD;AACpD,QAAM,iBAAiB,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,GAAR,CAA1B;;AAEA,QACE,iBAAiB,CAAC,MAAlB,KAA6B,CAA7B,IACA,CAAA,GAAA,OAAA,CAAA,OAAA,EAAc,iBAAiB,CAAC,CAAD,CAAjB,CAAsB,eAApC,CAFF,EAGE;AACA,UAAM,iBAAiB,GAAG,iBAAiB,CAAC,CAAD,CAA3C;AACA,UAAM,wBAAsB,GAAS,iBAAkB,CAAC,YAAxD;AAEA,aAAO,YAAA;AACL,eAAO,KAAK,EAAL,CAAQ,CAAR,EAAW,YAAX,KAA4B,wBAAnC;AACD,OAFD;AAGD,KAVD,MAUO;AACL,UAAM,aAAW,GAAG,CAAA,GAAA,OAAA,CAAA,MAAA,EAClB,iBADkB,EAElB,UAAC,MAAD,EAAS,WAAT,EAAsB,GAAtB,EAAyB;AACvB,QAAA,MAAM,CAAC,WAAW,CAAC,YAAb,CAAN,GAAmC,IAAnC;AACA,SAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,WAAW,CAAC,eAApB,EAAqC,UAAC,iBAAD,EAAkB;AACrD,UAAA,MAAM,CAAC,iBAAD,CAAN,GAA4B,IAA5B;AACD,SAFD;AAGA,eAAO,MAAP;AACD,OARiB,EASlB,EATkB,CAApB;AAYA,aAAO,YAAA;AACL,YAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAR,CAAlB;AACA,eAAO,aAAW,CAAC,SAAS,CAAC,YAAX,CAAX,KAAwC,IAA/C;AACD,OAHD;AAID;AACF,GA/BD,MA+BO;AACL,WAAO,YAAA;AACL,MAAA,QAAQ,EAAE,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AAC7C,YAAM,QAAQ,GAAG,GAAG,CAAC,CAAD,CAApB;AACA,YAAM,cAAc,GAAG,QAAQ,CAAC,MAAhC;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,CAAC,EAArC,EAAyC;AACvC,cAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,CAAlB;;AACA,cAAI,YAAY,CAAC,SAAD,EAAY,QAAQ,CAAC,CAAD,CAApB,CAAZ,KAAyC,KAA7C,EAAoD;AAClD;AACA;AACA,qBAAS,QAAT;AACD;AACF,SAV4C,CAW7C;;;AACA,eAAO,IAAP;AACD,OAdI,CAgBL;;;AACA,aAAO,KAAP;AACD,KAlBD;AAmBD;AACF;;AAjED,OAAA,CAAA,uCAAA,GAAA,uCAAA;;AAmEA,IAAA,0BAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAyC,EAAA,SAAA,CAAA,0BAAA,EAAA,MAAA,CAAA;;AAGvC,WAAA,0BAAA,CACU,OADV,EAEU,gBAFV,EAGU,cAHV,EAGmC;AAHnC,QAAA,KAAA,GAKE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IALT;;AACU,IAAA,KAAA,CAAA,OAAA,GAAA,OAAA;AACA,IAAA,KAAA,CAAA,gBAAA,GAAA,gBAAA;AACA,IAAA,KAAA,CAAA,cAAA,GAAA,cAAA;;AAGT;;AAED,EAAA,0BAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,SAAK,IAAL,CAAU,KAAK,OAAf;AACA,WAAO,KAAK,OAAZ;AACD,GAHD;;AAKQ,EAAA,0BAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UACE,IADF,EAEE,gBAFF,EAGE,QAHF,EAIE,QAJF,EAIyB;AAEvB,QACE,IAAI,CAAC,GAAL,KAAa,KAAK,gBAAlB,IACA,KAAK,cAAL,KAAwB,gBAF1B,EAGE;AACA,WAAK,OAAL,GAAe,QAAQ,CAAC,MAAT,CAAgB,QAAhB,CAAf;AACA,aAAO,IAAP;AACD,KARsB,CASvB;;;AACA,WAAO,KAAP;AACD,GAfO;;AAiBR,EAAA,0BAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UACE,UADF,EAEE,QAFF,EAGE,QAHF,EAGyB;AAEvB,QAAI,CAAC,KAAK,aAAL,CAAmB,UAAnB,EAA+B,SAAS,CAAC,MAAzC,EAAiD,QAAjD,EAA2D,QAA3D,CAAL,EAA2E;AACzE,MAAA,MAAA,CAAA,SAAA,CAAM,UAAN,CAAgB,IAAhB,CAAgB,IAAhB,EAAiB,UAAjB,EAA6B,QAA7B,EAAuC,QAAvC;AACD;AACF,GARD;;AAUA,EAAA,0BAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UACE,cADF,EAEE,QAFF,EAGE,QAHF,EAGyB;AAEvB,QACE,CAAC,KAAK,aAAL,CACC,cADD,EAEC,SAAS,CAAC,oBAFX,EAGC,QAHD,EAIC,QAJD,CADH,EAOE;AACA,MAAA,MAAA,CAAA,SAAA,CAAM,UAAN,CAAgB,IAAhB,CAAgB,IAAhB,EAAiB,cAAjB,EAAiC,QAAjC,EAA2C,QAA3C;AACD;AACF,GAfD;;AAiBA,EAAA,0BAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UACE,iBADF,EAEE,QAFF,EAGE,QAHF,EAGyB;AAEvB,QACE,CAAC,KAAK,aAAL,CACC,iBADD,EAEC,SAAS,CAAC,mCAFX,EAGC,QAHD,EAIC,QAJD,CADH,EAOE;AACA,MAAA,MAAA,CAAA,SAAA,CAAM,UAAN,CAAgB,IAAhB,CAAgB,IAAhB,EAAiB,iBAAjB,EAAoC,QAApC,EAA8C,QAA9C;AACD;AACF,GAfD;;AAiBA,EAAA,0BAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UACE,QADF,EAEE,QAFF,EAGE,QAHF,EAGyB;AAEvB,QACE,CAAC,KAAK,aAAL,CAAmB,QAAnB,EAA6B,SAAS,CAAC,UAAvC,EAAmD,QAAnD,EAA6D,QAA7D,CADH,EAEE;AACA,MAAA,MAAA,CAAA,SAAA,CAAM,UAAN,CAAgB,IAAhB,CAAgB,IAAhB,EAAiB,QAAjB,EAA2B,QAA3B,EAAqC,QAArC;AACD;AACF,GAVD;;AAYA,EAAA,0BAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UACE,WADF,EAEE,QAFF,EAGE,QAHF,EAGyB;AAEvB,QACE,CAAC,KAAK,aAAL,CACC,WADD,EAEC,SAAS,CAAC,yBAFX,EAGC,QAHD,EAIC,QAJD,CADH,EAOE;AACA,MAAA,MAAA,CAAA,SAAA,CAAM,UAAN,CAAgB,IAAhB,CAAgB,IAAhB,EAAiB,WAAjB,EAA8B,QAA9B,EAAwC,QAAxC;AACD;AACF,GAfD;;AAgBF,SAAA,0BAAA;AAAC,CAzGD,CAAyC,MAAA,CAAA,UAAzC,CAAA;AA2GA;;AAEG;;;AACH,IAAA,6BAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA4C,EAAA,SAAA,CAAA,6BAAA,EAAA,MAAA,CAAA;;AAG1C,WAAA,6BAAA,CACU,gBADV,EAEU,cAFV,EAGU,SAHV,EAGyB;AAHzB,QAAA,KAAA,GAKE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IALT;;AACU,IAAA,KAAA,CAAA,gBAAA,GAAA,gBAAA;AACA,IAAA,KAAA,CAAA,cAAA,GAAA,cAAA;AACA,IAAA,KAAA,CAAA,SAAA,GAAA,SAAA;AALH,IAAA,KAAA,CAAA,MAAA,GAAwB,EAAxB;;AAQN;;AAEO,EAAA,6BAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UACE,IADF,EAEE,gBAFF,EAE6B;AAE3B,QACE,IAAI,CAAC,GAAL,KAAa,KAAK,gBAAlB,IACA,KAAK,cAAL,KAAwB,gBADxB,KAEC,KAAK,SAAL,KAAmB,SAAnB,IAAgC,IAAI,KAAK,KAAK,SAF/C,CADF,EAIE;AACA,WAAK,MAAL,GAAc,IAAI,CAAC,UAAnB;AACD;AACF,GAXO;;AAaD,EAAA,6BAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,IAAnB,EAA+B;AAC7B,SAAK,aAAL,CAAmB,IAAnB,EAAyB,SAAS,CAAC,MAAnC;AACD,GAFM;;AAIA,EAAA,6BAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,IAAvB,EAAuC;AACrC,SAAK,aAAL,CAAmB,IAAnB,EAAyB,SAAS,CAAC,UAAnC;AACD,GAFM;;AAIA,EAAA,6BAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,UAAgC,IAAhC,EAAyD;AACvD,SAAK,aAAL,CAAmB,IAAnB,EAAyB,SAAS,CAAC,oBAAnC;AACD,GAFM;;AAIA,EAAA,6BAAA,CAAA,SAAA,CAAA,qCAAA,GAAP,UACE,IADF,EACwC;AAEtC,SAAK,aAAL,CAAmB,IAAnB,EAAyB,SAAS,CAAC,mCAAnC;AACD,GAJM;;AAMA,EAAA,6BAAA,CAAA,SAAA,CAAA,4BAAA,GAAP,UAAoC,IAApC,EAAiE;AAC/D,SAAK,aAAL,CAAmB,IAAnB,EAAyB,SAAS,CAAC,yBAAnC;AACD,GAFM;;AAIA,EAAA,6BAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,IAAxB,EAAyC;AACvC,SAAK,aAAL,CAAmB,IAAnB,EAAyB,SAAS,CAAC,WAAnC;AACD,GAFM;;AAGT,SAAA,6BAAA;AAAC,CAjDD,CAA4C,qBAAA,CAAA,WAA5C,CAAA;;AAmDA,SAAS,uBAAT,CAAiC,IAAjC,EAAqC;AACnC,MAAM,MAAM,GAAG,IAAI,KAAJ,CAAU,IAAV,CAAf;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAApB,EAA0B,CAAC,EAA3B,EAA+B;AAC7B,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,EAAZ;AACD;;AACD,SAAO,MAAP;AACD;AAED;;;;AAIG;;;AACH,SAAS,cAAT,CAAwB,IAAxB,EAAyC;AACvC,MAAI,IAAI,GAAG,CAAC,EAAD,CAAX;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AACpC,QAAM,OAAO,GAAG,IAAI,CAAC,CAAD,CAApB;AACA,QAAM,UAAU,GAAG,EAAnB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AACpC,UAAM,cAAc,GAAG,IAAI,CAAC,CAAD,CAA3B;AACA,MAAA,UAAU,CAAC,IAAX,CAAgB,cAAc,GAAG,GAAjB,GAAuB,OAAO,CAAC,YAA/C;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,eAAR,CAAwB,MAA5C,EAAoD,CAAC,EAArD,EAAyD;AACvD,YAAM,mBAAmB,GAAG,MAAM,OAAO,CAAC,eAAR,CAAwB,CAAxB,CAAlC;AACA,QAAA,UAAU,CAAC,IAAX,CAAgB,cAAc,GAAG,mBAAjC;AACD;AACF;;AACD,IAAA,IAAI,GAAG,UAAP;AACD;;AACD,SAAO,IAAP;AACD;AAED;;AAEG;;;AACH,SAAS,kBAAT,CACE,iBADF,EAEE,cAFF,EAGE,GAHF,EAGa;AAEX,OACE,IAAI,UAAU,GAAG,CADnB,EAEE,UAAU,GAAG,iBAAiB,CAAC,MAFjC,EAGE,UAAU,EAHZ,EAIE;AACA;AACA,QAAI,UAAU,KAAK,GAAnB,EAAwB;AACtB;AACD;;AACD,QAAM,sBAAsB,GAAG,iBAAiB,CAAC,UAAD,CAAhD;;AACA,SAAK,IAAI,SAAS,GAAG,CAArB,EAAwB,SAAS,GAAG,cAAc,CAAC,MAAnD,EAA2D,SAAS,EAApE,EAAwE;AACtE,UAAM,SAAS,GAAG,cAAc,CAAC,SAAD,CAAhC;;AACA,UAAI,sBAAsB,CAAC,SAAD,CAAtB,KAAsC,IAA1C,EAAgD;AAC9C,eAAO,KAAP;AACD;AACF;AACF,GAlBU,CAmBX;;;AACA,SAAO,IAAP;AACD;;AAED,SAAgB,iCAAhB,CACE,QADF,EAEE,CAFF,EAEW;AAET,MAAM,WAAW,GAAG,CAAA,GAAA,OAAA,CAAA,GAAA,EAAI,QAAJ,EAAc,UAAC,OAAD,EAAQ;AACxC,WAAA,CAAA,GAAA,aAAA,CAAA,iBAAA,EAAkB,CAAC,OAAD,CAAlB,EAA6B,CAA7B,CAAA;AAA+B,GADb,CAApB;AAGA,MAAM,WAAW,GAAG,uBAAuB,CAAC,WAAW,CAAC,MAAb,CAA3C;AACA,MAAM,UAAU,GAAG,CAAA,GAAA,OAAA,CAAA,GAAA,EAAI,WAAJ,EAAiB,UAAC,YAAD,EAAa;AAC/C,QAAM,IAAI,GAAG,EAAb;AACA,KAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,YAAR,EAAsB,UAAC,IAAD,EAAK;AACzB,UAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,WAAN,CAA3B;AACA,OAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,IAAR,EAAc,UAAC,OAAD,EAAQ;AACpB,QAAA,IAAI,CAAC,OAAD,CAAJ,GAAgB,IAAhB;AACD,OAFD;AAGD,KALD;AAMA,WAAO,IAAP;AACD,GATkB,CAAnB;AAUA,MAAI,OAAO,GAAG,WAAd,CAhBS,CAkBT;;AACA,OAAK,IAAI,UAAU,GAAG,CAAtB,EAAyB,UAAU,IAAI,CAAvC,EAA0C,UAAU,EAApD,EAAwD;AACtD,QAAM,WAAW,GAAG,OAApB;AACA,IAAA,OAAO,GAAG,uBAAuB,CAAC,WAAW,CAAC,MAAb,CAAjC;;4BAGS,M,EAAM;AACb,UAAM,uBAAuB,GAAG,WAAW,CAAC,MAAD,CAA3C,CADa,CAEb;;AACA,WACE,IAAI,WAAW,GAAG,CADpB,EAEE,WAAW,GAAG,uBAAuB,CAAC,MAFxC,EAGE,WAAW,EAHb,EAIE;AACA,YAAM,cAAc,GAAG,uBAAuB,CAAC,WAAD,CAAvB,CAAqC,WAA5D;AACA,YAAM,SAAS,GAAG,uBAAuB,CAAC,WAAD,CAAvB,CAAqC,SAAvD;AACA,YAAM,UAAU,GAAG,cAAc,CAAC,cAAD,CAAjC;AACA,YAAM,QAAQ,GAAG,kBAAkB,CAAC,UAAD,EAAa,UAAb,EAAyB,MAAzB,CAAnC,CAJA,CAKA;;AACA,YAAI,QAAQ,IAAI,CAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,SAAR,CAAZ,IAAkC,cAAc,CAAC,MAAf,KAA0B,CAAhE,EAAmE;AACjE,cAAM,aAAa,GAAG,WAAW,CAAC,MAAD,CAAjC,CADiE,CAEjE;;AACA,cAAI,YAAY,CAAC,aAAD,EAAgB,cAAhB,CAAZ,KAAgD,KAApD,EAA2D;AACzD,YAAA,aAAa,CAAC,IAAd,CAAmB,cAAnB,EADyD,CAEzD;;AACA,iBAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,MAA/B,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,kBAAM,OAAO,GAAG,UAAU,CAAC,CAAD,CAA1B;AACA,cAAA,UAAU,CAAC,MAAD,CAAV,CAAmB,OAAnB,IAA8B,IAA9B;AACD;AACF;AACF,SAXD,CAYA;AAZA,aAaK;AACH,cAAM,0BAA0B,GAAG,CAAA,GAAA,aAAA,CAAA,iBAAA,EACjC,SADiC,EAEjC,UAAU,GAAG,CAFoB,EAGjC,cAHiC,CAAnC;AAKA,UAAA,OAAO,CAAC,MAAD,CAAP,GAAkB,OAAO,CAAC,MAAD,CAAP,CAAgB,MAAhB,CAAuB,0BAAvB,CAAlB,CANG,CAQH;;AACA,WAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,0BAAR,EAAoC,UAAC,IAAD,EAAK;AACvC,gBAAM,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC,WAAN,CAAjC;AACA,aAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,UAAR,EAAoB,UAAC,GAAD,EAAI;AACtB,cAAA,UAAU,CAAC,MAAD,CAAV,CAAmB,GAAnB,IAA0B,IAA1B;AACD,aAFD;AAGD,WALD;AAMD;AACF;MA/CmD,CAItD;;;AACA,SAAK,IAAI,MAAM,GAAG,CAAlB,EAAqB,MAAM,GAAG,WAAW,CAAC,MAA1C,EAAkD,MAAM,EAAxD,EAA0D;cAAjD,M;AA2CR;AACF;;AAED,SAAO,WAAP;AACD;;AAzED,OAAA,CAAA,iCAAA,GAAA,iCAAA;;AA2EA,SAAgB,sBAAhB,CACE,UADF,EAEE,WAFF,EAGE,CAHF,EAIE,MAJF,EAIsB;AAEpB,MAAM,OAAO,GAAG,IAAI,6BAAJ,CACd,UADc,EAEd,SAAS,CAAC,WAFI,EAGd,MAHc,CAAhB;AAKA,EAAA,WAAW,CAAC,MAAZ,CAAmB,OAAnB;AACA,SAAO,iCAAiC,CAAC,OAAO,CAAC,MAAT,EAAiB,CAAjB,CAAxC;AACD;;AAbD,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AAeA,SAAgB,gCAAhB,CACE,UADF,EAEE,WAFF,EAGE,QAHF,EAIE,CAJF,EAIW;AAET,MAAM,gBAAgB,GAAG,IAAI,6BAAJ,CACvB,UADuB,EAEvB,QAFuB,CAAzB;AAIA,EAAA,WAAW,CAAC,MAAZ,CAAmB,gBAAnB;AACA,MAAM,SAAS,GAAG,gBAAgB,CAAC,MAAnC;AAEA,MAAM,cAAc,GAAG,IAAI,0BAAJ,CACrB,WADqB,EAErB,UAFqB,EAGrB,QAHqB,CAAvB;AAKA,MAAM,QAAQ,GAAG,cAAc,CAAC,YAAf,EAAjB;AAEA,MAAM,UAAU,GAAG,IAAI,aAAA,CAAA,WAAJ,CAAoB;AAAE,IAAA,UAAU,EAAE;AAAd,GAApB,CAAnB;AACA,MAAM,SAAS,GAAG,IAAI,aAAA,CAAA,WAAJ,CAAoB;AAAE,IAAA,UAAU,EAAE;AAAd,GAApB,CAAlB;AAEA,SAAO,iCAAiC,CAAC,CAAC,UAAD,EAAa,SAAb,CAAD,EAA0B,CAA1B,CAAxC;AACD;;AAxBD,OAAA,CAAA,gCAAA,GAAA,gCAAA;;AA0BA,SAAgB,YAAhB,CACE,WADF,EAEE,UAFF,EAEyB;AAEvB,EAAA,gBAAgB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC7D,QAAM,SAAS,GAAG,WAAW,CAAC,CAAD,CAA7B;;AACA,QAAI,SAAS,CAAC,MAAV,KAAqB,UAAU,CAAC,MAApC,EAA4C;AAC1C;AACD;;AACD,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,UAAM,SAAS,GAAG,UAAU,CAAC,CAAD,CAA5B;AACA,UAAM,QAAQ,GAAG,SAAS,CAAC,CAAD,CAA1B;AAEA,UAAM,cAAc,GAClB,SAAS,KAAK,QAAd,IACA,QAAQ,CAAC,kBAAT,CAA4B,SAAS,CAAC,YAAtC,MAAwD,SAF1D;;AAGA,UAAI,cAAc,KAAK,KAAvB,EAA8B;AAC5B,iBAAS,gBAAT;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;;AAxBD,OAAA,CAAA,YAAA,GAAA,YAAA;;AA0BA,SAAgB,oBAAhB,CACE,MADF,EAEE,KAFF,EAEoB;AAElB,SACE,MAAM,CAAC,MAAP,GAAgB,KAAK,CAAC,MAAtB,IACA,CAAA,GAAA,OAAA,CAAA,KAAA,EAAM,MAAN,EAAc,UAAC,OAAD,EAAU,GAAV,EAAa;AACzB,QAAM,YAAY,GAAG,KAAK,CAAC,GAAD,CAA1B;AACA,WACE,OAAO,KAAK,YAAZ,IACA,YAAY,CAAC,kBAAb,CAAgC,OAAO,CAAC,YAAxC,CAFF;AAID,GAND,CAFF;AAUD;;AAdD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAgBA,SAAgB,yBAAhB,CACE,cADF,EACqC;AAEnC,SAAO,CAAA,GAAA,OAAA,CAAA,KAAA,EAAM,cAAN,EAAsB,UAAC,cAAD,EAAe;AAC1C,WAAA,CAAA,GAAA,OAAA,CAAA,KAAA,EAAM,cAAN,EAAsB,UAAC,UAAD,EAAW;AAC/B,aAAA,CAAA,GAAA,OAAA,CAAA,KAAA,EAAM,UAAN,EAAkB,UAAC,KAAD,EAAM;AAAK,eAAA,CAAA,GAAA,OAAA,CAAA,OAAA,EAAQ,KAAK,CAAb,eAAA,CAAA;AAA8B,OAA3D,CAAA;AAA4D,KAD9D,CAAA;AAEC,GAHI,CAAP;AAKD;;AARD,OAAA,CAAA,yBAAA,GAAA,yBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getProdType = exports.PROD_TYPE = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar interpreter_1 = require(\"./interpreter\");\nvar rest_1 = require(\"./rest\");\nvar tokens_1 = require(\"../../scan/tokens\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar gast_visitor_public_1 = require(\"./gast/gast_visitor_public\");\nvar PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));\nfunction getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof gast_public_1.Option) {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof gast_public_1.Repetition) {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof gast_public_1.RepetitionMandatory) {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof gast_public_1.Alternation) {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.getProdType = getProdType;\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokens_1.tokenStructuredMatcherNoCategories\n        : tokens_1.tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokens_1.tokenStructuredMatcherNoCategories\n        : tokens_1.tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = (0, utils_1.every)(alts, function (currAlt) {\n        return (0, utils_1.every)(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = (0, utils_1.map)(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = (0, utils_1.map)(alts, function (currAlt) {\n            return (0, utils_1.flatten)(currAlt);\n        });\n        var choiceToAlt_1 = (0, utils_1.reduce)(singleTokenAlts, function (result, currAlt, idx) {\n            (0, utils_1.forEach)(currAlt, function (currTokType) {\n                if (!(0, utils_1.has)(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                (0, utils_1.forEach)(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!(0, utils_1.has)(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, []);\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = (0, utils_1.every)(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = (0, utils_1.flatten)(alt);\n        if (singleTokensTypes.length === 1 &&\n            (0, utils_1.isEmpty)(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = (0, utils_1.reduce)(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                (0, utils_1.forEach)(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nexports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(rest_1.RestWalker));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(gast_visitor_public_1.GAstVisitor));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = (0, utils_1.map)(altsDefs, function (currAlt) {\n        return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);\n    });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = (0, utils_1.map)(partialAlts, function (currAltPaths) {\n        var dict = {};\n        (0, utils_1.forEach)(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            (0, utils_1.forEach)(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || (0, utils_1.isEmpty)(suffixDef) || currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    (0, utils_1.forEach)(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        (0, utils_1.forEach)(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nexports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexports.getLookaheadPathsForOr = getLookaheadPathsForOr;\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new gast_public_1.Alternative({ definition: insideDef });\n    var afterFlat = new gast_public_1.Alternative({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;\nfunction containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexports.containsPath = containsPath;\nfunction isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        (0, utils_1.every)(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexports.isStrictPrefixOfPath = isStrictPrefixOfPath;\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n    return (0, utils_1.every)(lookAheadPaths, function (singleAltPaths) {\n        return (0, utils_1.every)(singleAltPaths, function (singlePath) {\n            return (0, utils_1.every)(singlePath, function (token) { return (0, utils_1.isEmpty)(token.categoryMatches); });\n        });\n    });\n}\nexports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;\n//# sourceMappingURL=lookahead.js.map"]},"metadata":{},"sourceType":"script"}