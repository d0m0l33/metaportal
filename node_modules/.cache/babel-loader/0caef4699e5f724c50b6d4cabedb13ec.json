{"ast":null,"code":"import{TransactionLevel,CriteriaComparions}from\"./BadgeHelperTypes\";export var parseResponseForItems=function parseResponseForItems(response){if(!response||!response.data||!response.data.data){return null;}return response.data.data.items;};export var RANDOM_VISOR_COLOR_NAMES=['black','white','grey','green','blue','purple','pink','silver','bronze','gold'];export var RANDOM_VISOR_COLORS=['black','white','grey','#3f9468',//light green\n'#5093aa',//light blue\n'#9550aa',//light purple\n'#e74f71',//light pink\n'silver','#271f1f',//brown\n'gold'];export var calculateFrequencyForKeyValueMatches=function calculateFrequencyForKeyValueMatches(transactions,key,value,valueMatching){if(valueMatching){// matches if 'key' found && key maps to 'value'\nreturn getKeyValueMatchCount(transactions,key,value);}else{// matches if 'key' found\nreturn getKeyMatchCount(transactions,key);}};export var getKeyValueMatchCount=function getKeyValueMatchCount(items,key,value){var count=0;items.forEach(function(item){if(item[key]&&item[key]===value){count++;}});return count;};export var getKeyMatchCount=function getKeyMatchCount(items,key){var count=0;items.forEach(function(item){if(item[key]){count++;}});return count;};export var getValidBadges=function getValidBadges(badges,transactions){var validBadges=[];badges.forEach(function(badge){if(validateBadgeAgainstTransactions(badge,transactions)){validBadges.push(badge);}});return validBadges;};export var validateBadgeAgainstTransactions=function validateBadgeAgainstTransactions(badge,transactions){var isValid=false;switch(badge.parseRules.level){case TransactionLevel.Root:// compare rules with trnsaction list\nisValid=executeRootLevelChecksForBadge(badge.parseRules,transactions);return isValid;default:return false;}};export var executeRootLevelChecksForBadge=function executeRootLevelChecksForBadge(rules,transactions){// defaulting to Key Match frequency comparisons\nreturn executeFrequencyRuleForBadge(rules.keyValueObject.name,rules.keyValueObject.value,rules.criteria.comparison,rules.criteria.value,rules.useKeyValueMatching,transactions);};export var executeFrequencyRuleForBadge=function executeFrequencyRuleForBadge(key,value,criteriaRule,criteriaValue,isValueMathing,transactions){// defaulting to Key Match frequency comparisons\nvar isValid=false;var frequency=calculateFrequencyForKeyValueMatches(transactions,key,value,isValueMathing);switch(criteriaRule){case CriteriaComparions.GT:return frequency>criteriaValue;case CriteriaComparions.LT:return frequency<criteriaValue;default:return false;}};","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/src/portalHooks/BadgeHelper.ts"],"names":["TransactionLevel","CriteriaComparions","parseResponseForItems","response","data","items","RANDOM_VISOR_COLOR_NAMES","RANDOM_VISOR_COLORS","calculateFrequencyForKeyValueMatches","transactions","key","value","valueMatching","getKeyValueMatchCount","getKeyMatchCount","count","forEach","item","getValidBadges","badges","validBadges","badge","validateBadgeAgainstTransactions","push","isValid","parseRules","level","Root","executeRootLevelChecksForBadge","rules","executeFrequencyRuleForBadge","keyValueObject","name","criteria","comparison","useKeyValueMatching","criteriaRule","criteriaValue","isValueMathing","frequency","GT","LT"],"mappings":"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","sourcesContent":["import { AxiosResponse } from \"axios\";\nimport { TransactionLevel, ParseParams, CriteriaComparions, MetaBadge } from \"./BadgeHelperTypes\";\n\n\nexport const parseResponseForItems =(response: AxiosResponse): (any[]|null) => {\n    if(!response || !response.data || !response.data.data) {\n      return null;\n    }\n    return response.data.data.items;\n}\n  \n  export const RANDOM_VISOR_COLOR_NAMES = [\n    'black',\n    'white',\n    'grey',\n    'green',\n    'blue',\n    'purple',\n    'pink',\n    'silver',\n    'bronze',\n    'gold'\n  ]\n\n  export const RANDOM_VISOR_COLORS = [\n    'black',\n    'white',\n    'grey',\n    '#3f9468',//light green\n    '#5093aa',//light blue\n    '#9550aa',//light purple\n    '#e74f71',//light pink\n    'silver',\n    '#271f1f',//brown\n    'gold'\n  ]\n  \n  export const calculateFrequencyForKeyValueMatches =(\n    transactions: any[], \n    key: string, \n    value: number, \n    valueMatching: boolean\n    ) : number => {\n      if(valueMatching) {\n        // matches if 'key' found && key maps to 'value'\n        return getKeyValueMatchCount(transactions, key, value);\n      } else {\n          // matches if 'key' found\n          return getKeyMatchCount(transactions, key);\n      }\n  }\n\n  export const getKeyValueMatchCount = (items: any[], key: string, value: any) =>  {\n      let count = 0;\n      items.forEach((item) => {\n        if(item[key] && item[key] === value) {\n          count++;\n        }\n      });\n      return count;\n  }\n\n  export const getKeyMatchCount = (items: any[], key: string) =>  {\n    let count = 0;\n    items.forEach((item) => {\n      if(item[key]) {\n        count++;\n      }\n    });\n    return count;\n}\n\n\nexport const getValidBadges = (badges: MetaBadge[], transactions: any[]) : MetaBadge[] =>  {\n  let validBadges: MetaBadge[] = [];\n  badges.forEach((badge: MetaBadge) => {\n    if(validateBadgeAgainstTransactions(badge,transactions)){\n      validBadges.push(badge);\n    }\n  });\n  return validBadges;\n}\n\n\nexport const validateBadgeAgainstTransactions = (badge: MetaBadge, transactions: any[]): boolean =>  {\n  let isValid = false;\n  switch(badge.parseRules.level) {\n    case TransactionLevel.Root :\n        // compare rules with trnsaction list\n        isValid = executeRootLevelChecksForBadge(badge.parseRules,transactions);\n      return isValid;\n    default:\n      return false;\n  }\n}\n\n\nexport const executeRootLevelChecksForBadge = (rules: ParseParams, transactions: any[]): boolean =>  {\n  // defaulting to Key Match frequency comparisons\n  return executeFrequencyRuleForBadge(\n    rules.keyValueObject.name, \n    rules.keyValueObject.value,\n    rules.criteria.comparison,\n    rules.criteria.value,\n    rules.useKeyValueMatching,\n    transactions\n    );\n}\n\n\nexport const executeFrequencyRuleForBadge = (\n  key: string, \n  value: any, \n  criteriaRule: CriteriaComparions,\n  criteriaValue: number,\n  isValueMathing: boolean,\n  transactions: any[], ): boolean =>  {\n  // defaulting to Key Match frequency comparisons\n  let isValid = false;\n  const frequency = calculateFrequencyForKeyValueMatches(transactions, key, value, isValueMathing);\n\n  switch(criteriaRule) {\n    case CriteriaComparions.GT : \n      return frequency > criteriaValue;\n\n    case CriteriaComparions.LT : \n      return frequency < criteriaValue;\n\n    default:\n      return false;\n  }\n}"]},"metadata":{},"sourceType":"module"}