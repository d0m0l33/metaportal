{"ast":null,"code":"import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals() {\n    let areaWeighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix) {\n    let materialIndexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices() {\n    let precisionPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    /*\n    // Handle primitives\n    const parameters = this.parameters;\n    if ( parameters !== undefined ) {\n    const values = [];\n    for ( const key in parameters ) {\n    values.push( parameters[ key ] );\n    }\n    const geometry = Object.create( this.constructor.prototype );\n    this.constructor.apply( geometry, values );\n    return geometry;\n    }\n    return new this.constructor().copy( this );\n    */\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nGeometry.createBufferGeometryFromObject = object => {\n  let buffergeometry = new BufferGeometry();\n  const geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color) {\n    let materialIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/deprecated/Geometry.js"],"names":["Matrix4","Object3D","Vector3","EventDispatcher","MathUtils","Matrix3","Color","Box3","Sphere","BufferGeometry","BufferAttribute","Float32BufferAttribute","Vector2","_m1","_obj","_offset","Geometry","constructor","isGeometry","uuid","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","applyMatrix4","matrix","normalMatrix","getNormalMatrix","i","il","length","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","geometry","scope","index","undefined","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","toBufferGeometry","DirectGeometry","fromGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","warn","dispose","dispatchEvent","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","computeGroups","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","isVector3","isArray","isColor"],"mappings":"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","sourcesContent":["import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    /*\n    // Handle primitives\n    const parameters = this.parameters;\n    if ( parameters !== undefined ) {\n    const values = [];\n    for ( const key in parameters ) {\n    values.push( parameters[ key ] );\n    }\n    const geometry = Object.create( this.constructor.prototype );\n    this.constructor.apply( geometry, values );\n    return geometry;\n    }\n    return new this.constructor().copy( this );\n    */\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nGeometry.createBufferGeometryFromObject = object => {\n  let buffergeometry = new BufferGeometry();\n  const geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };\n"]},"metadata":{},"sourceType":"module"}