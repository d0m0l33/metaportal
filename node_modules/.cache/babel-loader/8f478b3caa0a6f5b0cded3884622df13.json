{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\n\nvar tokens_public_1 = require(\"../scan/tokens_public\");\n\nvar utils = require(\"@chevrotain/utils\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar gast_public_1 = require(\"./grammar/gast/gast_public\");\n\nvar gast_1 = require(\"./grammar/gast/gast\");\n\nexports.defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function buildMismatchTokenMessage(_a) {\n    var expected = _a.expected,\n        actual = _a.actual,\n        previous = _a.previous,\n        ruleName = _a.ruleName;\n    var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n    var expectedMsg = hasLabel ? \"--> \" + (0, tokens_public_1.tokenLabel)(expected) + \" <--\" : \"token of type --> \" + expected.name + \" <--\";\n    var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function buildNotAllInputParsedMessage(_a) {\n    var firstRedundant = _a.firstRedundant,\n        ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function buildNoViableAltMessage(_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n        actual = _a.actual,\n        previous = _a.previous,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = (0, utils_1.first)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = (0, utils_1.reduce)(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = (0, utils_1.map)(allLookAheadPaths, function (currPath) {\n        return \"[\" + (0, utils_1.map)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\", \") + \"]\";\n      });\n      var nextValidSequenceItems = (0, utils_1.map)(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \" + (idx + 1) + \". \" + itemMsg;\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function buildEarlyExitMessage(_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n        actual = _a.actual,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = (0, utils_1.first)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = (0, utils_1.map)(expectedIterationPaths, function (currPath) {\n        return \"[\" + (0, utils_1.map)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\",\") + \"]\";\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof gast_public_1.Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof gast_public_1.NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = (0, utils_1.first)(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = (0, gast_1.getProductionDslName)(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \"; // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError: function buildNamespaceConflictError(rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function buildAlternationPrefixAmbiguityError(options) {\n    var pathMsg = (0, utils_1.map)(options.prefixPath, function (currTok) {\n      return (0, tokens_public_1.tokenLabel)(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" + (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function buildAlternationAmbiguityError(options) {\n    var pathMsg = (0, utils_1.map)(options.prefixPath, function (currtok) {\n      return (0, tokens_public_1.tokenLabel)(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" + (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function buildEmptyRepetitionError(options) {\n    var dslName = (0, gast_1.getProductionDslName)(options.repetition);\n\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n\n    var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError: function buildTokenNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError: function buildEmptyAlternationError(options) {\n    var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" + (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function buildTooManyAlternativesError(options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function buildLeftRecursionError(options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = utils.map(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = ruleName + \" --> \" + pathNames.concat([ruleName]).join(\" --> \");\n    var errMsg = \"Left Recursion found in grammar.\\n\" + (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") + (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError: function buildInvalidRuleNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError: function buildDuplicateRuleNameError(options) {\n    var ruleName;\n\n    if (options.topLevelRule instanceof gast_public_1.Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n\n    var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n    return errMsg;\n  }\n};","map":{"version":3,"sources":["../../../src/parse/errors_public.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\nvar tokens_public_1 = require(\"../scan/tokens_public\");\nvar utils = require(\"@chevrotain/utils\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar gast_public_1 = require(\"./grammar/gast/gast_public\");\nvar gast_1 = require(\"./grammar/gast/gast\");\nexports.defaultParserErrorProvider = {\n    buildMismatchTokenMessage: function (_a) {\n        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;\n        var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n        var expectedMsg = hasLabel\n            ? \"--> \" + (0, tokens_public_1.tokenLabel)(expected) + \" <--\"\n            : \"token of type --> \" + expected.name + \" <--\";\n        var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n        return msg;\n    },\n    buildNotAllInputParsedMessage: function (_a) {\n        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage: function (_a) {\n        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = (0, utils_1.first)(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var allLookAheadPaths = (0, utils_1.reduce)(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);\n            var nextValidTokenSequences = (0, utils_1.map)(allLookAheadPaths, function (currPath) {\n                return \"[\" + (0, utils_1.map)(currPath, function (currTokenType) { return (0, tokens_public_1.tokenLabel)(currTokenType); }).join(\", \") + \"]\";\n            });\n            var nextValidSequenceItems = (0, utils_1.map)(nextValidTokenSequences, function (itemMsg, idx) { return \"  \" + (idx + 1) + \". \" + itemMsg; });\n            var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage: function (_a) {\n        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = (0, utils_1.first)(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var nextValidTokenSequences = (0, utils_1.map)(expectedIterationPaths, function (currPath) {\n                return \"[\" + (0, utils_1.map)(currPath, function (currTokenType) { return (0, tokens_public_1.tokenLabel)(currTokenType); }).join(\",\") + \"]\";\n            });\n            var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" +\n                (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof gast_public_1.Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof gast_public_1.NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = (0, utils_1.first)(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = (0, gast_1.getProductionDslName)(duplicateProd);\n        var extraArgument = getExtraProductionArgument(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError: function (rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\n\" +\n            (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") +\n            \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" +\n            \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" +\n            \"and Non-Terminal names start with a lower case letter.\";\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError: function (options) {\n        var pathMsg = (0, utils_1.map)(options.prefixPath, function (currTok) {\n            return (0, tokens_public_1.tokenLabel)(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" +\n            (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") +\n            \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" +\n            \"For Further details.\";\n        return errMsg;\n    },\n    buildAlternationAmbiguityError: function (options) {\n        var pathMsg = (0, utils_1.map)(options.prefixPath, function (currtok) {\n            return (0, tokens_public_1.tokenLabel)(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" +\n            (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage =\n            currMessage +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" +\n                \"For Further details.\";\n        return currMessage;\n    },\n    buildEmptyRepetitionError: function (options) {\n        var dslName = (0, gast_1.getProductionDslName)(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" +\n            \"This could lead to an infinite loop.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError: function (options) {\n        var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" +\n            (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") +\n            \"Only the last alternative may be an empty alternative.\";\n        return errMsg;\n    },\n    buildTooManyAlternativesError: function (options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" +\n            (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n        return errMsg;\n    },\n    buildLeftRecursionError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = utils.map(options.leftRecursionPath, function (currRule) { return currRule.name; });\n        var leftRecursivePath = ruleName + \" --> \" + pathNames\n            .concat([ruleName])\n            .join(\" --> \");\n        var errMsg = \"Left Recursion found in grammar.\\n\" +\n            (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") +\n            (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") +\n            \" To fix this refactor your grammar to remove the left recursion.\\n\" +\n            \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError: function (options) {\n        var ruleName;\n        if (options.topLevelRule instanceof gast_public_1.Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n        return errMsg;\n    }\n};\n//# sourceMappingURL=errors_public.js.map"]},"metadata":{},"sourceType":"script"}