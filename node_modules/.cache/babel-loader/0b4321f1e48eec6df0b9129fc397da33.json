{"ast":null,"code":"import { Frustum, Vector3 } from 'three';\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\n\nconst SelectionBox = (() => {\n  const frustum = new Frustum();\n  const center = new Vector3();\n  const tmpPoint = new Vector3();\n  const vecNear = new Vector3();\n  const vecTopLeft = new Vector3();\n  const vecTopRight = new Vector3();\n  const vecDownRight = new Vector3();\n  const vecDownLeft = new Vector3();\n  const vecFarTopLeft = new Vector3();\n  const vecFarTopRight = new Vector3();\n  const vecFarDownRight = new Vector3();\n  const vecFarDownLeft = new Vector3();\n  const vectemp1 = new Vector3();\n  const vectemp2 = new Vector3();\n  const vectemp3 = new Vector3();\n\n  class SelectionBox {\n    constructor(camera, scene, deep) {\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new Vector3();\n      this.endPoint = new Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n\n    select(startPoint, endPoint) {\n      this.startPoint = startPoint || this.startPoint;\n      this.endPoint = endPoint || this.endPoint;\n      this.collection = [];\n      this.updateFrustum(this.startPoint, this.endPoint);\n      this.searchChildInFrustum(frustum, this.scene);\n      return this.collection;\n    }\n\n    updateFrustum(startPoint, endPoint) {\n      startPoint = startPoint || this.startPoint;\n      endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n      if (startPoint.x === endPoint.x) {\n        endPoint.x += Number.EPSILON;\n      }\n\n      if (startPoint.y === endPoint.y) {\n        endPoint.y += Number.EPSILON;\n      }\n\n      this.camera.updateProjectionMatrix();\n      this.camera.updateMatrixWorld();\n\n      if (this.camera.isPerspectiveCamera) {\n        tmpPoint.copy(startPoint);\n        tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n        tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n        endPoint.x = Math.max(startPoint.x, endPoint.x);\n        endPoint.y = Math.min(startPoint.y, endPoint.y);\n        vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n        vecTopLeft.copy(tmpPoint);\n        vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n        vecDownRight.copy(endPoint);\n        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vectemp1.copy(vecTopLeft).sub(vecNear);\n        vectemp2.copy(vecTopRight).sub(vecNear);\n        vectemp3.copy(vecDownRight).sub(vecNear);\n        vectemp1.normalize();\n        vectemp2.normalize();\n        vectemp3.normalize();\n        vectemp1.multiplyScalar(this.deep);\n        vectemp2.multiplyScalar(this.deep);\n        vectemp3.multiplyScalar(this.deep);\n        vectemp1.add(vecNear);\n        vectemp2.add(vecNear);\n        vectemp3.add(vecNear);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n        planes[5].normal.multiplyScalar(-1);\n      } else if (this.camera.isOrthographicCamera) {\n        const left = Math.min(startPoint.x, endPoint.x);\n        const top = Math.max(startPoint.y, endPoint.y);\n        const right = Math.max(startPoint.x, endPoint.x);\n        const down = Math.min(startPoint.y, endPoint.y);\n        vecTopLeft.set(left, top, -1);\n        vecTopRight.set(right, top, -1);\n        vecDownRight.set(right, down, -1);\n        vecDownLeft.set(left, down, -1);\n        vecFarTopLeft.set(left, top, 1);\n        vecFarTopRight.set(right, top, 1);\n        vecFarDownRight.set(right, down, 1);\n        vecFarDownLeft.set(left, down, 1);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vecFarTopLeft.unproject(this.camera);\n        vecFarTopRight.unproject(this.camera);\n        vecFarDownRight.unproject(this.camera);\n        vecFarDownLeft.unproject(this.camera);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n        planes[5].normal.multiplyScalar(-1);\n      } else {\n        console.error('THREE.SelectionBox: Unsupported camera type.');\n      }\n    }\n\n    searchChildInFrustum(frustum, object) {\n      if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material !== undefined) {\n          if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n          center.copy(object.geometry.boundingSphere.center);\n          center.applyMatrix4(object.matrixWorld);\n\n          if (frustum.containsPoint(center)) {\n            this.collection.push(object);\n          }\n        }\n      }\n\n      if (object.children.length > 0) {\n        for (let x = 0; x < object.children.length; x++) {\n          this.searchChildInFrustum(frustum, object.children[x]);\n        }\n      }\n    }\n\n  }\n\n  return SelectionBox;\n})();\n\nexport { SelectionBox };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/interactive/SelectionBox.js"],"names":["Frustum","Vector3","SelectionBox","frustum","center","tmpPoint","vecNear","vecTopLeft","vecTopRight","vecDownRight","vecDownLeft","vecFarTopLeft","vecFarTopRight","vecFarDownRight","vecFarDownLeft","vectemp1","vectemp2","vectemp3","constructor","camera","scene","deep","startPoint","endPoint","collection","Number","MAX_VALUE","select","updateFrustum","searchChildInFrustum","x","EPSILON","y","updateProjectionMatrix","updateMatrixWorld","isPerspectiveCamera","copy","Math","min","max","setFromMatrixPosition","matrixWorld","set","unproject","sub","normalize","multiplyScalar","add","planes","setFromCoplanarPoints","normal","isOrthographicCamera","left","top","right","down","console","error","object","isMesh","isLine","isPoints","material","undefined","geometry","boundingSphere","computeBoundingSphere","applyMatrix4","containsPoint","push","children","length"],"mappings":"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","sourcesContent":["import { Frustum, Vector3 } from 'three';\n\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\n\nconst SelectionBox = (() => {\n  const frustum = new Frustum();\n  const center = new Vector3();\n  const tmpPoint = new Vector3();\n  const vecNear = new Vector3();\n  const vecTopLeft = new Vector3();\n  const vecTopRight = new Vector3();\n  const vecDownRight = new Vector3();\n  const vecDownLeft = new Vector3();\n  const vecFarTopLeft = new Vector3();\n  const vecFarTopRight = new Vector3();\n  const vecFarDownRight = new Vector3();\n  const vecFarDownLeft = new Vector3();\n  const vectemp1 = new Vector3();\n  const vectemp2 = new Vector3();\n  const vectemp3 = new Vector3();\n\n  class SelectionBox {\n    constructor(camera, scene, deep) {\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new Vector3();\n      this.endPoint = new Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n\n    select(startPoint, endPoint) {\n      this.startPoint = startPoint || this.startPoint;\n      this.endPoint = endPoint || this.endPoint;\n      this.collection = [];\n      this.updateFrustum(this.startPoint, this.endPoint);\n      this.searchChildInFrustum(frustum, this.scene);\n      return this.collection;\n    }\n\n    updateFrustum(startPoint, endPoint) {\n      startPoint = startPoint || this.startPoint;\n      endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n      if (startPoint.x === endPoint.x) {\n        endPoint.x += Number.EPSILON;\n      }\n\n      if (startPoint.y === endPoint.y) {\n        endPoint.y += Number.EPSILON;\n      }\n\n      this.camera.updateProjectionMatrix();\n      this.camera.updateMatrixWorld();\n\n      if (this.camera.isPerspectiveCamera) {\n        tmpPoint.copy(startPoint);\n        tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n        tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n        endPoint.x = Math.max(startPoint.x, endPoint.x);\n        endPoint.y = Math.min(startPoint.y, endPoint.y);\n        vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n        vecTopLeft.copy(tmpPoint);\n        vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n        vecDownRight.copy(endPoint);\n        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vectemp1.copy(vecTopLeft).sub(vecNear);\n        vectemp2.copy(vecTopRight).sub(vecNear);\n        vectemp3.copy(vecDownRight).sub(vecNear);\n        vectemp1.normalize();\n        vectemp2.normalize();\n        vectemp3.normalize();\n        vectemp1.multiplyScalar(this.deep);\n        vectemp2.multiplyScalar(this.deep);\n        vectemp3.multiplyScalar(this.deep);\n        vectemp1.add(vecNear);\n        vectemp2.add(vecNear);\n        vectemp3.add(vecNear);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n        planes[5].normal.multiplyScalar(-1);\n      } else if (this.camera.isOrthographicCamera) {\n        const left = Math.min(startPoint.x, endPoint.x);\n        const top = Math.max(startPoint.y, endPoint.y);\n        const right = Math.max(startPoint.x, endPoint.x);\n        const down = Math.min(startPoint.y, endPoint.y);\n        vecTopLeft.set(left, top, -1);\n        vecTopRight.set(right, top, -1);\n        vecDownRight.set(right, down, -1);\n        vecDownLeft.set(left, down, -1);\n        vecFarTopLeft.set(left, top, 1);\n        vecFarTopRight.set(right, top, 1);\n        vecFarDownRight.set(right, down, 1);\n        vecFarDownLeft.set(left, down, 1);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vecFarTopLeft.unproject(this.camera);\n        vecFarTopRight.unproject(this.camera);\n        vecFarDownRight.unproject(this.camera);\n        vecFarDownLeft.unproject(this.camera);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n        planes[5].normal.multiplyScalar(-1);\n      } else {\n        console.error('THREE.SelectionBox: Unsupported camera type.');\n      }\n    }\n\n    searchChildInFrustum(frustum, object) {\n      if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material !== undefined) {\n          if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n          center.copy(object.geometry.boundingSphere.center);\n          center.applyMatrix4(object.matrixWorld);\n\n          if (frustum.containsPoint(center)) {\n            this.collection.push(object);\n          }\n        }\n      }\n\n      if (object.children.length > 0) {\n        for (let x = 0; x < object.children.length; x++) {\n          this.searchChildInFrustum(frustum, object.children[x]);\n        }\n      }\n    }\n\n  }\n\n  return SelectionBox;\n})();\n\nexport { SelectionBox };\n"]},"metadata":{},"sourceType":"module"}