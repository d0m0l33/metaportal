"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");class t extends e.Mesh{constructor(r,n={}){super(r),this.type="Reflector";const a=this,o=void 0!==n.color?new e.Color(n.color):new e.Color(8355711),i=n.textureWidth||512,l=n.textureHeight||512,s=n.clipBias||0,d=n.shader||t.ReflectorShader,c=new e.Plane,u=new e.Vector3,m=new e.Vector3,x=new e.Vector3,p=new e.Matrix4,v=new e.Vector3(0,0,-1),f=new e.Vector4,b=new e.Vector3,M=new e.Vector3,w=new e.Vector4,g=new e.Matrix4,h=new e.PerspectiveCamera,y={minFilter:e.LinearFilter,magFilter:e.LinearFilter,format:e.RGBFormat},R=new e.WebGLRenderTarget(i,l,y);e.MathUtils.isPowerOfTwo(i)&&e.MathUtils.isPowerOfTwo(l)||(R.texture.generateMipmaps=!1);const U=new e.ShaderMaterial({uniforms:e.UniformsUtils.clone(d.uniforms),fragmentShader:d.fragmentShader,vertexShader:d.vertexShader});U.uniforms.tDiffuse.value=R.texture,U.uniforms.color.value=o,U.uniforms.textureMatrix.value=g,this.material=U,this.onBeforeRender=function(e,t,r){if(m.setFromMatrixPosition(a.matrixWorld),x.setFromMatrixPosition(r.matrixWorld),p.extractRotation(a.matrixWorld),u.set(0,0,1),u.applyMatrix4(p),b.subVectors(m,x),b.dot(u)>0)return;b.reflect(u).negate(),b.add(m),p.extractRotation(r.matrixWorld),v.set(0,0,-1),v.applyMatrix4(p),v.add(x),M.subVectors(m,v),M.reflect(u).negate(),M.add(m),h.position.copy(b),h.up.set(0,1,0),h.up.applyMatrix4(p),h.up.reflect(u),h.lookAt(M),h.far=r.far,h.updateMatrixWorld(),h.projectionMatrix.copy(r.projectionMatrix),g.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),g.multiply(h.projectionMatrix),g.multiply(h.matrixWorldInverse),g.multiply(a.matrixWorld),c.setFromNormalAndCoplanarPoint(u,m),c.applyMatrix4(h.matrixWorldInverse),f.set(c.normal.x,c.normal.y,c.normal.z,c.constant);const n=h.projectionMatrix;w.x=(Math.sign(f.x)+n.elements[8])/n.elements[0],w.y=(Math.sign(f.y)+n.elements[9])/n.elements[5],w.z=-1,w.w=(1+n.elements[10])/n.elements[14],f.multiplyScalar(2/f.dot(w)),n.elements[2]=f.x,n.elements[6]=f.y,n.elements[10]=f.z+1-s,n.elements[14]=f.w,R.texture.encoding=e.outputEncoding,a.visible=!1;const o=e.getRenderTarget(),i=e.xr.enabled,l=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(R),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,h),e.xr.enabled=i,e.shadowMap.autoUpdate=l,e.setRenderTarget(o);const d=r.viewport;void 0!==d&&e.state.viewport(d),a.visible=!0},this.getRenderTarget=function(){return R}}}t.prototype.isReflector=!0,t.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},exports.Reflector=t;
