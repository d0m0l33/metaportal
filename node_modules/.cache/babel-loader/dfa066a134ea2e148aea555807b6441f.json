{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\nconst cb = new Vector3(),\n      ab = new Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nclass Vertex {\n  constructor(v, id) {\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"faces\", void 0);\n\n    _defineProperty(this, \"neighbors\", void 0);\n\n    _defineProperty(this, \"collapseCost\", void 0);\n\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n\n    _defineProperty(this, \"minCost\", 0);\n\n    _defineProperty(this, \"totalCost\", 0);\n\n    _defineProperty(this, \"costCount\", 0);\n\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  }\n\n} // we use a triangle class to represent structure of face slightly differently\n\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"c\", void 0);\n\n    _defineProperty(this, \"v1\", void 0);\n\n    _defineProperty(this, \"v2\", void 0);\n\n    _defineProperty(this, \"v3\", void 0);\n\n    _defineProperty(this, \"normal\", new Vector3());\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n\n}\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\n\nclass SimplifyModifier {\n  constructor() {\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      const borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        this.removeVertex(u, vertices);\n        return;\n      }\n\n      let i;\n      const tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\n      // O(n * n) approach. TODO optimize this\n      let least = vertices[0];\n\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n\n    _defineProperty(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (let name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      const vertices = [];\n      const faces = []; // add vertices\n\n      const positionAttribute = geometry.getAttribute('position');\n\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      const geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n\n      let nextVertex;\n      let z = count;\n\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = []; //\n\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      } //\n\n\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n\n    removeFromArray(vertices, v);\n  }\n\n}\n\nexport { SimplifyModifier };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/modifiers/SimplifyModifier.js"],"names":["_defineProperty","Vector3","BufferGeometry","Float32BufferAttribute","mergeVertices","cb","ab","pushIfUnique","array","object","indexOf","push","removeFromArray","k","splice","Vertex","constructor","v","id","position","faces","neighbors","collapseCost","collapseNeighbor","addUniqueNeighbor","vertex","removeIfNonNeighbor","n","offset","i","length","hasVertex","Triangle","v1","v2","v3","a","b","c","computeNormal","vA","vB","vC","subVectors","cross","normalize","normal","copy","replaceVertex","oldv","newv","SimplifyModifier","u","edgelength","distanceTo","curvature","sideFaces","il","face","sideFace","minCurvature","j","dotProd","dot","Math","min","max","borders","amt","computeEdgeCollapseCost","minCost","totalCost","costCount","f","vs","vertices","removeVertex","tmpVertices","removeFace","computeEdgeCostAtVertex","least","geometry","count","clone","attributes","name","deleteAttribute","positionAttribute","getAttribute","fromBufferAttribute","geomIndex","getIndex","getX","triangle","nextVertex","z","minimumCostEdge","console","log","collapse","simplifiedGeometry","index","x","y","setAttribute","setIndex","assert","pop"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\n\nconst cb = new Vector3(),\n      ab = new Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nclass Vertex {\n  constructor(v, id) {\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"faces\", void 0);\n\n    _defineProperty(this, \"neighbors\", void 0);\n\n    _defineProperty(this, \"collapseCost\", void 0);\n\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n\n    _defineProperty(this, \"minCost\", 0);\n\n    _defineProperty(this, \"totalCost\", 0);\n\n    _defineProperty(this, \"costCount\", 0);\n\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  }\n\n} // we use a triangle class to represent structure of face slightly differently\n\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"c\", void 0);\n\n    _defineProperty(this, \"v1\", void 0);\n\n    _defineProperty(this, \"v2\", void 0);\n\n    _defineProperty(this, \"v3\", void 0);\n\n    _defineProperty(this, \"normal\", new Vector3());\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n\n}\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\n\nclass SimplifyModifier {\n  constructor() {\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      const borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        this.removeVertex(u, vertices);\n        return;\n      }\n\n      let i;\n      const tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\n      // O(n * n) approach. TODO optimize this\n      let least = vertices[0];\n\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n\n    _defineProperty(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (let name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      const vertices = [];\n      const faces = []; // add vertices\n\n      const positionAttribute = geometry.getAttribute('position');\n\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      const geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n\n      let nextVertex;\n      let z = count;\n\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = []; //\n\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      } //\n\n\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n\n    removeFromArray(vertices, v);\n  }\n\n}\n\nexport { SimplifyModifier };\n"]},"metadata":{},"sourceType":"module"}