{"ast":null,"code":"import { Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute } from 'three';\n\nclass Lensflare extends Mesh {\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.type = 'Lensflare';\n    this.frustumCulled = false;\n    this.renderOrder = Infinity; //\n\n    const positionScreen = new Vector3();\n    const positionView = new Vector3(); // textures\n\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBFormat);\n    tempMap.minFilter = NearestFilter;\n    tempMap.magFilter = NearestFilter;\n    tempMap.wrapS = ClampToEdgeWrapping;\n    tempMap.wrapT = ClampToEdgeWrapping;\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBFormat);\n    occlusionMap.minFilter = NearestFilter;\n    occlusionMap.magFilter = NearestFilter;\n    occlusionMap.wrapS = ClampToEdgeWrapping;\n    occlusionMap.wrapT = ClampToEdgeWrapping; // material\n\n    const geometry = Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: tempMap\n        },\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    }); // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a); //\n\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: null\n        },\n        occlusionMap: {\n          value: occlusionMap\n        },\n        color: {\n          value: new Color(0xffffff)\n        },\n        scale: {\n          value: new Vector2()\n        },\n        screenPosition: {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry, material2);\n\n    this.addElement = function (element) {\n      elements.push(element);\n    }; //\n\n\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2.0;\n      const halfViewportHeight = viewport.w / 2.0;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return; // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad\n\n        let uniforms = material1a.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics\n\n        uniforms = material1b.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements\n\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms = material2.uniforms;\n          uniforms['color'].value.copy(element.color);\n          uniforms['map'].value = element.texture;\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect = viewport.w / viewport.z;\n          uniforms['scale'].value.set(size * invAspect, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n        }\n      }\n    };\n\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n\n}\n\nLensflare.prototype.isLensflare = true; //\n\nclass LensflareElement {\n  constructor(texture) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Color(0xffffff);\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n\n}\n\nLensflareElement.Shader = {\n  uniforms: {\n    map: {\n      value: null\n    },\n    occlusionMap: {\n      value: null\n    },\n    color: {\n      value: null\n    },\n    scale: {\n      value: null\n    },\n    screenPosition: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n};\n\nLensflare.Geometry = function () {\n  const geometry = new BufferGeometry();\n  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n  geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n  return geometry;\n}();\n\nexport { Lensflare, LensflareElement };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/objects/Lensflare.js"],"names":["Mesh","MeshBasicMaterial","Vector3","DataTexture","RGBFormat","NearestFilter","ClampToEdgeWrapping","RawShaderMaterial","Color","Vector2","AdditiveBlending","Box2","Vector4","BufferGeometry","InterleavedBuffer","InterleavedBufferAttribute","Lensflare","constructor","Geometry","opacity","transparent","type","frustumCulled","renderOrder","Infinity","positionScreen","positionView","tempMap","Uint8Array","minFilter","magFilter","wrapS","wrapT","occlusionMap","geometry","material1a","uniforms","scale","value","screenPosition","vertexShader","fragmentShader","depthTest","depthWrite","material1b","map","mesh1","elements","shader","LensflareElement","Shader","material2","color","blending","mesh2","addElement","element","push","screenPositionPixels","validArea","viewport","onBeforeRender","renderer","scene","camera","getCurrentViewport","invAspect","w","z","halfViewportWidth","halfViewportHeight","size","set","min","x","y","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","copy","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","texture","distance","uniformsNeedUpdate","dispose","prototype","isLensflare","float32Array","Float32Array","interleavedBuffer","setIndex","setAttribute"],"mappings":"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","sourcesContent":["import { Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute } from 'three';\n\nclass Lensflare extends Mesh {\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.type = 'Lensflare';\n    this.frustumCulled = false;\n    this.renderOrder = Infinity; //\n\n    const positionScreen = new Vector3();\n    const positionView = new Vector3(); // textures\n\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBFormat);\n    tempMap.minFilter = NearestFilter;\n    tempMap.magFilter = NearestFilter;\n    tempMap.wrapS = ClampToEdgeWrapping;\n    tempMap.wrapT = ClampToEdgeWrapping;\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBFormat);\n    occlusionMap.minFilter = NearestFilter;\n    occlusionMap.magFilter = NearestFilter;\n    occlusionMap.wrapS = ClampToEdgeWrapping;\n    occlusionMap.wrapT = ClampToEdgeWrapping; // material\n\n    const geometry = Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: tempMap\n        },\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    }); // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a); //\n\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: null\n        },\n        occlusionMap: {\n          value: occlusionMap\n        },\n        color: {\n          value: new Color(0xffffff)\n        },\n        scale: {\n          value: new Vector2()\n        },\n        screenPosition: {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry, material2);\n\n    this.addElement = function (element) {\n      elements.push(element);\n    }; //\n\n\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2.0;\n      const halfViewportHeight = viewport.w / 2.0;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return; // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad\n\n        let uniforms = material1a.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics\n\n        uniforms = material1b.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements\n\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms = material2.uniforms;\n          uniforms['color'].value.copy(element.color);\n          uniforms['map'].value = element.texture;\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect = viewport.w / viewport.z;\n          uniforms['scale'].value.set(size * invAspect, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n        }\n      }\n    };\n\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n\n}\n\nLensflare.prototype.isLensflare = true; //\n\nclass LensflareElement {\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n\n}\n\nLensflareElement.Shader = {\n  uniforms: {\n    map: {\n      value: null\n    },\n    occlusionMap: {\n      value: null\n    },\n    color: {\n      value: null\n    },\n    scale: {\n      value: null\n    },\n    screenPosition: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n};\n\nLensflare.Geometry = function () {\n  const geometry = new BufferGeometry();\n  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n  geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n  return geometry;\n}();\n\nexport { Lensflare, LensflareElement };\n"]},"metadata":{},"sourceType":"module"}