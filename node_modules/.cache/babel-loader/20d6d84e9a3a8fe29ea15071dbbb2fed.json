{"ast":null,"code":"import { CompressedTextureLoader, CompressedTexture, FileLoader, sRGBEncoding, LinearEncoding } from 'three';\nimport { BasisTextureLoader } from './BasisTextureLoader.js';\nimport { ZSTDDecoder } from 'zstddec';\nimport { read, KTX2Model, KTX2Transfer, KTX2SupercompressionScheme, KTX2ChannelUASTC, KTX2ChannelETC1S, KTX2Flags } from 'ktx-parse';\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nclass KTX2Loader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.basisLoader = new BasisTextureLoader(manager);\n    this.zstd = new ZSTDDecoder();\n    this.zstd.init();\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.basisLoader.setTranscoderPath(path);\n    return this;\n  }\n\n  setWorkerLimit(path) {\n    this.basisLoader.setWorkerLimit(path);\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.basisLoader.detectSupport(renderer);\n    return this;\n  }\n\n  dispose() {\n    this.basisLoader.dispose();\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new CompressedTexture();\n    var bufferPending = new Promise(function (resolve, reject) {\n      new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n    });\n    bufferPending.then(function (buffer) {\n      scope.parse(buffer, function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onError);\n    }).catch(onError);\n    return texture;\n  }\n\n  parse(buffer, onLoad, onError) {\n    var scope = this;\n    var ktx = read(new Uint8Array(buffer));\n\n    if (ktx.pixelDepth > 0) {\n      throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n    }\n\n    if (ktx.layerCount > 1) {\n      throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n    }\n\n    if (ktx.faceCount > 1) {\n      throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n    }\n\n    var dfd = KTX2Utils.getBasicDFD(ktx);\n    KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n      var basisFormat = dfd.colorModel === KTX2Model.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n      var parseConfig = {\n        levels: levels,\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        basisFormat: basisFormat,\n        hasAlpha: KTX2Utils.getAlpha(ktx)\n      };\n\n      if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n        parseConfig.globalData = ktx.globalData;\n      }\n\n      return scope.basisLoader.parseInternalAsync(parseConfig);\n    }).then(function (texture) {\n      texture.encoding = dfd.transferFunction === KTX2Transfer.SRGB ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n      onLoad(texture);\n    }).catch(onError);\n    return this;\n  }\n\n}\n\nvar KTX2Utils = {\n  createLevels: async function (ktx, zstd) {\n    if (ktx.supercompressionScheme === KTX2SupercompressionScheme.ZSTD) {\n      await zstd.init();\n    }\n\n    var levels = [];\n    var width = ktx.pixelWidth;\n    var height = ktx.pixelHeight;\n\n    for (var levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n      var levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n      var levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n      var levelData = ktx.levels[levelIndex].levelData;\n\n      if (ktx.supercompressionScheme === KTX2SupercompressionScheme.ZSTD) {\n        levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n      }\n\n      levels.push({\n        index: levelIndex,\n        width: levelWidth,\n        height: levelHeight,\n        data: levelData\n      });\n    }\n\n    return levels;\n  },\n  getBasicDFD: function (ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === KTX2Model.UASTC) {\n      if ((dfd.samples[0].channelID & 0xf) === KTX2ChannelUASTC.RGBA) {\n        return true;\n      }\n\n      return false;\n    } // ETC1S\n\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === KTX2ChannelETC1S.AAA) {\n      return true;\n    }\n\n    return false;\n  },\n  getPremultiplyAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & KTX2Flags.ALPHA_PREMULTIPLIED);\n  }\n};\nexport { KTX2Loader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/loaders/KTX2Loader.js"],"names":["CompressedTextureLoader","CompressedTexture","FileLoader","sRGBEncoding","LinearEncoding","BasisTextureLoader","ZSTDDecoder","read","KTX2Model","KTX2Transfer","KTX2SupercompressionScheme","KTX2ChannelUASTC","KTX2ChannelETC1S","KTX2Flags","KTX2Loader","constructor","manager","basisLoader","zstd","init","MSC_TRANSCODER","console","warn","setTranscoderPath","path","setWorkerLimit","detectSupport","renderer","dispose","load","url","onLoad","onProgress","onError","scope","texture","bufferPending","Promise","resolve","reject","setPath","setResponseType","then","buffer","parse","_texture","copy","needsUpdate","catch","ktx","Uint8Array","pixelDepth","Error","layerCount","faceCount","dfd","KTX2Utils","getBasicDFD","createLevels","levels","basisFormat","colorModel","UASTC","BasisFormat","UASTC_4x4","ETC1S","parseConfig","width","pixelWidth","height","pixelHeight","hasAlpha","getAlpha","globalData","parseInternalAsync","encoding","transferFunction","SRGB","premultiplyAlpha","getPremultiplyAlpha","supercompressionScheme","ZSTD","levelIndex","length","levelWidth","Math","max","floor","pow","levelHeight","levelData","decode","uncompressedByteLength","push","index","data","dataFormatDescriptor","samples","channelID","RGBA","AAA","flags","ALPHA_PREMULTIPLIED"],"mappings":"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","sourcesContent":["import { CompressedTextureLoader, CompressedTexture, FileLoader, sRGBEncoding, LinearEncoding } from 'three';\nimport { BasisTextureLoader } from './BasisTextureLoader.js';\nimport { ZSTDDecoder } from 'zstddec';\nimport { read, KTX2Model, KTX2Transfer, KTX2SupercompressionScheme, KTX2ChannelUASTC, KTX2ChannelETC1S, KTX2Flags } from 'ktx-parse';\n\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nclass KTX2Loader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.basisLoader = new BasisTextureLoader(manager);\n    this.zstd = new ZSTDDecoder();\n    this.zstd.init();\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.basisLoader.setTranscoderPath(path);\n    return this;\n  }\n\n  setWorkerLimit(path) {\n    this.basisLoader.setWorkerLimit(path);\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.basisLoader.detectSupport(renderer);\n    return this;\n  }\n\n  dispose() {\n    this.basisLoader.dispose();\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new CompressedTexture();\n    var bufferPending = new Promise(function (resolve, reject) {\n      new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n    });\n    bufferPending.then(function (buffer) {\n      scope.parse(buffer, function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onError);\n    }).catch(onError);\n    return texture;\n  }\n\n  parse(buffer, onLoad, onError) {\n    var scope = this;\n    var ktx = read(new Uint8Array(buffer));\n\n    if (ktx.pixelDepth > 0) {\n      throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n    }\n\n    if (ktx.layerCount > 1) {\n      throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n    }\n\n    if (ktx.faceCount > 1) {\n      throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n    }\n\n    var dfd = KTX2Utils.getBasicDFD(ktx);\n    KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n      var basisFormat = dfd.colorModel === KTX2Model.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n      var parseConfig = {\n        levels: levels,\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        basisFormat: basisFormat,\n        hasAlpha: KTX2Utils.getAlpha(ktx)\n      };\n\n      if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n        parseConfig.globalData = ktx.globalData;\n      }\n\n      return scope.basisLoader.parseInternalAsync(parseConfig);\n    }).then(function (texture) {\n      texture.encoding = dfd.transferFunction === KTX2Transfer.SRGB ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n      onLoad(texture);\n    }).catch(onError);\n    return this;\n  }\n\n}\n\nvar KTX2Utils = {\n  createLevels: async function (ktx, zstd) {\n    if (ktx.supercompressionScheme === KTX2SupercompressionScheme.ZSTD) {\n      await zstd.init();\n    }\n\n    var levels = [];\n    var width = ktx.pixelWidth;\n    var height = ktx.pixelHeight;\n\n    for (var levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n      var levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n      var levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n      var levelData = ktx.levels[levelIndex].levelData;\n\n      if (ktx.supercompressionScheme === KTX2SupercompressionScheme.ZSTD) {\n        levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n      }\n\n      levels.push({\n        index: levelIndex,\n        width: levelWidth,\n        height: levelHeight,\n        data: levelData\n      });\n    }\n\n    return levels;\n  },\n  getBasicDFD: function (ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === KTX2Model.UASTC) {\n      if ((dfd.samples[0].channelID & 0xf) === KTX2ChannelUASTC.RGBA) {\n        return true;\n      }\n\n      return false;\n    } // ETC1S\n\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === KTX2ChannelETC1S.AAA) {\n      return true;\n    }\n\n    return false;\n  },\n  getPremultiplyAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & KTX2Flags.ALPHA_PREMULTIPLIED);\n  }\n};\n\nexport { KTX2Loader };\n"]},"metadata":{},"sourceType":"module"}