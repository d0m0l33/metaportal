{"ast":null,"code":"import { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide } from 'three';\nimport { TGALoader } from './TGALoader.js';\nimport { Parser } from 'mmd-parser';\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\n/**\n * @param {THREE.LoadingManager} manager\n */\n\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null; // lazy generation\n\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n\n\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath;\n    return this;\n  } // Load MMD assets as Three.js Object\n\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin); // resource path\n\n    let resourcePath;\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== '') {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n\n    const modelExtension = this._extractExtension(url).toLowerCase(); // Should I detect by seeing header?\n\n\n    if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n      if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'));\n      return;\n    }\n\n    this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](url, function (data) {\n      onLoad(builder.build(data, resourcePath, onProgress, onError));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder;\n    this.loadVMD(url, function (vmd) {\n      onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this;\n    this.load(modelUrl, function (mesh) {\n      scope.loadAnimation(vmdUrl, mesh, function (animation) {\n        onLoad({\n          mesh: mesh,\n          animation: animation\n        });\n      }, onProgress, onError);\n    }, onProgress, onError);\n  } // Load MMD assets as Object data parsed by MMDParser\n\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n\n    this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmd(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n\n    this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmx(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url];\n    const vmds = [];\n    const vmdNum = urls.length;\n\n    const parser = this._getParser();\n\n    this.loader.setMimeType(undefined).setPath(this.animationPath).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(urls[i], function (buffer) {\n        vmds.push(parser.parseVmd(buffer, true));\n        if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n      }, onProgress, onError);\n    }\n  }\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n\n    this.loader.setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis').setPath(this.animationPath).setResponseType('text').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n      onLoad(parser.parseVpd(text, true));\n    }, onProgress, onError);\n  } // private methods\n\n\n  _extractExtension(url) {\n    const index = url.lastIndexOf('.');\n    return index < 0 ? '' : url.slice(index + 1);\n  }\n\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser(); // eslint-disable-line no-undef\n    }\n\n    return this.parser;\n  }\n\n} // Utilities\n\n/*\n * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n * We don't need to request external toon image files.\n * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n */\n\n\nconst DEFAULT_TOON_TEXTURES = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=']; // Builders. They build Three.js object from Object data parsed by MMDParser.\n\n/**\n * @param {THREE.LoadingManager} manager\n */\n\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = 'anonymous';\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n\n\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n\n\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data);\n    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n    const mesh = new SkinnedMesh(geometry, material);\n    const skeleton = new Skeleton(initBones(mesh));\n    mesh.bind(skeleton); // console.log( mesh ); // for console debug\n\n    return mesh;\n  }\n\n} // TODO: Try to remove this function\n\n\nfunction initBones(mesh) {\n  const geometry = mesh.geometry;\n  const bones = [];\n\n  if (geometry && geometry.bones !== undefined) {\n    // first, create array of 'Bone' objects from geometry data\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]; // create new 'Bone' object\n\n      const bone = new Bone();\n      bones.push(bone); // apply values\n\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\n    } // second, create bone hierarchy\n\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n        // subsequent bones in the hierarchy\n        bones[gbone.parent].add(bones[i]);\n      } else {\n        // topmost bone, immediate child of the skinned mesh\n        mesh.add(bones[i]);\n      }\n    }\n  } // now the bones are part of the scene graph and children of the skinned mesh.\n  // let's update the corresponding matrices\n\n\n  mesh.updateMatrixWorld(true);\n  return bones;\n} //\n\n\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    // for geometry\n    const positions = [];\n    const uvs = [];\n    const normals = [];\n    const indices = [];\n    const groups = [];\n    const bones = [];\n    const skinIndices = [];\n    const skinWeights = [];\n    const morphTargets = [];\n    const morphPositions = [];\n    const iks = [];\n    const grants = [];\n    const rigidBodies = [];\n    const constraints = []; // for work\n\n    let offset = 0;\n    const boneTypeTable = {}; // positions, normals, uvs, skinIndices, skinWeights\n\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i];\n\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j]);\n      }\n\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j]);\n      }\n\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j]);\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);\n      }\n    } // indices\n\n\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i];\n\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j]);\n      }\n    } // groups\n\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3\n      });\n      offset += material.faceCount;\n    } // bones\n\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i];\n      let value = boneTypeTable[body.boneIndex]; // keeps greater number if already value is set without any special reasons\n\n      value = value === undefined ? body.type : Math.max(body.type, value);\n      boneTypeTable[body.boneIndex] = value;\n    }\n\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i];\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1\n      };\n\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0];\n        bone.pos[1] -= data.bones[bone.parent].position[1];\n        bone.pos[2] -= data.bones[bone.parent].position[2];\n      }\n\n      bones.push(bone);\n    } // iks\n    // TODO: remove duplicated codes between PMD and PMX\n\n\n    if (data.metadata.format === 'pmd') {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i];\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: []\n        };\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n\n          if (data.bones[link.index].name.indexOf('ひざ') >= 0) {\n            link.limitation = new Vector3(1.0, 0.0, 0.0);\n          }\n\n          param.links.push(link);\n        }\n\n        iks.push(param);\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik;\n        if (ik === undefined) continue;\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: []\n        };\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n\n          if (ik.links[j].angleLimitation === 1) {\n            // Revert if rotationMin/Max doesn't work well\n            // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n            const rotationMin = ik.links[j].lowerLimitationAngle;\n            const rotationMax = ik.links[j].upperLimitationAngle; // Convert Left to Right coordinate by myself because\n            // MMDParser doesn't convert. It's a MMDParser's bug\n\n            const tmp1 = -rotationMax[0];\n            const tmp2 = -rotationMax[1];\n            rotationMax[0] = -rotationMin[0];\n            rotationMax[1] = -rotationMin[1];\n            rotationMin[0] = tmp1;\n            rotationMin[1] = tmp2;\n            link.rotationMin = new Vector3().fromArray(rotationMin);\n            link.rotationMax = new Vector3().fromArray(rotationMax);\n          }\n\n          param.links.push(link);\n        }\n\n        iks.push(param); // Save the reference even from bone data for efficiently\n        // simulating PMX animation system\n\n        bones[i].ik = param;\n      }\n    } // grants\n\n\n    if (data.metadata.format === 'pmx') {\n      // bone index -> grant entry map\n      const grantEntryMap = {};\n\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i];\n        const grant = boneData.grant;\n        if (grant === undefined) continue;\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass\n        };\n        grantEntryMap[i] = {\n          parent: null,\n          children: [],\n          param: param,\n          visited: false\n        };\n      }\n\n      const rootEntry = {\n        parent: null,\n        children: [],\n        param: null,\n        visited: false\n      }; // Build a tree representing grant hierarchy\n\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex];\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n        grantEntry.parent = parentGrantEntry;\n        parentGrantEntry.children.push(grantEntry);\n      } // Sort grant parameters from parents to children because\n      // grant uses parent's transform that parent's grant is already applied\n      // so grant should be applied in order from parents to children\n\n\n      function traverse(entry) {\n        if (entry.param) {\n          grants.push(entry.param); // Save the reference even from bone data for efficiently\n          // simulating PMX animation system\n\n          bones[entry.param.index].grant = entry.param;\n        }\n\n        entry.visited = true;\n\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i]; // Cut off a loop if exists. (Is a grant loop invalid?)\n\n          if (!child.visited) traverse(child);\n        }\n      }\n\n      traverse(rootEntry);\n    } // morph\n\n\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i];\n        let index;\n\n        if (data.metadata.format === 'pmd') {\n          index = data.morphs[0].elements[element.index].index;\n        } else {\n          index = element.index;\n        }\n\n        attribute.array[index * 3 + 0] += element.position[0] * ratio;\n        attribute.array[index * 3 + 1] += element.position[1] * ratio;\n        attribute.array[index * 3 + 2] += element.position[2] * ratio;\n      }\n    }\n\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i];\n      const params = {\n        name: morph.name\n      };\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n      attribute.name = morph.name;\n\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j];\n      }\n\n      if (data.metadata.format === 'pmd') {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1.0);\n        }\n      } else {\n        if (morph.type === 0) {\n          // group\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index];\n            const ratio = morph.elements[j].ratio;\n\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio);\n            }\n          }\n        } else if (morph.type === 1) {\n          // vertex\n          updateAttributes(attribute, morph, 1.0);\n        } else if (morph.type === 2) ;else if (morph.type === 3) ;else if (morph.type === 4) ;else if (morph.type === 5) ;else if (morph.type === 6) ;else if (morph.type === 7) ;else if (morph.type === 8) ;\n      }\n\n      morphTargets.push(params);\n      morphPositions.push(attribute);\n    } // rigid bodies from rigidBodies field.\n\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i];\n      const params = {};\n\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key];\n      }\n      /*\n       * RigidBody position parameter in PMX seems global position\n       * while the one in PMD seems offset from corresponding bone.\n       * So unify being offset.\n       */\n\n\n      if (data.metadata.format === 'pmx') {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex];\n          params.position[0] -= bone.position[0];\n          params.position[1] -= bone.position[1];\n          params.position[2] -= bone.position[2];\n        }\n      }\n\n      rigidBodies.push(params);\n    } // constraints from constraints field.\n\n\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i];\n      const params = {};\n\n      for (const key in constraint) {\n        params[key] = constraint[key];\n      }\n\n      const bodyA = rigidBodies[params.rigidBodyIndex1];\n      const bodyB = rigidBodies[params.rigidBodyIndex2]; // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n          bodyB.type = 1;\n        }\n      }\n\n      constraints.push(params);\n    } // build BufferGeometry.\n\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4));\n    geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4));\n    geometry.setIndex(indices);\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i);\n    }\n\n    geometry.bones = bones;\n    geometry.morphTargets = morphTargets;\n    geometry.morphAttributes.position = morphPositions;\n    geometry.morphTargetsRelative = false;\n    geometry.userData.MMD = {\n      bones: bones,\n      iks: iks,\n      grants: grants,\n      rigidBodies: rigidBodies,\n      constraints: constraints,\n      format: data.metadata.format\n    };\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n\n} //\n\n/**\n * @param {THREE.LoadingManager} manager\n */\n\n\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null; // lazy generation\n\n    this.crossOrigin = 'anonymous';\n    this.resourcePath = undefined;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n\n\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n\n\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n\n\n  build(data, geometry\n  /*, onProgress, onError */\n  ) {\n    const materials = [];\n    const textures = {};\n    this.textureLoader.setCrossOrigin(this.crossOrigin); // materials\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      const params = {\n        userData: {}\n      };\n      if (material.name !== undefined) params.name = material.name;\n      /*\n       * Color\n       *\n       * MMD         MeshToonMaterial\n       * diffuse  -  color\n       * ambient  -  emissive * a\n       *               (a = 1.0 without map texture or 0.2 with map texture)\n       *\n       * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n       * It'll be too bright if material has map texture so using coef 0.2.\n       */\n\n      params.color = new Color().fromArray(material.diffuse);\n      params.opacity = material.diffuse[3];\n      params.emissive = new Color().fromArray(material.ambient);\n      params.transparent = params.opacity !== 1.0; //\n\n      params.skinning = geometry.bones.length > 0 ? true : false;\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n      params.fog = true; // blend\n\n      params.blending = CustomBlending;\n      params.blendSrc = SrcAlphaFactor;\n      params.blendDst = OneMinusSrcAlphaFactor;\n      params.blendSrcAlpha = SrcAlphaFactor;\n      params.blendDstAlpha = DstAlphaFactor; // side\n\n      if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n        params.side = DoubleSide;\n      } else {\n        params.side = params.opacity === 1.0 ? FrontSide : DoubleSide;\n      }\n\n      if (data.metadata.format === 'pmd') {\n        // map, envMap\n        if (material.fileName) {\n          const fileName = material.fileName;\n          const fileNames = fileName.split('*'); // fileNames[ 0 ]: mapFileName\n          // fileNames[ 1 ]: envMapFileName( optional )\n\n          params.map = this._loadTexture(fileNames[0], textures);\n\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase();\n            params.envMap = this._loadTexture(fileNames[1], textures);\n            params.combine = extension === '.sph' ? MultiplyOperation : AddOperation;\n          }\n        } // gradientMap\n\n\n        const toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName;\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n        }); // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n          color: [0, 0, 0],\n          alpha: 1.0,\n          visible: material.edgeFlag === 1\n        };\n      } else {\n        // map\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n        } // envMap TODO: support m.envFlag === 3\n\n\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n        } // gradientMap\n\n\n        let toonFileName, isDefaultToon;\n\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp';\n          isDefaultToon = true;\n        } else {\n          toonFileName = data.textures[material.toonIndex];\n          isDefaultToon = false;\n        }\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon\n        }); // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300,\n          // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0\n        };\n      }\n\n      if (params.map !== undefined) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i);\n        }\n\n        params.emissive.multiplyScalar(0.2);\n      }\n\n      materials.push(new MeshToonMaterial(params));\n    }\n\n    if (data.metadata.format === 'pmx') {\n      // set transparent true if alpha morph is defined.\n      function checkAlphaMorph(elements, materials) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i];\n          if (element.index === -1) continue;\n          const material = materials[element.index];\n\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true;\n          }\n        }\n      }\n\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i];\n        const elements = morph.elements;\n\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index];\n            if (morph2.type !== 8) continue;\n            checkAlphaMorph(morph2.elements, materials);\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials);\n        }\n      }\n    }\n\n    return materials;\n  } // private methods\n\n\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === undefined) {\n        throw new Error('THREE.MMDLoader: Import TGALoader');\n      }\n\n      this.tgaLoader = new TGALoader(this.manager);\n    }\n\n    return this.tgaLoader;\n  }\n\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false;\n    return /toon(10|0[0-9])\\.bmp/.test(name);\n  }\n\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {};\n    const scope = this;\n    let fullPath;\n\n    if (params.isDefaultToonTexture === true) {\n      let index;\n\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n      } catch (e) {\n        console.warn('THREE.MMDLoader: ' + filePath + ' seems like a ' + 'not right default texture path. Using toon00.bmp instead.');\n        index = 0;\n      }\n\n      fullPath = DEFAULT_TOON_TEXTURES[index];\n    } else {\n      fullPath = this.resourcePath + filePath;\n    }\n\n    if (textures[fullPath] !== undefined) return textures[fullPath];\n    let loader = this.manager.getHandler(fullPath);\n\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader;\n    }\n\n    const texture = loader.load(fullPath, function (t) {\n      // MMD toon texture is Axis-Y oriented\n      // but Three.js gradient map is Axis-X oriented.\n      // So here replaces the toon texture image with the rotated one.\n      if (params.isToonTexture === true) {\n        t.image = scope._getRotatedImage(t.image);\n        t.magFilter = NearestFilter;\n        t.minFilter = NearestFilter;\n      }\n\n      t.flipY = false;\n      t.wrapS = RepeatWrapping;\n      t.wrapT = RepeatWrapping;\n\n      for (let i = 0; i < texture.readyCallbacks.length; i++) {\n        texture.readyCallbacks[i](texture);\n      }\n\n      delete texture.readyCallbacks;\n    }, onProgress, onError);\n    texture.readyCallbacks = [];\n    textures[fullPath] = texture;\n    return texture;\n  }\n\n  _getRotatedImage(image) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const width = image.width;\n    const height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    context.clearRect(0, 0, width, height);\n    context.translate(width / 2.0, height / 2.0);\n    context.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0\n\n    context.translate(-width / 2.0, -height / 2.0);\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, width, height);\n  } // Check if the partial image area used by the texture is transparent.\n\n\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      // Is there any efficient ways?\n      function createImageData(image) {\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n      }\n\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width;\n        const height = image.height;\n        const data = image.data;\n        const threshold = 253;\n        if (data.length / (width * height) !== 4) return false;\n\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = {\n            x: 0.0,\n            y: 0.0\n          };\n\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j];\n            const uv = {\n              x: uvs[index * 2 + 0],\n              y: uvs[index * 2 + 1]\n            };\n            if (getAlphaByUv(image, uv) < threshold) return true;\n            centerUV.x += uv.x;\n            centerUV.y += uv.y;\n          }\n\n          centerUV.x /= 3;\n          centerUV.y /= 3;\n          if (getAlphaByUv(image, centerUV) < threshold) return true;\n        }\n\n        return false;\n      }\n      /*\n       * This method expects\n       *   texture.flipY = false\n       *   texture.wrapS = RepeatWrapping\n       *   texture.wrapT = RepeatWrapping\n       * TODO: more precise\n       */\n\n\n      function getAlphaByUv(image, uv) {\n        const width = image.width;\n        const height = image.height;\n        let x = Math.round(uv.x * width) % width;\n        let y = Math.round(uv.y * height) % height;\n        if (x < 0) x += width;\n        if (y < 0) y += height;\n        const index = y * width + x;\n        return image.data[index * 4 + 3];\n      }\n\n      const imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image);\n      const group = geometry.groups[groupIndex];\n\n      if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n        map.transparent = true;\n      }\n    });\n  }\n\n} //\n\n\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    // combine skeletal and morph animations\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i]);\n    }\n\n    return new AnimationClip('', -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n\n\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127); // x1\n\n      array.push(interpolation[index + 8] / 127); // x2\n\n      array.push(interpolation[index + 4] / 127); // y1\n\n      array.push(interpolation[index + 12] / 127); // y2\n    }\n\n    const tracks = [];\n    const motions = {};\n    const bones = mesh.skeleton.bones;\n    const boneNameDictionary = {};\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true;\n    }\n\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i];\n      const boneName = motion.boneName;\n      if (boneNameDictionary[boneName] === undefined) continue;\n      motions[boneName] = motions[boneName] || [];\n      motions[boneName].push(motion);\n    }\n\n    for (const key in motions) {\n      const array = motions[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const positions = [];\n      const rotations = [];\n      const pInterpolations = [];\n      const rInterpolations = [];\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30;\n        const position = array[i].position;\n        const rotation = array[i].rotation;\n        const interpolation = array[i].interpolation;\n        times.push(time);\n\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j]);\n\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j);\n\n        pushInterpolation(rInterpolations, interpolation, 3);\n      }\n\n      const targetName = '.bones[' + key + ']';\n      tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations));\n    }\n\n    return new AnimationClip('', -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n\n\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = [];\n    const morphs = {};\n    const morphTargetDictionary = mesh.morphTargetDictionary;\n\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i];\n      const morphName = morph.morphName;\n      if (morphTargetDictionary[morphName] === undefined) continue;\n      morphs[morphName] = morphs[morphName] || [];\n      morphs[morphName].push(morph);\n    }\n\n    for (const key in morphs) {\n      const array = morphs[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const values = [];\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30);\n        values.push(array[i].weight);\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values));\n    }\n\n    return new AnimationClip('', -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n\n\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x);\n      array.push(vec.y);\n      array.push(vec.z);\n    }\n\n    function pushQuaternion(array, q) {\n      array.push(q.x);\n      array.push(q.y);\n      array.push(q.z);\n      array.push(q.w);\n    }\n\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127); // x1\n\n      array.push(interpolation[index * 4 + 1] / 127); // x2\n\n      array.push(interpolation[index * 4 + 2] / 127); // y1\n\n      array.push(interpolation[index * 4 + 3] / 127); // y2\n    }\n\n    const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum;\n    });\n    const times = [];\n    const centers = [];\n    const quaternions = [];\n    const positions = [];\n    const fovs = [];\n    const cInterpolations = [];\n    const qInterpolations = [];\n    const pInterpolations = [];\n    const fInterpolations = [];\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const position = new Vector3();\n    const center = new Vector3();\n\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i];\n      const time = motion.frameNum / 30;\n      const pos = motion.position;\n      const rot = motion.rotation;\n      const distance = motion.distance;\n      const fov = motion.fov;\n      const interpolation = motion.interpolation;\n      times.push(time);\n      position.set(0, 0, -distance);\n      center.set(pos[0], pos[1], pos[2]);\n      euler.set(-rot[0], -rot[1], -rot[2]);\n      quaternion.setFromEuler(euler);\n      position.add(center);\n      position.applyQuaternion(quaternion);\n      pushVector3(centers, center);\n      pushQuaternion(quaternions, quaternion);\n      pushVector3(positions, position);\n      fovs.push(fov);\n\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j);\n      }\n\n      pushInterpolation(qInterpolations, interpolation, 3); // use the same parameter for x, y, z axis.\n\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4);\n      }\n\n      pushInterpolation(fInterpolations, interpolation, 5);\n    }\n\n    const tracks = []; // I expect an object whose name 'target' exists under THREE.Camera\n\n    tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations));\n    tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n    tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations));\n    tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations));\n    return new AnimationClip('', -1, tracks);\n  } // private method\n\n\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    /*\n     * optimizes here not to let KeyframeTrackPrototype optimize\n     * because KeyframeTrackPrototype optimizes times and values but\n     * doesn't optimize interpolations.\n     */\n    if (times.length > 2) {\n      times = times.slice();\n      values = values.slice();\n      interpolations = interpolations.slice();\n      const stride = values.length / times.length;\n      const interpolateStride = interpolations.length / times.length;\n      let index = 1;\n\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n            index++;\n            break;\n          }\n        }\n\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex];\n\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i];\n          }\n\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n          }\n        }\n      }\n\n      times.length = index + 1;\n      values.length = (index + 1) * stride;\n      interpolations.length = (index + 1) * interpolateStride;\n    }\n\n    const track = new typedKeyframeTrack(node, times, values);\n\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n    };\n\n    return track;\n  }\n\n} // interpolation\n\n\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const params = this.interpolationParams;\n    const offset1 = i1 * stride;\n    const offset0 = offset1 - stride; // No interpolation if next key frame is in one frame in 30fps.\n    // This is from MMD animation spec.\n    // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n\n    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);\n\n    if (stride === 4) {\n      // Quaternion\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n    } else if (stride === 3) {\n      // Vector3\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0];\n        const x2 = params[i1 * 12 + i * 4 + 1];\n        const y1 = params[i1 * 12 + i * 4 + 2];\n        const y2 = params[i1 * 12 + i * 4 + 3];\n\n        const ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n      }\n    } else {\n      // Number\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n    }\n\n    return result;\n  }\n\n  _calculate(x1, x2, y1, y2, x) {\n    /*\n     * Cubic Bezier curves\n     *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n     *\n     * B(t) = ( 1 - t ) ^ 3 * P0\n     *      + 3 * ( 1 - t ) ^ 2 * t * P1\n     *      + 3 * ( 1 - t ) * t^2 * P2\n     *      + t ^ 3 * P3\n     *      ( 0 <= t <= 1 )\n     *\n     * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n     *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n     *\n     *    x = ( 1 - t ) ^ 3 * x0\n     *      + 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 * x3\n     *    y = ( 1 - t ) ^ 3 * y0\n     *      + 3 * ( 1 - t ) ^ 2 * t * y1\n     *      + 3 * ( 1 - t ) * t^2 * y2\n     *      + t ^ 3 * y3\n     *      ( x0 = 0, y0 = 0 )\n     *      ( x3 = 1, y3 = 1 )\n     *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n     *\n     * Here solves this equation with Bisection method,\n     *   https://en.wikipedia.org/wiki/Bisection_method\n     * gets t, and then calculate y.\n     *\n     * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 - x = 0\n     *\n     * (Another option: Newton's method\n     *    https://en.wikipedia.org/wiki/Newton%27s_method)\n     */\n    let c = 0.5;\n    let t = c;\n    let s = 1.0 - t;\n    const loop = 15;\n    const eps = 1e-5;\n    const math = Math;\n    let sst3, stt3, ttt;\n\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3.0 * s * s * t;\n      stt3 = 3.0 * s * t * t;\n      ttt = t * t * t;\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x;\n      if (math.abs(ft) < eps) break;\n      c /= 2.0;\n      t += ft < 0 ? c : -c;\n      s = 1.0 - t;\n    }\n\n    return sst3 * y1 + stt3 * y2 + ttt;\n  }\n\n}\n\nexport { MMDLoader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/loaders/MMDLoader.js"],"names":["Loader","FileLoader","LoaderUtils","SkinnedMesh","Skeleton","Bone","Vector3","Float32BufferAttribute","BufferGeometry","Uint16BufferAttribute","TextureLoader","Color","MultiplyOperation","AddOperation","MeshToonMaterial","NearestFilter","RepeatWrapping","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","NumberKeyframeTrack","Quaternion","Euler","Interpolant","CustomBlending","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","DoubleSide","FrontSide","TGALoader","Parser","MMDLoader","constructor","manager","loader","parser","meshBuilder","MeshBuilder","animationBuilder","AnimationBuilder","setAnimationPath","animationPath","load","url","onLoad","onProgress","onError","builder","setCrossOrigin","crossOrigin","resourcePath","path","extractUrlBase","modelExtension","_extractExtension","toLowerCase","Error","data","build","loadAnimation","object","loadVMD","vmd","isCamera","buildCameraAnimation","loadWithAnimation","modelUrl","vmdUrl","scope","mesh","animation","loadPMD","_getParser","setMimeType","undefined","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parsePmd","loadPMX","parsePmx","urls","Array","isArray","vmds","vmdNum","length","i","il","push","parseVmd","mergeVmds","loadVPD","isUnicode","text","parseVpd","index","lastIndexOf","slice","DEFAULT_TOON_TEXTURES","geometryBuilder","GeometryBuilder","materialBuilder","MaterialBuilder","geometry","material","setResourcePath","skeleton","initBones","bind","bones","gbone","bone","name","position","fromArray","pos","quaternion","rotq","scl","scale","parent","add","updateMatrixWorld","positions","uvs","normals","indices","groups","skinIndices","skinWeights","morphTargets","morphPositions","iks","grants","rigidBodies","constraints","offset","boneTypeTable","metadata","vertexCount","v","vertices","j","jl","normal","uv","faceCount","face","faces","materialCount","materials","count","rigidBodyCount","body","value","boneIndex","type","Math","max","boneCount","boneData","transformationClass","parentIndex","rigidBodyType","format","ikCount","ik","param","target","effector","iteration","maxAngle","links","link","enabled","indexOf","limitation","angleLimitation","rotationMin","lowerLimitationAngle","rotationMax","upperLimitationAngle","tmp1","tmp2","grantEntryMap","grant","ratio","isLocal","affectRotation","affectPosition","children","visited","rootEntry","grantEntry","parentGrantEntry","traverse","entry","child","updateAttributes","attribute","morph","elementCount","element","elements","morphs","array","morphCount","params","morph2","rigidBody","key","constraintCount","constraint","bodyA","rigidBodyIndex1","bodyB","rigidBodyIndex2","setAttribute","setIndex","addGroup","morphAttributes","morphTargetsRelative","userData","MMD","computeBoundingSphere","textureLoader","tgaLoader","textures","color","diffuse","opacity","emissive","ambient","transparent","skinning","fog","blending","blendSrc","blendDst","blendSrcAlpha","blendDstAlpha","flag","side","fileName","fileNames","split","map","_loadTexture","extension","envMap","combine","toonFileName","toonIndex","toonTextures","gradientMap","isToonTexture","isDefaultToonTexture","_isDefaultToonTexture","outlineParameters","thickness","edgeFlag","alpha","visible","textureIndex","envTextureIndex","envFlag","isDefaultToon","toonFlag","edgeSize","edgeColor","_checkImageTransparency","multiplyScalar","checkAlphaMorph","_getTGALoader","test","filePath","fullPath","parseInt","match","e","console","warn","getHandler","texture","t","image","_getRotatedImage","magFilter","minFilter","flipY","wrapS","wrapT","readyCallbacks","canvas","document","createElement","context","getContext","width","height","clearRect","translate","rotate","PI","drawImage","getImageData","groupIndex","createImageData","detectImageTransparency","threshold","centerUV","x","y","getAlphaByUv","round","imageData","group","attributes","start","tracks","buildSkeletalAnimation","tracks2","buildMorphAnimation","pushInterpolation","interpolation","motions","boneNameDictionary","motionCount","motion","boneName","sort","a","b","frameNum","times","rotations","pInterpolations","rInterpolations","basePosition","getBoneByName","toArray","time","rotation","targetName","_createTrack","morphTargetDictionary","morphName","values","weight","pushVector3","vec","z","pushQuaternion","q","w","cameras","centers","quaternions","fovs","cInterpolations","qInterpolations","fInterpolations","euler","center","rot","distance","fov","set","setFromEuler","applyQuaternion","node","typedKeyframeTrack","interpolations","stride","interpolateStride","aheadIndex","endIndex","track","createInterpolant","InterpolantFactoryMethodCubicBezier","result","CubicBezierInterpolation","getValueSize","Float32Array","parameterPositions","sampleValues","sampleSize","resultBuffer","interpolationParams","interpolate_","i1","t0","t1","valueSize","offset1","offset0","weight1","x1","x2","y1","y2","_calculate","slerpFlat","c","s","loop","eps","math","sst3","stt3","ttt","ft","abs"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide } from 'three';\nimport { TGALoader } from './TGALoader.js';\nimport { Parser } from 'mmd-parser';\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\n/**\n * @param {THREE.LoadingManager} manager\n */\n\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.loader = new FileLoader(this.manager);\n    this.parser = null; // lazy generation\n\n    this.meshBuilder = new MeshBuilder(this.manager);\n    this.animationBuilder = new AnimationBuilder();\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n\n\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath;\n    return this;\n  } // Load MMD assets as Three.js Object\n\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin); // resource path\n\n    let resourcePath;\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== '') {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n\n    const modelExtension = this._extractExtension(url).toLowerCase(); // Should I detect by seeing header?\n\n\n    if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n      if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'));\n      return;\n    }\n\n    this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](url, function (data) {\n      onLoad(builder.build(data, resourcePath, onProgress, onError));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder;\n    this.loadVMD(url, function (vmd) {\n      onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this;\n    this.load(modelUrl, function (mesh) {\n      scope.loadAnimation(vmdUrl, mesh, function (animation) {\n        onLoad({\n          mesh: mesh,\n          animation: animation\n        });\n      }, onProgress, onError);\n    }, onProgress, onError);\n  } // Load MMD assets as Object data parsed by MMDParser\n\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n\n    this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmd(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n\n    this.loader.setMimeType(undefined).setPath(this.path).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n      onLoad(parser.parsePmx(buffer, true));\n    }, onProgress, onError);\n  }\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url];\n    const vmds = [];\n    const vmdNum = urls.length;\n\n    const parser = this._getParser();\n\n    this.loader.setMimeType(undefined).setPath(this.animationPath).setResponseType('arraybuffer').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(urls[i], function (buffer) {\n        vmds.push(parser.parseVmd(buffer, true));\n        if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n      }, onProgress, onError);\n    }\n  }\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n\n\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser();\n\n    this.loader.setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis').setPath(this.animationPath).setResponseType('text').setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n      onLoad(parser.parseVpd(text, true));\n    }, onProgress, onError);\n  } // private methods\n\n\n  _extractExtension(url) {\n    const index = url.lastIndexOf('.');\n    return index < 0 ? '' : url.slice(index + 1);\n  }\n\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser(); // eslint-disable-line no-undef\n    }\n\n    return this.parser;\n  }\n\n} // Utilities\n\n/*\n * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n * We don't need to request external toon image files.\n * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n */\n\n\nconst DEFAULT_TOON_TEXTURES = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=']; // Builders. They build Three.js object from Object data parsed by MMDParser.\n\n/**\n * @param {THREE.LoadingManager} manager\n */\n\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = 'anonymous';\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n\n\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n\n\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data);\n    const material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n    const mesh = new SkinnedMesh(geometry, material);\n    const skeleton = new Skeleton(initBones(mesh));\n    mesh.bind(skeleton); // console.log( mesh ); // for console debug\n\n    return mesh;\n  }\n\n} // TODO: Try to remove this function\n\n\nfunction initBones(mesh) {\n  const geometry = mesh.geometry;\n  const bones = [];\n\n  if (geometry && geometry.bones !== undefined) {\n    // first, create array of 'Bone' objects from geometry data\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]; // create new 'Bone' object\n\n      const bone = new Bone();\n      bones.push(bone); // apply values\n\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\n    } // second, create bone hierarchy\n\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i];\n\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n        // subsequent bones in the hierarchy\n        bones[gbone.parent].add(bones[i]);\n      } else {\n        // topmost bone, immediate child of the skinned mesh\n        mesh.add(bones[i]);\n      }\n    }\n  } // now the bones are part of the scene graph and children of the skinned mesh.\n  // let's update the corresponding matrices\n\n\n  mesh.updateMatrixWorld(true);\n  return bones;\n} //\n\n\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    // for geometry\n    const positions = [];\n    const uvs = [];\n    const normals = [];\n    const indices = [];\n    const groups = [];\n    const bones = [];\n    const skinIndices = [];\n    const skinWeights = [];\n    const morphTargets = [];\n    const morphPositions = [];\n    const iks = [];\n    const grants = [];\n    const rigidBodies = [];\n    const constraints = []; // for work\n\n    let offset = 0;\n    const boneTypeTable = {}; // positions, normals, uvs, skinIndices, skinWeights\n\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i];\n\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j]);\n      }\n\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j]);\n      }\n\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j]);\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);\n      }\n    } // indices\n\n\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i];\n\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j]);\n      }\n    } // groups\n\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3\n      });\n      offset += material.faceCount;\n    } // bones\n\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i];\n      let value = boneTypeTable[body.boneIndex]; // keeps greater number if already value is set without any special reasons\n\n      value = value === undefined ? body.type : Math.max(body.type, value);\n      boneTypeTable[body.boneIndex] = value;\n    }\n\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i];\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1\n      };\n\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0];\n        bone.pos[1] -= data.bones[bone.parent].position[1];\n        bone.pos[2] -= data.bones[bone.parent].position[2];\n      }\n\n      bones.push(bone);\n    } // iks\n    // TODO: remove duplicated codes between PMD and PMX\n\n\n    if (data.metadata.format === 'pmd') {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i];\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: []\n        };\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n\n          if (data.bones[link.index].name.indexOf('ひざ') >= 0) {\n            link.limitation = new Vector3(1.0, 0.0, 0.0);\n          }\n\n          param.links.push(link);\n        }\n\n        iks.push(param);\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik;\n        if (ik === undefined) continue;\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: []\n        };\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {};\n          link.index = ik.links[j].index;\n          link.enabled = true;\n\n          if (ik.links[j].angleLimitation === 1) {\n            // Revert if rotationMin/Max doesn't work well\n            // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n            const rotationMin = ik.links[j].lowerLimitationAngle;\n            const rotationMax = ik.links[j].upperLimitationAngle; // Convert Left to Right coordinate by myself because\n            // MMDParser doesn't convert. It's a MMDParser's bug\n\n            const tmp1 = -rotationMax[0];\n            const tmp2 = -rotationMax[1];\n            rotationMax[0] = -rotationMin[0];\n            rotationMax[1] = -rotationMin[1];\n            rotationMin[0] = tmp1;\n            rotationMin[1] = tmp2;\n            link.rotationMin = new Vector3().fromArray(rotationMin);\n            link.rotationMax = new Vector3().fromArray(rotationMax);\n          }\n\n          param.links.push(link);\n        }\n\n        iks.push(param); // Save the reference even from bone data for efficiently\n        // simulating PMX animation system\n\n        bones[i].ik = param;\n      }\n    } // grants\n\n\n    if (data.metadata.format === 'pmx') {\n      // bone index -> grant entry map\n      const grantEntryMap = {};\n\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i];\n        const grant = boneData.grant;\n        if (grant === undefined) continue;\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass\n        };\n        grantEntryMap[i] = {\n          parent: null,\n          children: [],\n          param: param,\n          visited: false\n        };\n      }\n\n      const rootEntry = {\n        parent: null,\n        children: [],\n        param: null,\n        visited: false\n      }; // Build a tree representing grant hierarchy\n\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex];\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n        grantEntry.parent = parentGrantEntry;\n        parentGrantEntry.children.push(grantEntry);\n      } // Sort grant parameters from parents to children because\n      // grant uses parent's transform that parent's grant is already applied\n      // so grant should be applied in order from parents to children\n\n\n      function traverse(entry) {\n        if (entry.param) {\n          grants.push(entry.param); // Save the reference even from bone data for efficiently\n          // simulating PMX animation system\n\n          bones[entry.param.index].grant = entry.param;\n        }\n\n        entry.visited = true;\n\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i]; // Cut off a loop if exists. (Is a grant loop invalid?)\n\n          if (!child.visited) traverse(child);\n        }\n      }\n\n      traverse(rootEntry);\n    } // morph\n\n\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i];\n        let index;\n\n        if (data.metadata.format === 'pmd') {\n          index = data.morphs[0].elements[element.index].index;\n        } else {\n          index = element.index;\n        }\n\n        attribute.array[index * 3 + 0] += element.position[0] * ratio;\n        attribute.array[index * 3 + 1] += element.position[1] * ratio;\n        attribute.array[index * 3 + 2] += element.position[2] * ratio;\n      }\n    }\n\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i];\n      const params = {\n        name: morph.name\n      };\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n      attribute.name = morph.name;\n\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j];\n      }\n\n      if (data.metadata.format === 'pmd') {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1.0);\n        }\n      } else {\n        if (morph.type === 0) {\n          // group\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index];\n            const ratio = morph.elements[j].ratio;\n\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio);\n            }\n          }\n        } else if (morph.type === 1) {\n          // vertex\n          updateAttributes(attribute, morph, 1.0);\n        } else if (morph.type === 2) ; else if (morph.type === 3) ; else if (morph.type === 4) ; else if (morph.type === 5) ; else if (morph.type === 6) ; else if (morph.type === 7) ; else if (morph.type === 8) ;\n      }\n\n      morphTargets.push(params);\n      morphPositions.push(attribute);\n    } // rigid bodies from rigidBodies field.\n\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i];\n      const params = {};\n\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key];\n      }\n      /*\n       * RigidBody position parameter in PMX seems global position\n       * while the one in PMD seems offset from corresponding bone.\n       * So unify being offset.\n       */\n\n\n      if (data.metadata.format === 'pmx') {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex];\n          params.position[0] -= bone.position[0];\n          params.position[1] -= bone.position[1];\n          params.position[2] -= bone.position[2];\n        }\n      }\n\n      rigidBodies.push(params);\n    } // constraints from constraints field.\n\n\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i];\n      const params = {};\n\n      for (const key in constraint) {\n        params[key] = constraint[key];\n      }\n\n      const bodyA = rigidBodies[params.rigidBodyIndex1];\n      const bodyB = rigidBodies[params.rigidBodyIndex2]; // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n          bodyB.type = 1;\n        }\n      }\n\n      constraints.push(params);\n    } // build BufferGeometry.\n\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4));\n    geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4));\n    geometry.setIndex(indices);\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i);\n    }\n\n    geometry.bones = bones;\n    geometry.morphTargets = morphTargets;\n    geometry.morphAttributes.position = morphPositions;\n    geometry.morphTargetsRelative = false;\n    geometry.userData.MMD = {\n      bones: bones,\n      iks: iks,\n      grants: grants,\n      rigidBodies: rigidBodies,\n      constraints: constraints,\n      format: data.metadata.format\n    };\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n\n} //\n\n/**\n * @param {THREE.LoadingManager} manager\n */\n\n\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null; // lazy generation\n\n    this.crossOrigin = 'anonymous';\n    this.resourcePath = undefined;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n\n\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n\n\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n\n\n  build(data, geometry\n  /*, onProgress, onError */\n  ) {\n    const materials = [];\n    const textures = {};\n    this.textureLoader.setCrossOrigin(this.crossOrigin); // materials\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i];\n      const params = {\n        userData: {}\n      };\n      if (material.name !== undefined) params.name = material.name;\n      /*\n       * Color\n       *\n       * MMD         MeshToonMaterial\n       * diffuse  -  color\n       * ambient  -  emissive * a\n       *               (a = 1.0 without map texture or 0.2 with map texture)\n       *\n       * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n       * It'll be too bright if material has map texture so using coef 0.2.\n       */\n\n      params.color = new Color().fromArray(material.diffuse);\n      params.opacity = material.diffuse[3];\n      params.emissive = new Color().fromArray(material.ambient);\n      params.transparent = params.opacity !== 1.0; //\n\n      params.skinning = geometry.bones.length > 0 ? true : false;\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n      params.fog = true; // blend\n\n      params.blending = CustomBlending;\n      params.blendSrc = SrcAlphaFactor;\n      params.blendDst = OneMinusSrcAlphaFactor;\n      params.blendSrcAlpha = SrcAlphaFactor;\n      params.blendDstAlpha = DstAlphaFactor; // side\n\n      if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n        params.side = DoubleSide;\n      } else {\n        params.side = params.opacity === 1.0 ? FrontSide : DoubleSide;\n      }\n\n      if (data.metadata.format === 'pmd') {\n        // map, envMap\n        if (material.fileName) {\n          const fileName = material.fileName;\n          const fileNames = fileName.split('*'); // fileNames[ 0 ]: mapFileName\n          // fileNames[ 1 ]: envMapFileName( optional )\n\n          params.map = this._loadTexture(fileNames[0], textures);\n\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase();\n            params.envMap = this._loadTexture(fileNames[1], textures);\n            params.combine = extension === '.sph' ? MultiplyOperation : AddOperation;\n          }\n        } // gradientMap\n\n\n        const toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName;\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n        }); // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n          color: [0, 0, 0],\n          alpha: 1.0,\n          visible: material.edgeFlag === 1\n        };\n      } else {\n        // map\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n        } // envMap TODO: support m.envFlag === 3\n\n\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n        } // gradientMap\n\n\n        let toonFileName, isDefaultToon;\n\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp';\n          isDefaultToon = true;\n        } else {\n          toonFileName = data.textures[material.toonIndex];\n          isDefaultToon = false;\n        }\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon\n        }); // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300,\n          // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0\n        };\n      }\n\n      if (params.map !== undefined) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i);\n        }\n\n        params.emissive.multiplyScalar(0.2);\n      }\n\n      materials.push(new MeshToonMaterial(params));\n    }\n\n    if (data.metadata.format === 'pmx') {\n      // set transparent true if alpha morph is defined.\n      function checkAlphaMorph(elements, materials) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i];\n          if (element.index === -1) continue;\n          const material = materials[element.index];\n\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true;\n          }\n        }\n      }\n\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i];\n        const elements = morph.elements;\n\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index];\n            if (morph2.type !== 8) continue;\n            checkAlphaMorph(morph2.elements, materials);\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials);\n        }\n      }\n    }\n\n    return materials;\n  } // private methods\n\n\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === undefined) {\n        throw new Error('THREE.MMDLoader: Import TGALoader');\n      }\n\n      this.tgaLoader = new TGALoader(this.manager);\n    }\n\n    return this.tgaLoader;\n  }\n\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false;\n    return /toon(10|0[0-9])\\.bmp/.test(name);\n  }\n\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {};\n    const scope = this;\n    let fullPath;\n\n    if (params.isDefaultToonTexture === true) {\n      let index;\n\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n      } catch (e) {\n        console.warn('THREE.MMDLoader: ' + filePath + ' seems like a ' + 'not right default texture path. Using toon00.bmp instead.');\n        index = 0;\n      }\n\n      fullPath = DEFAULT_TOON_TEXTURES[index];\n    } else {\n      fullPath = this.resourcePath + filePath;\n    }\n\n    if (textures[fullPath] !== undefined) return textures[fullPath];\n    let loader = this.manager.getHandler(fullPath);\n\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader;\n    }\n\n    const texture = loader.load(fullPath, function (t) {\n      // MMD toon texture is Axis-Y oriented\n      // but Three.js gradient map is Axis-X oriented.\n      // So here replaces the toon texture image with the rotated one.\n      if (params.isToonTexture === true) {\n        t.image = scope._getRotatedImage(t.image);\n        t.magFilter = NearestFilter;\n        t.minFilter = NearestFilter;\n      }\n\n      t.flipY = false;\n      t.wrapS = RepeatWrapping;\n      t.wrapT = RepeatWrapping;\n\n      for (let i = 0; i < texture.readyCallbacks.length; i++) {\n        texture.readyCallbacks[i](texture);\n      }\n\n      delete texture.readyCallbacks;\n    }, onProgress, onError);\n    texture.readyCallbacks = [];\n    textures[fullPath] = texture;\n    return texture;\n  }\n\n  _getRotatedImage(image) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const width = image.width;\n    const height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    context.clearRect(0, 0, width, height);\n    context.translate(width / 2.0, height / 2.0);\n    context.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0\n\n    context.translate(-width / 2.0, -height / 2.0);\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, width, height);\n  } // Check if the partial image area used by the texture is transparent.\n\n\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      // Is there any efficient ways?\n      function createImageData(image) {\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, canvas.width, canvas.height);\n      }\n\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width;\n        const height = image.height;\n        const data = image.data;\n        const threshold = 253;\n        if (data.length / (width * height) !== 4) return false;\n\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = {\n            x: 0.0,\n            y: 0.0\n          };\n\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j];\n            const uv = {\n              x: uvs[index * 2 + 0],\n              y: uvs[index * 2 + 1]\n            };\n            if (getAlphaByUv(image, uv) < threshold) return true;\n            centerUV.x += uv.x;\n            centerUV.y += uv.y;\n          }\n\n          centerUV.x /= 3;\n          centerUV.y /= 3;\n          if (getAlphaByUv(image, centerUV) < threshold) return true;\n        }\n\n        return false;\n      }\n      /*\n       * This method expects\n       *   texture.flipY = false\n       *   texture.wrapS = RepeatWrapping\n       *   texture.wrapT = RepeatWrapping\n       * TODO: more precise\n       */\n\n\n      function getAlphaByUv(image, uv) {\n        const width = image.width;\n        const height = image.height;\n        let x = Math.round(uv.x * width) % width;\n        let y = Math.round(uv.y * height) % height;\n        if (x < 0) x += width;\n        if (y < 0) y += height;\n        const index = y * width + x;\n        return image.data[index * 4 + 3];\n      }\n\n      const imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image);\n      const group = geometry.groups[groupIndex];\n\n      if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n        map.transparent = true;\n      }\n    });\n  }\n\n} //\n\n\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    // combine skeletal and morph animations\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i]);\n    }\n\n    return new AnimationClip('', -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n\n\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127); // x1\n\n      array.push(interpolation[index + 8] / 127); // x2\n\n      array.push(interpolation[index + 4] / 127); // y1\n\n      array.push(interpolation[index + 12] / 127); // y2\n    }\n\n    const tracks = [];\n    const motions = {};\n    const bones = mesh.skeleton.bones;\n    const boneNameDictionary = {};\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true;\n    }\n\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i];\n      const boneName = motion.boneName;\n      if (boneNameDictionary[boneName] === undefined) continue;\n      motions[boneName] = motions[boneName] || [];\n      motions[boneName].push(motion);\n    }\n\n    for (const key in motions) {\n      const array = motions[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const positions = [];\n      const rotations = [];\n      const pInterpolations = [];\n      const rInterpolations = [];\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30;\n        const position = array[i].position;\n        const rotation = array[i].rotation;\n        const interpolation = array[i].interpolation;\n        times.push(time);\n\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j]);\n\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j);\n\n        pushInterpolation(rInterpolations, interpolation, 3);\n      }\n\n      const targetName = '.bones[' + key + ']';\n      tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations));\n    }\n\n    return new AnimationClip('', -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n\n\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = [];\n    const morphs = {};\n    const morphTargetDictionary = mesh.morphTargetDictionary;\n\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i];\n      const morphName = morph.morphName;\n      if (morphTargetDictionary[morphName] === undefined) continue;\n      morphs[morphName] = morphs[morphName] || [];\n      morphs[morphName].push(morph);\n    }\n\n    for (const key in morphs) {\n      const array = morphs[key];\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      const times = [];\n      const values = [];\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30);\n        values.push(array[i].weight);\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values));\n    }\n\n    return new AnimationClip('', -1, tracks);\n  }\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n\n\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x);\n      array.push(vec.y);\n      array.push(vec.z);\n    }\n\n    function pushQuaternion(array, q) {\n      array.push(q.x);\n      array.push(q.y);\n      array.push(q.z);\n      array.push(q.w);\n    }\n\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127); // x1\n\n      array.push(interpolation[index * 4 + 1] / 127); // x2\n\n      array.push(interpolation[index * 4 + 2] / 127); // y1\n\n      array.push(interpolation[index * 4 + 3] / 127); // y2\n    }\n\n    const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum;\n    });\n    const times = [];\n    const centers = [];\n    const quaternions = [];\n    const positions = [];\n    const fovs = [];\n    const cInterpolations = [];\n    const qInterpolations = [];\n    const pInterpolations = [];\n    const fInterpolations = [];\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const position = new Vector3();\n    const center = new Vector3();\n\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i];\n      const time = motion.frameNum / 30;\n      const pos = motion.position;\n      const rot = motion.rotation;\n      const distance = motion.distance;\n      const fov = motion.fov;\n      const interpolation = motion.interpolation;\n      times.push(time);\n      position.set(0, 0, -distance);\n      center.set(pos[0], pos[1], pos[2]);\n      euler.set(-rot[0], -rot[1], -rot[2]);\n      quaternion.setFromEuler(euler);\n      position.add(center);\n      position.applyQuaternion(quaternion);\n      pushVector3(centers, center);\n      pushQuaternion(quaternions, quaternion);\n      pushVector3(positions, position);\n      fovs.push(fov);\n\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j);\n      }\n\n      pushInterpolation(qInterpolations, interpolation, 3); // use the same parameter for x, y, z axis.\n\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4);\n      }\n\n      pushInterpolation(fInterpolations, interpolation, 5);\n    }\n\n    const tracks = []; // I expect an object whose name 'target' exists under THREE.Camera\n\n    tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations));\n    tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n    tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations));\n    tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations));\n    return new AnimationClip('', -1, tracks);\n  } // private method\n\n\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    /*\n     * optimizes here not to let KeyframeTrackPrototype optimize\n     * because KeyframeTrackPrototype optimizes times and values but\n     * doesn't optimize interpolations.\n     */\n    if (times.length > 2) {\n      times = times.slice();\n      values = values.slice();\n      interpolations = interpolations.slice();\n      const stride = values.length / times.length;\n      const interpolateStride = interpolations.length / times.length;\n      let index = 1;\n\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n            index++;\n            break;\n          }\n        }\n\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex];\n\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i];\n          }\n\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n          }\n        }\n      }\n\n      times.length = index + 1;\n      values.length = (index + 1) * stride;\n      interpolations.length = (index + 1) * interpolateStride;\n    }\n\n    const track = new typedKeyframeTrack(node, times, values);\n\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n    };\n\n    return track;\n  }\n\n} // interpolation\n\n\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this.interpolationParams = params;\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const params = this.interpolationParams;\n    const offset1 = i1 * stride;\n    const offset0 = offset1 - stride; // No interpolation if next key frame is in one frame in 30fps.\n    // This is from MMD animation spec.\n    // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n\n    const weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);\n\n    if (stride === 4) {\n      // Quaternion\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n    } else if (stride === 3) {\n      // Vector3\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0];\n        const x2 = params[i1 * 12 + i * 4 + 1];\n        const y1 = params[i1 * 12 + i * 4 + 2];\n        const y2 = params[i1 * 12 + i * 4 + 3];\n\n        const ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n      }\n    } else {\n      // Number\n      const x1 = params[i1 * 4 + 0];\n      const x2 = params[i1 * 4 + 1];\n      const y1 = params[i1 * 4 + 2];\n      const y2 = params[i1 * 4 + 3];\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n    }\n\n    return result;\n  }\n\n  _calculate(x1, x2, y1, y2, x) {\n    /*\n     * Cubic Bezier curves\n     *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n     *\n     * B(t) = ( 1 - t ) ^ 3 * P0\n     *      + 3 * ( 1 - t ) ^ 2 * t * P1\n     *      + 3 * ( 1 - t ) * t^2 * P2\n     *      + t ^ 3 * P3\n     *      ( 0 <= t <= 1 )\n     *\n     * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n     *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n     *\n     *    x = ( 1 - t ) ^ 3 * x0\n     *      + 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 * x3\n     *    y = ( 1 - t ) ^ 3 * y0\n     *      + 3 * ( 1 - t ) ^ 2 * t * y1\n     *      + 3 * ( 1 - t ) * t^2 * y2\n     *      + t ^ 3 * y3\n     *      ( x0 = 0, y0 = 0 )\n     *      ( x3 = 1, y3 = 1 )\n     *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n     *\n     * Here solves this equation with Bisection method,\n     *   https://en.wikipedia.org/wiki/Bisection_method\n     * gets t, and then calculate y.\n     *\n     * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 - x = 0\n     *\n     * (Another option: Newton's method\n     *    https://en.wikipedia.org/wiki/Newton%27s_method)\n     */\n    let c = 0.5;\n    let t = c;\n    let s = 1.0 - t;\n    const loop = 15;\n    const eps = 1e-5;\n    const math = Math;\n    let sst3, stt3, ttt;\n\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3.0 * s * s * t;\n      stt3 = 3.0 * s * t * t;\n      ttt = t * t * t;\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x;\n      if (math.abs(ft) < eps) break;\n      c /= 2.0;\n      t += ft < 0 ? c : -c;\n      s = 1.0 - t;\n    }\n\n    return sst3 * y1 + stt3 * y2 + ttt;\n  }\n\n}\n\nexport { MMDLoader };\n"]},"metadata":{},"sourceType":"module"}