{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial, Color } from 'three';\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(this, \"isLineMaterial\", true);\n\n    _defineProperty(this, \"dashed\", false);\n\n    _defineProperty(this, \"color\", new Color(0x000000));\n\n    _defineProperty(this, \"lineWidth\", 0);\n\n    _defineProperty(this, \"dashScale\", 0);\n\n    _defineProperty(this, \"dashOffset\", 0);\n\n    _defineProperty(this, \"dashSize\", 0);\n\n    _defineProperty(this, \"opacity\", 0);\n\n    _defineProperty(this, \"resolution\", new Vector2());\n\n    _defineProperty(this, \"alphaToCoverage\", false);\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          const colorObj = new Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/lines/LineMaterial.js"],"names":["_defineProperty","Vector2","ShaderLib","UniformsUtils","UniformsLib","ShaderMaterial","Color","LineUniforms","linewidth","value","resolution","dashScale","dashSize","dashOffset","gapSize","opacity","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","constructor","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","colorObj","getHex","copy","alphaToCoverage","Boolean","defines","needsUpdate","ALPHA_TO_COVERAGE","extensions","derivatives","dashed","USE_DASH","setValues"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,SAASC,OAAT,EAAkBC,SAAlB,EAA6BC,aAA7B,EAA4CC,WAA5C,EAAyDC,cAAzD,EAAyEC,KAAzE,QAAsF,OAAtF;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,SAAS,EAAE;AACTC,IAAAA,KAAK,EAAE;AADE,GADQ;AAInBC,EAAAA,UAAU,EAAE;AACVD,IAAAA,KAAK,EAAE,IAAIR,OAAJ,CAAY,CAAZ,EAAe,CAAf;AADG,GAJO;AAOnBU,EAAAA,SAAS,EAAE;AACTF,IAAAA,KAAK,EAAE;AADE,GAPQ;AAUnBG,EAAAA,QAAQ,EAAE;AACRH,IAAAA,KAAK,EAAE;AADC,GAVS;AAanBI,EAAAA,UAAU,EAAE;AACVJ,IAAAA,KAAK,EAAE;AADG,GAbO;AAgBnBK,EAAAA,OAAO,EAAE;AACPL,IAAAA,KAAK,EAAE;AADA,GAhBU;AAmBnB;AACAM,EAAAA,OAAO,EAAE;AACPN,IAAAA,KAAK,EAAE;AADA;AApBU,CAArB;AAwBAP,SAAS,CAAC,MAAD,CAAT,GAAoB;AAClBc,EAAAA,QAAQ,EAAEb,aAAa,CAACc,KAAd,CAAoB,CAACb,WAAW,CAACc,MAAb,EAAqBd,WAAW,CAACe,GAAjC,EAAsCZ,YAAtC,CAApB,CADQ;AAElBa,EAAAA,YAAY;AACZ;AACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GApJoB;AAqJlBC,EAAAA,cAAc;AACd;AACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApOoB,CAApB;;AAuOA,MAAMC,YAAN,SAA2BjB,cAA3B,CAA0C;AACxCkB,EAAAA,WAAW,GAAkB;AAAA,QAAjBC,UAAiB,uEAAJ,EAAI;AAC3B,UAAM;AACJR,MAAAA,QAAQ,EAAEb,aAAa,CAACsB,KAAd,CAAoBvB,SAAS,CAAC,MAAD,CAAT,CAAkBc,QAAtC,CADN;AAEJI,MAAAA,YAAY,EAAElB,SAAS,CAAC,MAAD,CAAT,CAAkBkB,YAF5B;AAGJC,MAAAA,cAAc,EAAEnB,SAAS,CAAC,MAAD,CAAT,CAAkBmB,cAH9B;AAIJK,MAAAA,QAAQ,EAAE,IAJN,CAIW;;AAJX,KAAN;AAOA;AACJ;AACA;AACA;;AAEI1B,IAAAA,eAAe,CAAC,IAAD,EAAO,gBAAP,EAAyB,IAAzB,CAAf;;AAEAA,IA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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial, Color } from 'three';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters = {}) {\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(this, \"isLineMaterial\", true);\n\n    _defineProperty(this, \"dashed\", false);\n\n    _defineProperty(this, \"color\", new Color(0x000000));\n\n    _defineProperty(this, \"lineWidth\", 0);\n\n    _defineProperty(this, \"dashScale\", 0);\n\n    _defineProperty(this, \"dashOffset\", 0);\n\n    _defineProperty(this, \"dashSize\", 0);\n\n    _defineProperty(this, \"opacity\", 0);\n\n    _defineProperty(this, \"resolution\", new Vector2());\n\n    _defineProperty(this, \"alphaToCoverage\", false);\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          const colorObj = new Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };\n"]},"metadata":{},"sourceType":"module"}