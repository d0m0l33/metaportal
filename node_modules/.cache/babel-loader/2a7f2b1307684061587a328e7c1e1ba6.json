{"ast":null,"code":"/**\r\n * Lightweight thenable implementation that is entirely self-contained within a single\r\n * function with no external dependencies so it can be easily shipped across to a WorkerModule.\r\n *\r\n * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\r\n * with other thenable implementations. https://github.com/promises-aplus/promises-spec\r\n *\r\n * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\r\n * have the same constructor signature and does not expose a `catch` method or the static\r\n * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\r\n * instance off to consuming code that may expect a true Promise, you'll want to wrap it\r\n * in a native-or-polyfilled Promise first.\r\n *\r\n * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\r\n * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\r\n * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\r\n * implementation I've found. And also, exercises like this are challenging and fun.)\r\n */\nfunction BespokeThenable() {\n  var state = 0; // 0=pending, 1=fulfilled, -1=rejected\n\n  var queue = [];\n  var value;\n  var scheduled = 0;\n  var completeCalled = 0;\n\n  function then(onResolve, onReject) {\n    var nextThenable = BespokeThenable();\n\n    function handleNext() {\n      var cb = state > 0 ? onResolve : onReject;\n\n      if (isFn(cb)) {\n        try {\n          var result = cb(value);\n\n          if (result === nextThenable) {\n            recursiveError();\n          }\n\n          var resultThen = getThenableThen(result);\n\n          if (resultThen) {\n            resultThen.call(result, nextThenable.resolve, nextThenable.reject);\n          } else {\n            nextThenable.resolve(result);\n          }\n        } catch (err) {\n          nextThenable.reject(err);\n        }\n      } else {\n        nextThenable[state > 0 ? 'resolve' : 'reject'](value);\n      }\n    }\n\n    queue.push(handleNext);\n\n    if (state) {\n      scheduleQueueFlush();\n    }\n\n    return nextThenable;\n  }\n\n  var resolve = oneTime(function (val) {\n    if (!completeCalled) {\n      complete(1, val);\n    }\n  });\n  var reject = oneTime(function (reason) {\n    if (!completeCalled) {\n      complete(-1, reason);\n    }\n  });\n\n  function complete(st, val) {\n    completeCalled++;\n    var ignoreThrow = 0;\n\n    try {\n      if (val === thenableObj) {\n        recursiveError();\n      }\n\n      var valThen = st > 0 && getThenableThen(val);\n\n      if (valThen) {\n        valThen.call(val, oneTime(function (v) {\n          ignoreThrow++;\n          complete(1, v);\n        }), oneTime(function (v) {\n          ignoreThrow++;\n          complete(-1, v);\n        }));\n      } else {\n        state = st;\n        value = val;\n        scheduleQueueFlush();\n      }\n    } catch (e) {\n      if (!state && !ignoreThrow) {\n        complete(-1, e);\n      }\n    }\n  }\n\n  function scheduleQueueFlush() {\n    if (!scheduled) {\n      setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\n\n      scheduled = 1;\n    }\n  }\n\n  function flushQueue() {\n    var q = queue;\n    scheduled = 0;\n    queue = [];\n    q.forEach(callIt);\n  }\n\n  function callIt(fn) {\n    fn();\n  }\n\n  function getThenableThen(val) {\n    var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\n    return isFn(valThen) && valThen;\n  }\n\n  function oneTime(fn) {\n    var called = 0;\n    return function () {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      if (!called++) {\n        fn.apply(this, args);\n      }\n    };\n  }\n\n  function recursiveError() {\n    throw new TypeError('Chaining cycle detected');\n  }\n\n  var isFn = function (v) {\n    return typeof v === 'function';\n  };\n\n  var thenableObj = {\n    then: then,\n    resolve: resolve,\n    reject: reject\n  };\n  return thenableObj;\n}\n/**\r\n * Thenable implementation that uses a native Promise under the covers. This implementation\r\n * is preferred if Promise is available, for better performance and dev tools integration.\r\n * @constructor\r\n */\n\n\nfunction NativePromiseThenable() {\n  var resolve, reject;\n  var promise = new Promise(function (res, rej) {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    then: promise.then.bind(promise),\n    resolve: resolve,\n    reject: reject\n  };\n}\n/**\r\n * Promise.all() impl:\r\n */\n\n\nBespokeThenable.all = NativePromiseThenable.all = function (items) {\n  var resultCount = 0;\n  var results = [];\n  var out = DefaultThenable();\n\n  if (items.length === 0) {\n    out.resolve([]);\n  } else {\n    items.forEach(function (item, i) {\n      var itemThenable = DefaultThenable();\n      itemThenable.resolve(item);\n      itemThenable.then(function (res) {\n        resultCount++;\n        results[i] = res;\n\n        if (resultCount === items.length) {\n          out.resolve(results);\n        }\n      }, out.reject);\n    });\n  }\n\n  return out;\n};\n/**\r\n * Choose the best Thenable implementation and export it as the default.\r\n */\n\n\nvar DefaultThenable = typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable;\n/**\r\n * Main content for the worker that handles the loading and execution of\r\n * modules within it.\r\n */\n\nfunction workerBootstrap() {\n  var modules = Object.create(null); // Handle messages for registering a module\n\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies;\n    if (dependencies === void 0) dependencies = [];\n    var init = ref.init;\n    if (init === void 0) init = function () {};\n    var getTransferables = ref.getTransferables;\n    if (getTransferables === void 0) getTransferables = null; // Only register once\n\n    if (modules[id]) {\n      return;\n    }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) {\n              throw depResult;\n            }\n          });\n          dep = modules[dep.id].value;\n        }\n\n        return dep;\n      }); // Rehydrate functions\n\n      init = rehydrate(\"<\" + name + \">.init\", init);\n\n      if (getTransferables) {\n        getTransferables = rehydrate(\"<\" + name + \">.getTransferables\", getTransferables);\n      } // Initialize the module and store its value\n\n\n      var value = null;\n\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch (err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n\n      callback(err);\n    }\n  } // Handle messages for calling a registered module's result function\n\n\n  function callModule(ref, callback) {\n    var ref$1;\n    var id = ref.id;\n    var args = ref.args;\n\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error(\"Worker module \" + id + \": not found or its 'init' did not return a function\"));\n    }\n\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) {\n          return callback(rej instanceof Error ? rej : new Error('' + rej));\n        });\n      } else {\n        handleResult(result);\n      }\n    } catch (err) {\n      callback(err);\n    }\n\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n\n        callback(result, tx);\n      } catch (err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n\n    self.troikaDefine = function (r) {\n      return result = r;\n    };\n\n    var url = URL.createObjectURL(new Blob([\"/** \" + name.replace(/\\*/g, '') + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\"], {\n      type: 'application/javascript'\n    }));\n\n    try {\n      importScripts(url);\n    } catch (err) {\n      console.error(err);\n    }\n\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result;\n  } // Handler for all messages within the worker\n\n\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {\n                isCallable: typeof result === 'function'\n              }\n            });\n          }\n        });\n      } // Invocation\n\n\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch (err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n/**\r\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\r\n * thread, for when the execution environment doesn't support web workers or they\r\n * are disallowed due to e.g. CSP security restrictions.\r\n */\n\n\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args);\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function');\n      }\n    });\n  };\n\n  moduleFunc._getInitResult = function () {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init; // Resolve dependencies\n\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) {\n      return dep && dep._getInitResult ? dep._getInitResult() : dep;\n    }) : []; // Invoke init with the resolved dependencies\n\n    var initThenable = DefaultThenable.all(dependencies).then(function (deps) {\n      return init.apply(null, deps);\n    }); // Cache the resolved promise for subsequent calls\n\n    moduleFunc._getInitResult = function () {\n      return initThenable;\n    };\n\n    return initThenable;\n  };\n\n  return moduleFunc;\n}\n\nvar supportsWorkers = function () {\n  var supported = false; // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(URL.createObjectURL(new Blob([''], {\n        type: 'application/javascript'\n      })));\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') ;else {\n        console.log(\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + err.message + \"]\");\n      }\n    }\n  } // Cached result\n\n\n  supportsWorkers = function () {\n    return supported;\n  };\n\n  return supported;\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\n\nvar openRequests = Object.create(null);\n/**\r\n * Define a module of code that will be executed with a web worker. This provides a simple\r\n * interface for moving chunks of logic off the main thread, and managing their dependencies\r\n * among one another.\r\n *\r\n * @param {object} options\r\n * @param {function} options.init\r\n * @param {array} [options.dependencies]\r\n * @param {function} [options.getTransferables]\r\n * @param {string} [options.name]\r\n * @param {string} [options.workerId]\r\n * @return {function(...[*]): {then}}\r\n */\n\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function');\n  }\n\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  if (!supportsWorkers()) {\n    return defineMainThreadModule(options);\n  }\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n\n  var id = \"workerModule\" + ++_workerModuleId;\n  var name = options.name || id;\n  var registrationThenable = null;\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: \"<\" + name + \"> function dependency: \" + dep.name,\n        init: \"function(){return (\\n\" + stringifyFunction(dep) + \"\\n)}\"\n      });\n      _allowInitAsString = false;\n    } // Grab postable data for worker modules\n\n\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n\n    return dep;\n  });\n\n  function moduleFunc() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len]; // Register this module if needed\n\n\n    if (!registrationThenable) {\n      registrationThenable = callWorker(workerId, 'registerModule', moduleFunc.workerModuleData);\n\n      var unregister = function () {\n        registrationThenable = null;\n        registeredModules[workerId].delete(unregister);\n      };\n\n      (registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    } // Invoke the module, returning a thenable\n\n\n    return registrationThenable.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId, 'callModule', {\n          id: id,\n          args: args\n        });\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function');\n      }\n    });\n  }\n\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n  return moduleFunc;\n}\n/**\r\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\r\n * This only terminates the Worker itself; the worker module will remain available\r\n * and if you call it again its Worker will be respawned.\r\n * @param {string} workerId\r\n */\n\n\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  } // Terminate the Worker object\n\n\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n/**\r\n * Stringifies a function into a form that can be deserialized in the worker\r\n * @param fn\r\n */\n\n\nfunction stringifyFunction(fn) {\n  var str = fn.toString(); // If it was defined in object method/property format, it needs to be modified\n\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n\n  return str;\n}\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap); // Create the worker from the bootstrap function content\n\n    worker = workers[workerId] = new Worker(URL.createObjectURL(new Blob([\"/** Worker Module Bootstrap: \" + workerId.replace(/\\*/g, '') + \" **/\\n\\n;(\" + bootstrap + \")()\"], {\n      type: 'application/javascript'\n    }))); // Single handler for response messages from the worker\n\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId');\n      }\n\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n\n  return worker;\n} // Issue a call to the worker with a callback to handle the response\n\n\nfunction callWorker(workerId, action, data) {\n  var thenable = DefaultThenable();\n  var messageId = ++_messageId;\n\n  openRequests[messageId] = function (response) {\n    if (response.success) {\n      thenable.resolve(response.result);\n    } else {\n      thenable.reject(new Error(\"Error in worker \" + action + \" call: \" + response.error));\n    }\n  };\n\n  getWorker(workerId).postMessage({\n    messageId: messageId,\n    action: action,\n    data: data\n  });\n  return thenable;\n}\n/**\r\n * Just the {@link Thenable} function wrapped as a worker module. If another worker\r\n * module needs Thenable as a dependency, it's better to pass this module rather than\r\n * the raw function in its `dependencies` array so it only gets registered once.\r\n */\n\n\nvar ThenableWorkerModule = /*#__PURE__*/defineWorkerModule({\n  name: 'Thenable',\n  dependencies: [DefaultThenable],\n  init: function (Thenable) {\n    return Thenable;\n  }\n});\nexport { DefaultThenable as Thenable, ThenableWorkerModule, defineWorkerModule, stringifyFunction, terminateWorker };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js"],"names":["BespokeThenable","state","queue","value","scheduled","completeCalled","then","onResolve","onReject","nextThenable","handleNext","cb","isFn","result","recursiveError","resultThen","getThenableThen","call","resolve","reject","err","push","scheduleQueueFlush","oneTime","val","complete","reason","st","ignoreThrow","thenableObj","valThen","v","e","setTimeout","flushQueue","q","forEach","callIt","fn","called","args","len","arguments","length","apply","TypeError","NativePromiseThenable","promise","Promise","res","rej","bind","all","items","resultCount","results","out","DefaultThenable","item","i","itemThenable","workerBootstrap","modules","Object","create","registerModule","ref","callback","id","name","dependencies","init","getTransferables","map","dep","isWorkerModule","depResult","Error","rehydrate","console","error","noLog","callModule","ref$1","handleResult","tx","Array","isArray","undefined","str","self","troikaDefine","r","url","URL","createObjectURL","Blob","replace","type","importScripts","revokeObjectURL","addEventListener","data","messageId","action","postMessage","success","message","isCallable","transferables","stack","defineMainThreadModule","options","moduleFunc","_getInitResult","initResult","initThenable","deps","supportsWorkers","supported","window","document","worker","Worker","terminate","process","env","NODE_ENV","log","_workerModuleId","_messageId","_allowInitAsString","workers","registeredModules","openRequests","defineWorkerModule","workerId","registrationThenable","workerModuleData","stringifyFunction","callWorker","unregister","delete","Set","add","terminateWorker","toString","test","getWorker","bootstrap","onmessage","response","msgId","thenable","ThenableWorkerModule","Thenable"],"mappings":"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","sourcesContent":["/**\r\n * Lightweight thenable implementation that is entirely self-contained within a single\r\n * function with no external dependencies so it can be easily shipped across to a WorkerModule.\r\n *\r\n * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\r\n * with other thenable implementations. https://github.com/promises-aplus/promises-spec\r\n *\r\n * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\r\n * have the same constructor signature and does not expose a `catch` method or the static\r\n * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\r\n * instance off to consuming code that may expect a true Promise, you'll want to wrap it\r\n * in a native-or-polyfilled Promise first.\r\n *\r\n * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\r\n * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\r\n * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\r\n * implementation I've found. And also, exercises like this are challenging and fun.)\r\n */\r\nfunction BespokeThenable() {\r\n  var state = 0; // 0=pending, 1=fulfilled, -1=rejected\r\n  var queue = [];\r\n  var value;\r\n  var scheduled = 0;\r\n  var completeCalled = 0;\r\n\r\n  function then(onResolve, onReject) {\r\n    var nextThenable = BespokeThenable();\r\n\r\n    function handleNext() {\r\n      var cb = state > 0 ? onResolve : onReject;\r\n      if (isFn(cb)) {\r\n        try {\r\n          var result = cb(value);\r\n          if (result === nextThenable) {\r\n            recursiveError();\r\n          }\r\n          var resultThen = getThenableThen(result);\r\n          if (resultThen) {\r\n            resultThen.call(result, nextThenable.resolve, nextThenable.reject);\r\n          } else {\r\n            nextThenable.resolve(result);\r\n          }\r\n        } catch (err) {\r\n          nextThenable.reject(err);\r\n        }\r\n      } else {\r\n        nextThenable[state > 0 ? 'resolve' : 'reject'](value);\r\n      }\r\n    }\r\n\r\n    queue.push(handleNext);\r\n    if (state) {\r\n      scheduleQueueFlush();\r\n    }\r\n    return nextThenable\r\n  }\r\n\r\n  var resolve = oneTime(function (val) {\r\n    if (!completeCalled) {\r\n      complete(1, val);\r\n    }\r\n  });\r\n\r\n  var reject = oneTime(function (reason) {\r\n    if (!completeCalled) {\r\n      complete(-1, reason);\r\n    }\r\n  });\r\n\r\n  function complete(st, val) {\r\n    completeCalled++;\r\n    var ignoreThrow = 0;\r\n    try {\r\n      if (val === thenableObj) {\r\n        recursiveError();\r\n      }\r\n      var valThen = st > 0 && getThenableThen(val);\r\n      if (valThen) {\r\n        valThen.call(val, oneTime(function (v) {\r\n          ignoreThrow++;\r\n          complete(1, v);\r\n        }), oneTime(function (v) {\r\n          ignoreThrow++;\r\n          complete(-1, v);\r\n        }));\r\n      } else {\r\n        state = st;\r\n        value = val;\r\n        scheduleQueueFlush();\r\n      }\r\n    } catch(e) {\r\n      if (!state && !ignoreThrow) {\r\n        complete(-1, e);\r\n      }\r\n    }\r\n  }\r\n\r\n  function scheduleQueueFlush() {\r\n    if (!scheduled) {\r\n      setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\r\n      scheduled = 1;\r\n    }\r\n  }\r\n\r\n  function flushQueue() {\r\n    var q = queue;\r\n    scheduled = 0;\r\n    queue = [];\r\n    q.forEach(callIt);\r\n  }\r\n\r\n  function callIt(fn) {\r\n    fn();\r\n  }\r\n\r\n  function getThenableThen(val) {\r\n    var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\r\n    return isFn(valThen) && valThen\r\n  }\r\n\r\n  function oneTime(fn) {\r\n    var called = 0;\r\n    return function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\r\n      if (!called++) {\r\n        fn.apply(this, args);\r\n      }\r\n    }\r\n  }\r\n\r\n  function recursiveError() {\r\n    throw new TypeError('Chaining cycle detected')\r\n  }\r\n\r\n  var isFn = function (v) { return typeof v === 'function'; };\r\n\r\n  var thenableObj = {\r\n    then: then,\r\n    resolve: resolve,\r\n    reject: reject\r\n  };\r\n  return thenableObj\r\n}\r\n\r\n\r\n/**\r\n * Thenable implementation that uses a native Promise under the covers. This implementation\r\n * is preferred if Promise is available, for better performance and dev tools integration.\r\n * @constructor\r\n */\r\nfunction NativePromiseThenable() {\r\n  var resolve, reject;\r\n  var promise = new Promise(function (res, rej) {\r\n    resolve = res;\r\n    reject = rej;\r\n  });\r\n  return {\r\n    then: promise.then.bind(promise),\r\n    resolve: resolve,\r\n    reject: reject\r\n  }\r\n}\r\n\r\n/**\r\n * Promise.all() impl:\r\n */\r\nBespokeThenable.all = NativePromiseThenable.all = function(items) {\r\n  var resultCount = 0;\r\n  var results = [];\r\n  var out = DefaultThenable();\r\n  if (items.length === 0) {\r\n    out.resolve([]);\r\n  } else {\r\n    items.forEach(function (item, i) {\r\n      var itemThenable = DefaultThenable();\r\n      itemThenable.resolve(item);\r\n      itemThenable.then(function (res) {\r\n        resultCount++;\r\n        results[i] = res;\r\n        if (resultCount === items.length) {\r\n          out.resolve(results);\r\n        }\r\n      }, out.reject);\r\n    });\r\n  }\r\n  return out\r\n};\r\n\r\n\r\n/**\r\n * Choose the best Thenable implementation and export it as the default.\r\n */\r\nvar DefaultThenable = typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable;\n\n/**\r\n * Main content for the worker that handles the loading and execution of\r\n * modules within it.\r\n */\r\nfunction workerBootstrap() {\r\n  var modules = Object.create(null);\r\n\r\n  // Handle messages for registering a module\r\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n    var init = ref.init; if ( init === void 0 ) init = function(){};\n    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\r\n    // Only register once\r\n    if (modules[id]) { return }\r\n\r\n    try {\r\n      // If any dependencies are modules, ensure they're registered and grab their value\r\n      dependencies = dependencies.map(function (dep) {\r\n        if (dep && dep.isWorkerModule) {\r\n          registerModule(dep, function (depResult) {\r\n            if (depResult instanceof Error) { throw depResult }\r\n          });\r\n          dep = modules[dep.id].value;\r\n        }\r\n        return dep\r\n      });\r\n\r\n      // Rehydrate functions\r\n      init = rehydrate((\"<\" + name + \">.init\"), init);\r\n      if (getTransferables) {\r\n        getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\r\n      }\r\n\r\n      // Initialize the module and store its value\r\n      var value = null;\r\n      if (typeof init === 'function') {\r\n        value = init.apply(void 0, dependencies);\r\n      } else {\r\n        console.error('worker module init function failed to rehydrate');\r\n      }\r\n      modules[id] = {\r\n        id: id,\r\n        value: value,\r\n        getTransferables: getTransferables\r\n      };\r\n      callback(value);\r\n    } catch(err) {\r\n      if (!(err && err.noLog)) {\r\n        console.error(err);\r\n      }\r\n      callback(err);\r\n    }\r\n  }\r\n\r\n  // Handle messages for calling a registered module's result function\r\n  function callModule(ref, callback) {\n    var ref$1;\n\n    var id = ref.id;\n    var args = ref.args;\r\n    if (!modules[id] || typeof modules[id].value !== 'function') {\r\n      callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\r\n    }\r\n    try {\r\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\r\n      if (result && typeof result.then === 'function') {\r\n        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\r\n      } else {\r\n        handleResult(result);\r\n      }\r\n    } catch(err) {\r\n      callback(err);\r\n    }\r\n    function handleResult(result) {\r\n      try {\r\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\r\n        if (!tx || !Array.isArray(tx) || !tx.length) {\r\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\r\n        }\r\n        callback(result, tx);\r\n      } catch(err) {\r\n        console.error(err);\r\n        callback(err);\r\n      }\r\n    }\r\n  }\r\n\r\n  function rehydrate(name, str) {\r\n    var result = void 0;\r\n    self.troikaDefine = function (r) { return result = r; };\r\n    var url = URL.createObjectURL(\r\n      new Blob(\r\n        [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\r\n        {type: 'application/javascript'}\r\n      )\r\n    );\r\n    try {\r\n      importScripts(url);\r\n    } catch(err) {\r\n      console.error(err);\r\n    }\r\n    URL.revokeObjectURL(url);\r\n    delete self.troikaDefine;\r\n    return result\r\n  }\r\n\r\n  // Handler for all messages within the worker\r\n  self.addEventListener('message', function (e) {\r\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\r\n    try {\r\n      // Module registration\r\n      if (action === 'registerModule') {\r\n        registerModule(data, function (result) {\r\n          if (result instanceof Error) {\r\n            postMessage({\r\n              messageId: messageId,\r\n              success: false,\r\n              error: result.message\r\n            });\r\n          } else {\r\n            postMessage({\r\n              messageId: messageId,\r\n              success: true,\r\n              result: {isCallable: typeof result === 'function'}\r\n            });\r\n          }\r\n        });\r\n      }\r\n      // Invocation\r\n      if (action === 'callModule') {\r\n        callModule(data, function (result, transferables) {\r\n          if (result instanceof Error) {\r\n            postMessage({\r\n              messageId: messageId,\r\n              success: false,\r\n              error: result.message\r\n            });\r\n          } else {\r\n            postMessage({\r\n              messageId: messageId,\r\n              success: true,\r\n              result: result\r\n            }, transferables || undefined);\r\n          }\r\n        });\r\n      }\r\n    } catch(err) {\r\n      postMessage({\r\n        messageId: messageId,\r\n        success: false,\r\n        error: err.stack\r\n      });\r\n    }\r\n  });\r\n}\n\n/**\r\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\r\n * thread, for when the execution environment doesn't support web workers or they\r\n * are disallowed due to e.g. CSP security restrictions.\r\n */\r\nfunction defineMainThreadModule(options) {\r\n  var moduleFunc = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\r\n    return moduleFunc._getInitResult().then(function (initResult) {\r\n      if (typeof initResult === 'function') {\r\n        return initResult.apply(void 0, args)\r\n      } else {\r\n        throw new Error('Worker module function was called but `init` did not return a callable function')\r\n      }\r\n    })\r\n  };\r\n  moduleFunc._getInitResult = function() {\r\n    // We can ignore getTransferables in main thread. TODO workerId?\r\n    var dependencies = options.dependencies;\n    var init = options.init;\r\n\r\n    // Resolve dependencies\r\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\r\n    ) : [];\r\n\r\n    // Invoke init with the resolved dependencies\r\n    var initThenable = DefaultThenable.all(dependencies).then(function (deps) {\r\n      return init.apply(null, deps)\r\n    });\r\n\r\n    // Cache the resolved promise for subsequent calls\r\n    moduleFunc._getInitResult = function () { return initThenable; };\r\n\r\n    return initThenable\r\n  };\r\n  return moduleFunc\r\n}\n\nvar supportsWorkers = function () {\r\n  var supported = false;\r\n\r\n  // Only attempt worker initialization in browsers; elsewhere it would just be\r\n  // noise e.g. loading into a Node environment for SSR.\r\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\r\n    try {\r\n      // TODO additional checks for things like importScripts within the worker?\r\n      //  Would need to be an async check.\r\n      var worker = new Worker(\r\n        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\r\n      );\r\n      worker.terminate();\r\n      supported = true;\r\n    } catch (err) {\r\n      if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') ; else {\r\n        console.log(\r\n          (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Cached result\r\n  supportsWorkers = function () { return supported; };\r\n  return supported\r\n};\n\nvar _workerModuleId = 0;\r\nvar _messageId = 0;\r\nvar _allowInitAsString = false;\r\nvar workers = Object.create(null);\r\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\r\nvar openRequests = Object.create(null);\r\n\r\n\r\n/**\r\n * Define a module of code that will be executed with a web worker. This provides a simple\r\n * interface for moving chunks of logic off the main thread, and managing their dependencies\r\n * among one another.\r\n *\r\n * @param {object} options\r\n * @param {function} options.init\r\n * @param {array} [options.dependencies]\r\n * @param {function} [options.getTransferables]\r\n * @param {string} [options.name]\r\n * @param {string} [options.workerId]\r\n * @return {function(...[*]): {then}}\r\n */\r\nfunction defineWorkerModule(options) {\r\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\r\n    throw new Error('requires `options.init` function')\r\n  }\r\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\r\n\r\n  if (!supportsWorkers()) {\r\n    return defineMainThreadModule(options)\r\n  }\r\n\r\n  if (workerId == null) {\r\n    workerId = '#default';\r\n  }\r\n  var id = \"workerModule\" + (++_workerModuleId);\r\n  var name = options.name || id;\r\n  var registrationThenable = null;\r\n\r\n  dependencies = dependencies && dependencies.map(function (dep) {\r\n    // Wrap raw functions as worker modules with no dependencies\r\n    if (typeof dep === 'function' && !dep.workerModuleData) {\r\n      _allowInitAsString = true;\r\n      dep = defineWorkerModule({\r\n        workerId: workerId,\r\n        name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\r\n        init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\r\n      });\r\n      _allowInitAsString = false;\r\n    }\r\n    // Grab postable data for worker modules\r\n    if (dep && dep.workerModuleData) {\r\n      dep = dep.workerModuleData;\r\n    }\r\n    return dep\r\n  });\r\n\r\n  function moduleFunc() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\r\n    // Register this module if needed\r\n    if (!registrationThenable) {\r\n      registrationThenable = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\r\n      var unregister = function () {\r\n        registrationThenable = null;\r\n        registeredModules[workerId].delete(unregister);\r\n      }\r\n      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\r\n    }\r\n\r\n    // Invoke the module, returning a thenable\r\n    return registrationThenable.then(function (ref) {\n      var isCallable = ref.isCallable;\n\r\n      if (isCallable) {\r\n        return callWorker(workerId,'callModule', {id: id, args: args})\r\n      } else {\r\n        throw new Error('Worker module function was called but `init` did not return a callable function')\r\n      }\r\n    })\r\n  }\r\n  moduleFunc.workerModuleData = {\r\n    isWorkerModule: true,\r\n    id: id,\r\n    name: name,\r\n    dependencies: dependencies,\r\n    init: stringifyFunction(init),\r\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\r\n  };\r\n  return moduleFunc\r\n}\r\n\r\n/**\r\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\r\n * This only terminates the Worker itself; the worker module will remain available\r\n * and if you call it again its Worker will be respawned.\r\n * @param {string} workerId\r\n */\r\nfunction terminateWorker(workerId) {\r\n  // Unregister all modules that were registered in that worker\r\n  if (registeredModules[workerId]) {\r\n    registeredModules[workerId].forEach(function (unregister) {\r\n      unregister();\r\n    });\r\n  }\r\n  // Terminate the Worker object\r\n  if (workers[workerId]) {\r\n    workers[workerId].terminate();\r\n    delete workers[workerId];\r\n  }\r\n}\r\n\r\n/**\r\n * Stringifies a function into a form that can be deserialized in the worker\r\n * @param fn\r\n */\r\nfunction stringifyFunction(fn) {\r\n  var str = fn.toString();\r\n  // If it was defined in object method/property format, it needs to be modified\r\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\r\n    str = 'function ' + str;\r\n  }\r\n  return str\r\n}\r\n\r\n\r\nfunction getWorker(workerId) {\r\n  var worker = workers[workerId];\r\n  if (!worker) {\r\n    // Bootstrap the worker's content\r\n    var bootstrap = stringifyFunction(workerBootstrap);\r\n\r\n    // Create the worker from the bootstrap function content\r\n    worker = workers[workerId] = new Worker(\r\n      URL.createObjectURL(\r\n        new Blob(\r\n          [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\r\n          {type: 'application/javascript'}\r\n        )\r\n      )\r\n    );\r\n\r\n    // Single handler for response messages from the worker\r\n    worker.onmessage = function (e) {\r\n      var response = e.data;\r\n      var msgId = response.messageId;\r\n      var callback = openRequests[msgId];\r\n      if (!callback) {\r\n        throw new Error('WorkerModule response with empty or unknown messageId')\r\n      }\r\n      delete openRequests[msgId];\r\n      callback(response);\r\n    };\r\n  }\r\n  return worker\r\n}\r\n\r\n// Issue a call to the worker with a callback to handle the response\r\nfunction callWorker(workerId, action, data) {\r\n  var thenable = DefaultThenable();\r\n  var messageId = ++_messageId;\r\n  openRequests[messageId] = function (response) {\r\n    if (response.success) {\r\n      thenable.resolve(response.result);\r\n    } else {\r\n      thenable.reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\r\n    }\r\n  };\r\n  getWorker(workerId).postMessage({\r\n    messageId: messageId,\r\n    action: action,\r\n    data: data\r\n  });\r\n  return thenable\r\n}\n\n/**\r\n * Just the {@link Thenable} function wrapped as a worker module. If another worker\r\n * module needs Thenable as a dependency, it's better to pass this module rather than\r\n * the raw function in its `dependencies` array so it only gets registered once.\r\n */\r\nvar ThenableWorkerModule = /*#__PURE__*/defineWorkerModule({\r\n  name: 'Thenable',\r\n  dependencies: [DefaultThenable],\r\n  init: function(Thenable) {\r\n    return Thenable\r\n  }\r\n});\n\nexport { DefaultThenable as Thenable, ThenableWorkerModule, defineWorkerModule, stringifyFunction, terminateWorker };\n"]},"metadata":{},"sourceType":"module"}