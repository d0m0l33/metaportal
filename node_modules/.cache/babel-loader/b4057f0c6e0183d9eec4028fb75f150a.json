{"ast":null,"code":"import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three'; // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst conditionalLineVertShader =\n/* glsl */\n`\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\nconst conditionalLineFragShader =\n/* glsl */\n`\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nfunction smoothNormals(triangles, lineSegments) {\n  function hashVertex(v) {\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n    // to be smoothed as expected (see minifig arms). The errors between edges\n    // could be due to matrix multiplication.\n    const x = ~~(v.x * 1e2);\n    const y = ~~(v.y * 1e2);\n    const z = ~~(v.z * 1e2);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n\n  const hardEdges = new Set();\n  const halfEdgeList = {};\n  const fullHalfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const v0 = ls.v0;\n    const v1 = ls.v1;\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = triangles.length; i < l; i++) {\n    const tri = triangles[i];\n\n    for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % 3;\n      const v0 = tri[`v${index}`];\n      const v1 = tri[`v${next}`];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) continue;\n      halfEdgeList[hash] = tri;\n      fullHalfEdgeList[hash] = tri;\n    }\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n  // quads provide more \"influence\" to some vertex normals than a triangle due to\n  // the fact that a quad is made up of two triangles and all triangles are weighted\n  // equally. To fix this quads could be tracked separately so their vertex normals\n  // are weighted appropriately or we could try only adding a normal direction\n  // once per normal.\n  // Iterate until we've tried to connect all triangles to share normals\n\n\n  while (true) {\n    // Stop if there are no more triangles left\n    const halfEdges = Object.keys(halfEdgeList);\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n    let i = 0;\n    const queue = [fullHalfEdgeList[halfEdges[0]]];\n\n    while (i < queue.length) {\n      // initialize all vertex normals in this triangle\n      const tri = queue[i];\n      i++;\n      const faceNormal = tri.faceNormal;\n\n      if (tri.n0 === null) {\n        tri.n0 = faceNormal.clone();\n        normals.push(tri.n0);\n      }\n\n      if (tri.n1 === null) {\n        tri.n1 = faceNormal.clone();\n        normals.push(tri.n1);\n      }\n\n      if (tri.n2 === null) {\n        tri.n2 = faceNormal.clone();\n        normals.push(tri.n2);\n      } // Check if any edge is connected to another triangle edge\n\n\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % 3;\n        const v0 = tri[`v${index}`];\n        const v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherTri = fullHalfEdgeList[reverseHash];\n\n        if (otherTri) {\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherTri);\n            delete halfEdgeList[reverseHash];\n          } // Find the matching edge in this triangle and copy the normal vector over\n\n\n          for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n            const otherIndex = i3;\n            const otherNext = (i3 + 1) % 3;\n            const otherV0 = otherTri[`v${otherIndex}`];\n            const otherV1 = otherTri[`v${otherNext}`];\n            const otherHash = hashEdge(otherV0, otherV1);\n\n            if (otherHash === reverseHash) {\n              if (otherTri[`n${otherIndex}`] === null) {\n                const norm = tri[`n${next}`];\n                otherTri[`n${otherIndex}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              if (otherTri[`n${otherNext}`] === null) {\n                const norm = tri[`n${index}`];\n                otherTri[`n${otherNext}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              break;\n            }\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colourCode === b.colourCode) {\n    return 0;\n  }\n\n  if (a.colourCode < b.colourCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the triangles or line segments by colour code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  const positions = [];\n  const normals = [];\n  const materials = [];\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    const v0 = elem.v0;\n    const v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n    if (elementSize === 3) {\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n      const n0 = elem.n0 || elem.faceNormal;\n      const n1 = elem.n1 || elem.faceNormal;\n      const n2 = elem.n2 || elem.faceNormal;\n      normals.push(n0.x, n0.y, n0.z);\n      normals.push(n1.x, n1.y, n1.z);\n      normals.push(n2.x, n2.y, n2.z);\n    }\n\n    if (prevMaterial !== elem.material) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      materials.push(elem.material);\n      prevMaterial = elem.material;\n      index0 = iElem * elementSize;\n      numGroupVerts = elementSize;\n    } else {\n      numGroupVerts += elementSize;\n    }\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n  if (elementSize === 3) {\n    bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    object3d = new LineSegments(bufferGeometry, materials);\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const c0 = os.c0;\n      const c1 = os.c1;\n      const v0 = os.v0;\n      const v1 = os.v1;\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (!this.fileMap) {\n      this.fileMap = {};\n    }\n\n    const scope = this;\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, function (text) {\n      scope.processObject(text, onLoad, null, url);\n    }, onProgress, onError);\n  }\n\n  parse(text, path, onLoad) {\n    // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n    this.processObject(text, onLoad, null, path);\n  }\n\n  setMaterials(materials) {\n    // Clears parse scopes stack, adds new scope with material library\n    this.parseScopesStack = [];\n    this.newParseScopeLevel(materials);\n    this.getCurrentParseScope().isFromParse = false;\n    this.materials = materials;\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  newParseScopeLevel(materials) {\n    // Adds a new scope level, assign materials to it and returns it\n    const matLib = {};\n\n    if (materials) {\n      for (let i = 0, n = materials.length; i < n; i++) {\n        const material = materials[i];\n        matLib[material.userData.code] = material;\n      }\n    }\n\n    const topParseScope = this.getCurrentParseScope();\n    const newParseScope = {\n      lib: matLib,\n      url: null,\n      // Subobjects\n      subobjects: null,\n      numSubobjects: 0,\n      subobjectIndex: 0,\n      inverted: false,\n      category: null,\n      keywords: null,\n      // Current subobject\n      currentFileName: null,\n      mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n      mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n      currentMatrix: new Matrix4(),\n      matrix: new Matrix4(),\n      // If false, it is a root material scope previous to parse\n      isFromParse: true,\n      triangles: null,\n      lineSegments: null,\n      conditionalSegments: null,\n      // If true, this object is the start of a construction step\n      startingConstructionStep: false\n    };\n    this.parseScopesStack.push(newParseScope);\n    return newParseScope;\n  }\n\n  removeScopeLevel() {\n    this.parseScopesStack.pop();\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.getCurrentParseScope().lib;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n    }\n\n    matLib[material.userData.code] = material;\n    return this;\n  }\n\n  getMaterial(colourCode) {\n    // Given a colour code search its material in the parse scopes stack\n    if (colourCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB colour)\n      const colour = colourCode.substring(3);\n      return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n    }\n\n    for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n      const material = this.parseScopesStack[i].lib[colourCode];\n\n      if (material) {\n        return material;\n      }\n    } // Material was not found\n\n\n    return null;\n  }\n\n  getParentParseScope() {\n    if (this.parseScopesStack.length > 1) {\n      return this.parseScopesStack[this.parseScopesStack.length - 2];\n    }\n\n    return null;\n  }\n\n  getCurrentParseScope() {\n    if (this.parseScopesStack.length > 0) {\n      return this.parseScopesStack[this.parseScopesStack.length - 1];\n    }\n\n    return null;\n  }\n\n  parseColourMetaDirective(lineParser) {\n    // Parses a colour definition and returns a THREE.Material or null if error\n    let code = null; // Triangle and line colours\n\n    let colour = 0xff00ff;\n    let edgeColour = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let canHaveEnvMap = true;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          colour = lineParser.getToken();\n\n          if (colour.startsWith('0x')) {\n            colour = '#' + colour.substring(2);\n          } else if (!colour.startsWith('#')) {\n            throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColour = lineParser.getToken();\n\n          if (edgeColour.startsWith('0x')) {\n            edgeColour = '#' + edgeColour.substring(2);\n          } else if (!edgeColour.startsWith('#')) {\n            // Try to see if edge colour is a colour code\n            edgeMaterial = this.getMaterial(edgeColour);\n\n            if (!edgeMaterial) {\n              throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.3,\n          envMapIntensity: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n        const specular = new Color(colour);\n        const hsl = specular.getHSL({\n          h: 0,\n          s: 0,\n          l: 0\n        });\n        hsl.h = (hsl.h + 0.5) % 1;\n        hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n        specular.setHSL(hsl.h, hsl.s, hsl.l);\n        material = new MeshPhongMaterial({\n          color: colour,\n          specular: specular,\n          shininess: 10,\n          reflectivity: 0.3\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.9,\n          metalness: 0\n        });\n        canHaveEnvMap = false;\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    material.userData.canHaveEnvMap = canHaveEnvMap;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColour,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge';\n      edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n        vertexShader: conditionalLineVertShader,\n        fragmentShader: conditionalLineFragShader,\n        uniforms: UniformsUtils.merge([UniformsLib.fog, {\n          diffuse: {\n            value: new Color(edgeColour)\n          },\n          opacity: {\n            value: alpha\n          }\n        }]),\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    return material;\n  } //\n\n\n  objectParse(text) {\n    // Retrieve data from the parent parse scope\n    const parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n    const mainColourCode = parentParseScope.mainColourCode;\n    const mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n    const currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n    let triangles;\n    let lineSegments;\n    let conditionalSegments;\n    const subobjects = [];\n    let category = null;\n    let keywords = null;\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let type = '';\n    let startingConstructionStep = false;\n    const scope = this;\n\n    function parseColourCode(lineParser, forEdge) {\n      // Parses next colour code and returns a THREE.Material\n      let colourCode = lineParser.getToken();\n\n      if (!forEdge && colourCode === '16') {\n        colourCode = mainColourCode;\n      }\n\n      if (forEdge && colourCode === '24') {\n        colourCode = mainEdgeColourCode;\n      }\n\n      const material = scope.getMaterial(colourCode);\n\n      if (!material) {\n        throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n      }\n\n      return material;\n    }\n\n    function parseVector(lp) {\n      const v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n      if (!scope.separateObjects) {\n        v.applyMatrix4(currentParseScope.currentMatrix);\n      }\n\n      return v;\n    } // Parse all line commands\n\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let segment;\n      let inverted;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, faceNormal;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                currentParseScope.triangles = [];\n                currentParseScope.lineSegments = [];\n                currentParseScope.conditionalSegments = [];\n                currentParseScope.type = type;\n                const isRoot = !parentParseScope.isFromParse;\n\n                if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                  currentParseScope.groupObject = new Group();\n                  currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                } // If the scale of the object is negated then the triangle winding order\n                // needs to be flipped.\n\n\n                if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                  currentParseScope.inverted = !currentParseScope.inverted;\n                }\n\n                triangles = currentParseScope.triangles;\n                lineSegments = currentParseScope.lineSegments;\n                conditionalSegments = currentParseScope.conditionalSegments;\n                break;\n\n              case '!COLOUR':\n                material = this.parseColourMetaDirective(lp);\n\n                if (material) {\n                  this.addMaterial(material);\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          material = parseColourCode(lp);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (scope.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = scope.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            matrix: matrix,\n            fileName: fileName,\n            originalFileName: fileName,\n            locationState: FILE_LOCATION_AS_IS,\n            url: null,\n            triedLowerCase: false,\n            inverted: bfcInverted !== currentParseScope.inverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp)\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp),\n            c0: parseVector(lp),\n            c1: parseVector(lp)\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n          } else {\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n            v3 = parseVector(lp);\n          } else {\n            v3 = parseVector(lp);\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v2,\n            v2: v3,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v3,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n    }\n\n    currentParseScope.category = category;\n    currentParseScope.keywords = keywords;\n    currentParseScope.subobjects = subobjects;\n    currentParseScope.numSubobjects = subobjects.length;\n    currentParseScope.subobjectIndex = 0;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n  processObject(text, onProcessed, subobject, url) {\n    const scope = this;\n    const parseScope = scope.newParseScopeLevel();\n    parseScope.url = url;\n    const parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n    if (subobject) {\n      parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n      parseScope.matrix.copy(subobject.matrix);\n      parseScope.inverted = subobject.inverted;\n      parseScope.startingConstructionStep = subobject.startingConstructionStep;\n    } // Add to cache\n\n\n    let currentFileName = parentParseScope.currentFileName;\n\n    if (currentFileName !== null) {\n      currentFileName = parentParseScope.currentFileName.toLowerCase();\n    }\n\n    if (scope.subobjectCache[currentFileName] === undefined) {\n      scope.subobjectCache[currentFileName] = text;\n    } // Parse the object (returns a Group)\n\n\n    scope.objectParse(text);\n    let finishedCount = 0;\n    onSubobjectFinish();\n\n    function onSubobjectFinish() {\n      finishedCount++;\n\n      if (finishedCount === parseScope.subobjects.length + 1) {\n        finalizeObject();\n      } else {\n        // Once the previous subobject has finished we can start processing the next one in the list.\n        // The subobject processing shares scope in processing so it's important that they be loaded serially\n        // to avoid race conditions.\n        // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n        // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n        // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n        const subobject = parseScope.subobjects[parseScope.subobjectIndex];\n        Promise.resolve().then(function () {\n          loadSubobject(subobject);\n        });\n        parseScope.subobjectIndex++;\n      }\n    }\n\n    function finalizeObject() {\n      if (scope.smoothNormals && parseScope.type === 'Part') {\n        smoothNormals(parseScope.triangles, parseScope.lineSegments);\n      }\n\n      const isRoot = !parentParseScope.isFromParse;\n\n      if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n        const objGroup = parseScope.groupObject;\n\n        if (parseScope.triangles.length > 0) {\n          objGroup.add(createObject(parseScope.triangles, 3));\n        }\n\n        if (parseScope.lineSegments.length > 0) {\n          objGroup.add(createObject(parseScope.lineSegments, 2));\n        }\n\n        if (parseScope.conditionalSegments.length > 0) {\n          objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n        }\n\n        if (parentParseScope.groupObject) {\n          objGroup.name = parseScope.fileName;\n          objGroup.userData.category = parseScope.category;\n          objGroup.userData.keywords = parseScope.keywords;\n          parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n          parentParseScope.groupObject.add(objGroup);\n        }\n      } else {\n        const separateObjects = scope.separateObjects;\n        const parentLineSegments = parentParseScope.lineSegments;\n        const parentConditionalSegments = parentParseScope.conditionalSegments;\n        const parentTriangles = parentParseScope.triangles;\n        const lineSegments = parseScope.lineSegments;\n        const conditionalSegments = parseScope.conditionalSegments;\n        const triangles = parseScope.triangles;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n\n          if (separateObjects) {\n            ls.v0.applyMatrix4(parseScope.matrix);\n            ls.v1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n\n          if (separateObjects) {\n            os.v0.applyMatrix4(parseScope.matrix);\n            os.v1.applyMatrix4(parseScope.matrix);\n            os.c0.applyMatrix4(parseScope.matrix);\n            os.c1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = triangles.length; i < l; i++) {\n          const tri = triangles[i];\n\n          if (separateObjects) {\n            tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n            tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n            tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n\n            _tempVec0.subVectors(tri.v1, tri.v0);\n\n            _tempVec1.subVectors(tri.v2, tri.v1);\n\n            tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\n          }\n\n          parentTriangles.push(tri);\n        }\n      }\n\n      scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n      if (!parentParseScope.isFromParse) {\n        scope.computeConstructionSteps(parseScope.groupObject);\n      }\n\n      if (onProcessed) {\n        onProcessed(parseScope.groupObject);\n      }\n    }\n\n    function loadSubobject(subobject) {\n      parseScope.mainColourCode = subobject.material.userData.code;\n      parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n      parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n      const cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n      if (cached) {\n        scope.processObject(cached, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n        return;\n      } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n      // Update also subobject.locationState for the next try if this load fails.\n\n\n      let subobjectURL = subobject.fileName;\n      let newLocationState = FILE_LOCATION_NOT_FOUND;\n\n      switch (subobject.locationState) {\n        case FILE_LOCATION_AS_IS:\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (subobject.triedLowerCase) {\n            // Try absolute path\n            newLocationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            subobject.fileName = subobject.fileName.toLowerCase();\n            subobjectURL = subobject.fileName;\n            subobject.triedLowerCase = true;\n            newLocationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n\n        case FILE_LOCATION_NOT_FOUND:\n          // All location possibilities have been tried, give up loading this object\n          console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n          return;\n      }\n\n      subobject.locationState = newLocationState;\n      subobject.url = subobjectURL; // Load the subobject\n      // Use another file loader here so we can keep track of the subobject information\n      // and use it when processing the next model.\n\n      const fileLoader = new FileLoader(scope.manager);\n      fileLoader.setPath(scope.path);\n      fileLoader.setRequestHeader(scope.requestHeader);\n      fileLoader.setWithCredentials(scope.withCredentials);\n      fileLoader.load(subobjectURL, function (text) {\n        scope.processObject(text, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n      }, undefined, function (err) {\n        onSubobjectError(err, subobject);\n      }, subobject);\n    }\n\n    function onSubobjectLoaded(subobjectGroup, subobject) {\n      if (subobjectGroup === null) {\n        // Try to reload\n        loadSubobject(subobject);\n        return;\n      }\n\n      scope.fileMap[subobject.originalFileName] = subobject.url;\n    }\n\n    function onSubobjectError(err, subobject) {\n      // Retry download from a different default possible location\n      loadSubobject(subobject);\n    }\n  }\n\n}\n\nexport { LDrawLoader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/loaders/LDrawLoader.js"],"names":["Vector3","Loader","FileLoader","Matrix4","MeshStandardMaterial","Color","MeshPhongMaterial","LineBasicMaterial","ShaderMaterial","UniformsUtils","UniformsLib","Group","BufferGeometry","Float32BufferAttribute","LineSegments","Mesh","BufferAttribute","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","conditionalLineVertShader","conditionalLineFragShader","_tempVec0","_tempVec1","smoothNormals","triangles","lineSegments","hashVertex","v","x","y","z","hashEdge","v0","v1","hardEdges","Set","halfEdgeList","fullHalfEdgeList","normals","i","l","length","ls","add","tri","i2","l2","index","next","hash","has","halfEdges","Object","keys","queue","faceNormal","n0","clone","push","n1","n2","reverseHash","otherTri","Math","abs","dot","i3","l3","otherIndex","otherNext","otherV0","otherV1","otherHash","norm","normalize","isPrimitiveType","type","test","LineParser","constructor","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","sortByMaterial","a","b","colourCode","createObject","elements","elementSize","isConditionalSegments","sort","positions","materials","bufferGeometry","prevMaterial","index0","numGroupVerts","iElem","nElem","elem","v2","material","addGroup","Infinity","setAttribute","object3d","isConditionalLine","controlArray0","Float32Array","controlArray1","directionArray","os","c0","c1","LDrawLoader","manager","parseScopesStack","subobjectCache","fileMap","setMaterials","parseColourMetaDirective","separateObjects","load","url","onLoad","onProgress","onError","scope","fileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","processObject","parse","newParseScopeLevel","getCurrentParseScope","isFromParse","setFileMap","matLib","n","userData","code","topParseScope","newParseScope","lib","subobjects","numSubobjects","subobjectIndex","inverted","category","keywords","currentFileName","mainColourCode","mainEdgeColourCode","currentMatrix","matrix","conditionalSegments","startingConstructionStep","removeScopeLevel","pop","addMaterial","getMaterial","startsWith","colour","getParentParseScope","lineParser","edgeColour","alpha","isTransparent","luminance","finishType","canHaveEnvMap","edgeMaterial","name","token","toUpperCase","parseInt","isNaN","max","min","color","roughness","envMapIntensity","metalness","specular","hsl","getHSL","h","s","setHSL","shininess","reflectivity","transparent","premultipliedAlpha","opacity","depthWrite","polygonOffset","polygonOffsetFactor","emissive","set","multiplyScalar","conditionalEdgeMaterial","vertexShader","fragmentShader","uniforms","merge","fog","diffuse","value","objectParse","parentParseScope","currentParseScope","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","parseColourCode","forEdge","parseVector","lp","parseFloat","applyMatrix4","lineIndex","toLowerCase","lineType","segment","ccw","doubleSided","v3","meta","isRoot","groupObject","determinant","console","warn","newKeywords","forEach","keyword","trim","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","fileName","originalFileName","locationState","triedLowerCase","subVectors","crossVectors","computeConstructionSteps","model","stepNumber","traverse","c","isGroup","constructionStep","numConstructionSteps","onProcessed","subobject","parseScope","multiplyMatrices","copy","undefined","finishedCount","onSubobjectFinish","finalizeObject","Promise","resolve","then","loadSubobject","objGroup","decompose","position","quaternion","scale","parentLineSegments","parentConditionalSegments","parentTriangles","cached","subobjectGroup","onSubobjectLoaded","subobjectURL","newLocationState","lastIndexOf","err","onSubobjectError"],"mappings":"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","sourcesContent":["import { Vector3, Loader, FileLoader, Matrix4, MeshStandardMaterial, Color, MeshPhongMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Group, BufferGeometry, Float32BufferAttribute, LineSegments, Mesh, BufferAttribute } from 'three';\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst conditionalLineVertShader =\n/* glsl */\n`\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\nconst conditionalLineFragShader =\n/* glsl */\n`\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nfunction smoothNormals(triangles, lineSegments) {\n  function hashVertex(v) {\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n    // to be smoothed as expected (see minifig arms). The errors between edges\n    // could be due to matrix multiplication.\n    const x = ~~(v.x * 1e2);\n    const y = ~~(v.y * 1e2);\n    const z = ~~(v.z * 1e2);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n\n  const hardEdges = new Set();\n  const halfEdgeList = {};\n  const fullHalfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const v0 = ls.v0;\n    const v1 = ls.v1;\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = triangles.length; i < l; i++) {\n    const tri = triangles[i];\n\n    for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % 3;\n      const v0 = tri[`v${index}`];\n      const v1 = tri[`v${next}`];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) continue;\n      halfEdgeList[hash] = tri;\n      fullHalfEdgeList[hash] = tri;\n    }\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n  // quads provide more \"influence\" to some vertex normals than a triangle due to\n  // the fact that a quad is made up of two triangles and all triangles are weighted\n  // equally. To fix this quads could be tracked separately so their vertex normals\n  // are weighted appropriately or we could try only adding a normal direction\n  // once per normal.\n  // Iterate until we've tried to connect all triangles to share normals\n\n\n  while (true) {\n    // Stop if there are no more triangles left\n    const halfEdges = Object.keys(halfEdgeList);\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n    let i = 0;\n    const queue = [fullHalfEdgeList[halfEdges[0]]];\n\n    while (i < queue.length) {\n      // initialize all vertex normals in this triangle\n      const tri = queue[i];\n      i++;\n      const faceNormal = tri.faceNormal;\n\n      if (tri.n0 === null) {\n        tri.n0 = faceNormal.clone();\n        normals.push(tri.n0);\n      }\n\n      if (tri.n1 === null) {\n        tri.n1 = faceNormal.clone();\n        normals.push(tri.n1);\n      }\n\n      if (tri.n2 === null) {\n        tri.n2 = faceNormal.clone();\n        normals.push(tri.n2);\n      } // Check if any edge is connected to another triangle edge\n\n\n      for (let i2 = 0, l2 = 3; i2 < l2; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % 3;\n        const v0 = tri[`v${index}`];\n        const v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherTri = fullHalfEdgeList[reverseHash];\n\n        if (otherTri) {\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherTri);\n            delete halfEdgeList[reverseHash];\n          } // Find the matching edge in this triangle and copy the normal vector over\n\n\n          for (let i3 = 0, l3 = 3; i3 < l3; i3++) {\n            const otherIndex = i3;\n            const otherNext = (i3 + 1) % 3;\n            const otherV0 = otherTri[`v${otherIndex}`];\n            const otherV1 = otherTri[`v${otherNext}`];\n            const otherHash = hashEdge(otherV0, otherV1);\n\n            if (otherHash === reverseHash) {\n              if (otherTri[`n${otherIndex}`] === null) {\n                const norm = tri[`n${next}`];\n                otherTri[`n${otherIndex}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              if (otherTri[`n${otherNext}`] === null) {\n                const norm = tri[`n${index}`];\n                otherTri[`n${otherNext}`] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              break;\n            }\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colourCode === b.colourCode) {\n    return 0;\n  }\n\n  if (a.colourCode < b.colourCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the triangles or line segments by colour code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  const positions = [];\n  const normals = [];\n  const materials = [];\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    const v0 = elem.v0;\n    const v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n    if (elementSize === 3) {\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n      const n0 = elem.n0 || elem.faceNormal;\n      const n1 = elem.n1 || elem.faceNormal;\n      const n2 = elem.n2 || elem.faceNormal;\n      normals.push(n0.x, n0.y, n0.z);\n      normals.push(n1.x, n1.y, n1.z);\n      normals.push(n2.x, n2.y, n2.z);\n    }\n\n    if (prevMaterial !== elem.material) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      materials.push(elem.material);\n      prevMaterial = elem.material;\n      index0 = iElem * elementSize;\n      numGroupVerts = elementSize;\n    } else {\n      numGroupVerts += elementSize;\n    }\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n  if (elementSize === 3) {\n    bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    object3d = new LineSegments(bufferGeometry, materials);\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const c0 = os.c0;\n      const c1 = os.c1;\n      const v0 = os.v0;\n      const v1 = os.v1;\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (!this.fileMap) {\n      this.fileMap = {};\n    }\n\n    const scope = this;\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, function (text) {\n      scope.processObject(text, onLoad, null, url);\n    }, onProgress, onError);\n  }\n\n  parse(text, path, onLoad) {\n    // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n    this.processObject(text, onLoad, null, path);\n  }\n\n  setMaterials(materials) {\n    // Clears parse scopes stack, adds new scope with material library\n    this.parseScopesStack = [];\n    this.newParseScopeLevel(materials);\n    this.getCurrentParseScope().isFromParse = false;\n    this.materials = materials;\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  newParseScopeLevel(materials) {\n    // Adds a new scope level, assign materials to it and returns it\n    const matLib = {};\n\n    if (materials) {\n      for (let i = 0, n = materials.length; i < n; i++) {\n        const material = materials[i];\n        matLib[material.userData.code] = material;\n      }\n    }\n\n    const topParseScope = this.getCurrentParseScope();\n    const newParseScope = {\n      lib: matLib,\n      url: null,\n      // Subobjects\n      subobjects: null,\n      numSubobjects: 0,\n      subobjectIndex: 0,\n      inverted: false,\n      category: null,\n      keywords: null,\n      // Current subobject\n      currentFileName: null,\n      mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n      mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n      currentMatrix: new Matrix4(),\n      matrix: new Matrix4(),\n      // If false, it is a root material scope previous to parse\n      isFromParse: true,\n      triangles: null,\n      lineSegments: null,\n      conditionalSegments: null,\n      // If true, this object is the start of a construction step\n      startingConstructionStep: false\n    };\n    this.parseScopesStack.push(newParseScope);\n    return newParseScope;\n  }\n\n  removeScopeLevel() {\n    this.parseScopesStack.pop();\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.getCurrentParseScope().lib;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n    }\n\n    matLib[material.userData.code] = material;\n    return this;\n  }\n\n  getMaterial(colourCode) {\n    // Given a colour code search its material in the parse scopes stack\n    if (colourCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB colour)\n      const colour = colourCode.substring(3);\n      return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n    }\n\n    for (let i = this.parseScopesStack.length - 1; i >= 0; i--) {\n      const material = this.parseScopesStack[i].lib[colourCode];\n\n      if (material) {\n        return material;\n      }\n    } // Material was not found\n\n\n    return null;\n  }\n\n  getParentParseScope() {\n    if (this.parseScopesStack.length > 1) {\n      return this.parseScopesStack[this.parseScopesStack.length - 2];\n    }\n\n    return null;\n  }\n\n  getCurrentParseScope() {\n    if (this.parseScopesStack.length > 0) {\n      return this.parseScopesStack[this.parseScopesStack.length - 1];\n    }\n\n    return null;\n  }\n\n  parseColourMetaDirective(lineParser) {\n    // Parses a colour definition and returns a THREE.Material or null if error\n    let code = null; // Triangle and line colours\n\n    let colour = 0xff00ff;\n    let edgeColour = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let canHaveEnvMap = true;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          colour = lineParser.getToken();\n\n          if (colour.startsWith('0x')) {\n            colour = '#' + colour.substring(2);\n          } else if (!colour.startsWith('#')) {\n            throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColour = lineParser.getToken();\n\n          if (edgeColour.startsWith('0x')) {\n            edgeColour = '#' + edgeColour.substring(2);\n          } else if (!edgeColour.startsWith('#')) {\n            // Try to see if edge colour is a colour code\n            edgeMaterial = this.getMaterial(edgeColour);\n\n            if (!edgeMaterial) {\n              throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.3,\n          envMapIntensity: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n        const specular = new Color(colour);\n        const hsl = specular.getHSL({\n          h: 0,\n          s: 0,\n          l: 0\n        });\n        hsl.h = (hsl.h + 0.5) % 1;\n        hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n        specular.setHSL(hsl.h, hsl.s, hsl.l);\n        material = new MeshPhongMaterial({\n          color: colour,\n          specular: specular,\n          shininess: 10,\n          reflectivity: 0.3\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.9,\n          metalness: 0\n        });\n        canHaveEnvMap = false;\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: colour,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    material.userData.canHaveEnvMap = canHaveEnvMap;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColour,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge';\n      edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new ShaderMaterial({\n        vertexShader: conditionalLineVertShader,\n        fragmentShader: conditionalLineFragShader,\n        uniforms: UniformsUtils.merge([UniformsLib.fog, {\n          diffuse: {\n            value: new Color(edgeColour)\n          },\n          opacity: {\n            value: alpha\n          }\n        }]),\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    return material;\n  } //\n\n\n  objectParse(text) {\n    // Retrieve data from the parent parse scope\n    const parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n    const mainColourCode = parentParseScope.mainColourCode;\n    const mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n    const currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n    let triangles;\n    let lineSegments;\n    let conditionalSegments;\n    const subobjects = [];\n    let category = null;\n    let keywords = null;\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let type = '';\n    let startingConstructionStep = false;\n    const scope = this;\n\n    function parseColourCode(lineParser, forEdge) {\n      // Parses next colour code and returns a THREE.Material\n      let colourCode = lineParser.getToken();\n\n      if (!forEdge && colourCode === '16') {\n        colourCode = mainColourCode;\n      }\n\n      if (forEdge && colourCode === '24') {\n        colourCode = mainEdgeColourCode;\n      }\n\n      const material = scope.getMaterial(colourCode);\n\n      if (!material) {\n        throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n      }\n\n      return material;\n    }\n\n    function parseVector(lp) {\n      const v = new Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n      if (!scope.separateObjects) {\n        v.applyMatrix4(currentParseScope.currentMatrix);\n      }\n\n      return v;\n    } // Parse all line commands\n\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let segment;\n      let inverted;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, faceNormal;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                currentParseScope.triangles = [];\n                currentParseScope.lineSegments = [];\n                currentParseScope.conditionalSegments = [];\n                currentParseScope.type = type;\n                const isRoot = !parentParseScope.isFromParse;\n\n                if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                  currentParseScope.groupObject = new Group();\n                  currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                } // If the scale of the object is negated then the triangle winding order\n                // needs to be flipped.\n\n\n                if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                  currentParseScope.inverted = !currentParseScope.inverted;\n                }\n\n                triangles = currentParseScope.triangles;\n                lineSegments = currentParseScope.lineSegments;\n                conditionalSegments = currentParseScope.conditionalSegments;\n                break;\n\n              case '!COLOUR':\n                material = this.parseColourMetaDirective(lp);\n\n                if (material) {\n                  this.addMaterial(material);\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          material = parseColourCode(lp);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (scope.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = scope.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            matrix: matrix,\n            fileName: fileName,\n            originalFileName: fileName,\n            locationState: FILE_LOCATION_AS_IS,\n            url: null,\n            triedLowerCase: false,\n            inverted: bfcInverted !== currentParseScope.inverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp)\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          material = parseColourCode(lp, true);\n          segment = {\n            material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n            colourCode: material.userData.code,\n            v0: parseVector(lp),\n            v1: parseVector(lp),\n            c0: parseVector(lp),\n            c1: parseVector(lp)\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n          } else {\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          material = parseColourCode(lp);\n          inverted = currentParseScope.inverted;\n          ccw = bfcCCW !== inverted;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = parseVector(lp);\n            v1 = parseVector(lp);\n            v2 = parseVector(lp);\n            v3 = parseVector(lp);\n          } else {\n            v3 = parseVector(lp);\n            v2 = parseVector(lp);\n            v1 = parseVector(lp);\n            v0 = parseVector(lp);\n          }\n\n          _tempVec0.subVectors(v1, v0);\n\n          _tempVec1.subVectors(v2, v1);\n\n          faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v1,\n            v2: v2,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n          triangles.push({\n            material: material,\n            colourCode: material.userData.code,\n            v0: v0,\n            v1: v2,\n            v2: v3,\n            faceNormal: faceNormal,\n            n0: null,\n            n1: null,\n            n2: null\n          });\n\n          if (doubleSided === true) {\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v1,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v3,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n          }\n\n          break;\n\n        default:\n          throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n    }\n\n    currentParseScope.category = category;\n    currentParseScope.keywords = keywords;\n    currentParseScope.subobjects = subobjects;\n    currentParseScope.numSubobjects = subobjects.length;\n    currentParseScope.subobjectIndex = 0;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n  processObject(text, onProcessed, subobject, url) {\n    const scope = this;\n    const parseScope = scope.newParseScopeLevel();\n    parseScope.url = url;\n    const parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n    if (subobject) {\n      parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n      parseScope.matrix.copy(subobject.matrix);\n      parseScope.inverted = subobject.inverted;\n      parseScope.startingConstructionStep = subobject.startingConstructionStep;\n    } // Add to cache\n\n\n    let currentFileName = parentParseScope.currentFileName;\n\n    if (currentFileName !== null) {\n      currentFileName = parentParseScope.currentFileName.toLowerCase();\n    }\n\n    if (scope.subobjectCache[currentFileName] === undefined) {\n      scope.subobjectCache[currentFileName] = text;\n    } // Parse the object (returns a Group)\n\n\n    scope.objectParse(text);\n    let finishedCount = 0;\n    onSubobjectFinish();\n\n    function onSubobjectFinish() {\n      finishedCount++;\n\n      if (finishedCount === parseScope.subobjects.length + 1) {\n        finalizeObject();\n      } else {\n        // Once the previous subobject has finished we can start processing the next one in the list.\n        // The subobject processing shares scope in processing so it's important that they be loaded serially\n        // to avoid race conditions.\n        // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n        // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n        // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n        const subobject = parseScope.subobjects[parseScope.subobjectIndex];\n        Promise.resolve().then(function () {\n          loadSubobject(subobject);\n        });\n        parseScope.subobjectIndex++;\n      }\n    }\n\n    function finalizeObject() {\n      if (scope.smoothNormals && parseScope.type === 'Part') {\n        smoothNormals(parseScope.triangles, parseScope.lineSegments);\n      }\n\n      const isRoot = !parentParseScope.isFromParse;\n\n      if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n        const objGroup = parseScope.groupObject;\n\n        if (parseScope.triangles.length > 0) {\n          objGroup.add(createObject(parseScope.triangles, 3));\n        }\n\n        if (parseScope.lineSegments.length > 0) {\n          objGroup.add(createObject(parseScope.lineSegments, 2));\n        }\n\n        if (parseScope.conditionalSegments.length > 0) {\n          objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n        }\n\n        if (parentParseScope.groupObject) {\n          objGroup.name = parseScope.fileName;\n          objGroup.userData.category = parseScope.category;\n          objGroup.userData.keywords = parseScope.keywords;\n          parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n          parentParseScope.groupObject.add(objGroup);\n        }\n      } else {\n        const separateObjects = scope.separateObjects;\n        const parentLineSegments = parentParseScope.lineSegments;\n        const parentConditionalSegments = parentParseScope.conditionalSegments;\n        const parentTriangles = parentParseScope.triangles;\n        const lineSegments = parseScope.lineSegments;\n        const conditionalSegments = parseScope.conditionalSegments;\n        const triangles = parseScope.triangles;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n\n          if (separateObjects) {\n            ls.v0.applyMatrix4(parseScope.matrix);\n            ls.v1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n\n          if (separateObjects) {\n            os.v0.applyMatrix4(parseScope.matrix);\n            os.v1.applyMatrix4(parseScope.matrix);\n            os.c0.applyMatrix4(parseScope.matrix);\n            os.c1.applyMatrix4(parseScope.matrix);\n          }\n\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = triangles.length; i < l; i++) {\n          const tri = triangles[i];\n\n          if (separateObjects) {\n            tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n            tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n            tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n\n            _tempVec0.subVectors(tri.v1, tri.v0);\n\n            _tempVec1.subVectors(tri.v2, tri.v1);\n\n            tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\n          }\n\n          parentTriangles.push(tri);\n        }\n      }\n\n      scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n      if (!parentParseScope.isFromParse) {\n        scope.computeConstructionSteps(parseScope.groupObject);\n      }\n\n      if (onProcessed) {\n        onProcessed(parseScope.groupObject);\n      }\n    }\n\n    function loadSubobject(subobject) {\n      parseScope.mainColourCode = subobject.material.userData.code;\n      parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n      parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n      const cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n      if (cached) {\n        scope.processObject(cached, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n        return;\n      } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n      // Update also subobject.locationState for the next try if this load fails.\n\n\n      let subobjectURL = subobject.fileName;\n      let newLocationState = FILE_LOCATION_NOT_FOUND;\n\n      switch (subobject.locationState) {\n        case FILE_LOCATION_AS_IS:\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n          newLocationState = subobject.locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (subobject.triedLowerCase) {\n            // Try absolute path\n            newLocationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            subobject.fileName = subobject.fileName.toLowerCase();\n            subobjectURL = subobject.fileName;\n            subobject.triedLowerCase = true;\n            newLocationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n\n        case FILE_LOCATION_NOT_FOUND:\n          // All location possibilities have been tried, give up loading this object\n          console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n          return;\n      }\n\n      subobject.locationState = newLocationState;\n      subobject.url = subobjectURL; // Load the subobject\n      // Use another file loader here so we can keep track of the subobject information\n      // and use it when processing the next model.\n\n      const fileLoader = new FileLoader(scope.manager);\n      fileLoader.setPath(scope.path);\n      fileLoader.setRequestHeader(scope.requestHeader);\n      fileLoader.setWithCredentials(scope.withCredentials);\n      fileLoader.load(subobjectURL, function (text) {\n        scope.processObject(text, function (subobjectGroup) {\n          onSubobjectLoaded(subobjectGroup, subobject);\n          onSubobjectFinish();\n        }, subobject, url);\n      }, undefined, function (err) {\n        onSubobjectError(err, subobject);\n      }, subobject);\n    }\n\n    function onSubobjectLoaded(subobjectGroup, subobject) {\n      if (subobjectGroup === null) {\n        // Try to reload\n        loadSubobject(subobject);\n        return;\n      }\n\n      scope.fileMap[subobject.originalFileName] = subobject.url;\n    }\n\n    function onSubobjectError(err, subobject) {\n      // Retry download from a different default possible location\n      loadSubobject(subobject);\n    }\n  }\n\n}\n\nexport { LDrawLoader };\n"]},"metadata":{},"sourceType":"module"}