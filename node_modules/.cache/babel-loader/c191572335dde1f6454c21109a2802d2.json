{"ast":null,"code":"import { BufferGeometry, Vector3, Matrix4, Float32BufferAttribute } from 'three';\n/**\n * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\n * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\n *\n * Constructor parameter:\n *\n * mesh — Any mesh object\n * position — Position of the decal projector\n * orientation — Orientation of the decal projector\n * size — Size of the decal projector\n *\n * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\n *\n */\n\nclass DecalGeometry extends BufferGeometry {\n  constructor(mesh, position, orientation, size) {\n    super(); // buffers\n\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helpers\n\n    const plane = new Vector3(); // this matrix represents the transformation of the decal projector\n\n    const projectorMatrix = new Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    const projectorMatrixInverse = new Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert(); // generate buffers\n\n    generate(); // build geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function generate() {\n      let i;\n      let decalVertices = [];\n      const vertex = new Vector3();\n      const normal = new Vector3(); // handle different geometry types\n\n      if (mesh.geometry.isGeometry === true) {\n        console.error('THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.');\n        return;\n      }\n\n      const geometry = mesh.geometry;\n      const positionAttribute = geometry.attributes.position;\n      const normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects\n      // three consecutive 'DecalVertex' objects represent a single face\n      //\n      // this data structure will be later used to perform the clipping\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        const index = geometry.index;\n\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        // non-indexed BufferGeometry\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } // second, clip the geometry so that it doesn't extend out from the projector\n\n\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1)); // third, generate final vertices, normals and uvs\n\n      for (i = 0; i < decalVertices.length; i++) {\n        const decalVertex = decalVertices[i]; // create texture coordinates (we are still in projector space)\n\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y); // transform the vertex back to world space\n\n        decalVertex.position.applyMatrix4(projectorMatrix); // now create vertex and normal buffer data\n\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      // transform the vertex to world space, then to projector space\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n\n    function clipGeometry(inVertices, plane) {\n      const outVertices = [];\n      const s = 0.5 * Math.abs(size.dot(plane)); // a single iteration clips one face,\n      // which consists of three consecutive 'DecalVertex' objects\n\n      for (let i = 0; i < inVertices.length; i += 3) {\n        let v1Out,\n            v2Out,\n            v3Out,\n            total = 0;\n        let nV1, nV2, nV3, nV4;\n        const d1 = inVertices[i + 0].position.dot(plane) - s;\n        const d2 = inVertices[i + 1].position.dot(plane) - s;\n        const d3 = inVertices[i + 2].position.dot(plane) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane\n\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n        switch (total) {\n          case 0:\n            {\n              // the entire face lies inside of the plane, no clipping needed\n              outVertices.push(inVertices[i]);\n              outVertices.push(inVertices[i + 1]);\n              outVertices.push(inVertices[i + 2]);\n              break;\n            }\n\n          case 1:\n            {\n              // one vertex lies outside of the plane, perform clipping\n              if (v1Out) {\n                nV1 = inVertices[i + 1];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i], nV1, plane, s);\n                nV4 = clip(inVertices[i], nV2, plane, s);\n              }\n\n              if (v2Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i + 1], nV1, plane, s);\n                nV4 = clip(inVertices[i + 1], nV2, plane, s);\n                outVertices.push(nV3);\n                outVertices.push(nV2.clone());\n                outVertices.push(nV1.clone());\n                outVertices.push(nV2.clone());\n                outVertices.push(nV3.clone());\n                outVertices.push(nV4);\n                break;\n              }\n\n              if (v3Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 1];\n                nV3 = clip(inVertices[i + 2], nV1, plane, s);\n                nV4 = clip(inVertices[i + 2], nV2, plane, s);\n              }\n\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3);\n              outVertices.push(nV4);\n              outVertices.push(nV3.clone());\n              outVertices.push(nV2.clone());\n              break;\n            }\n\n          case 2:\n            {\n              // two vertices lies outside of the plane, perform clipping\n              if (!v1Out) {\n                nV1 = inVertices[i].clone();\n                nV2 = clip(nV1, inVertices[i + 1], plane, s);\n                nV3 = clip(nV1, inVertices[i + 2], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v2Out) {\n                nV1 = inVertices[i + 1].clone();\n                nV2 = clip(nV1, inVertices[i + 2], plane, s);\n                nV3 = clip(nV1, inVertices[i], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v3Out) {\n                nV1 = inVertices[i + 2].clone();\n                nV2 = clip(nV1, inVertices[i], plane, s);\n                nV3 = clip(nV1, inVertices[i + 1], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return outVertices;\n    }\n\n    function clip(v0, v1, p, s) {\n      const d0 = v0.position.dot(p) - s;\n      const d1 = v1.position.dot(p) - s;\n      const s0 = d0 / (d0 - d1);\n      const v = new DecalVertex(new Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z))); // need to clip more values (texture coordinates)? do it this way:\n      // intersectpoint.value = a.value + s * ( b.value - a.value );\n\n      return v;\n    }\n  }\n\n} // helper\n\n\nclass DecalVertex {\n  constructor(position, normal) {\n    this.position = position;\n    this.normal = normal;\n  }\n\n  clone() {\n    return new this.constructor(this.position.clone(), this.normal.clone());\n  }\n\n}\n\nexport { DecalGeometry, DecalVertex };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/geometries/DecalGeometry.js"],"names":["BufferGeometry","Vector3","Matrix4","Float32BufferAttribute","DecalGeometry","constructor","mesh","position","orientation","size","vertices","normals","uvs","plane","projectorMatrix","makeRotationFromEuler","setPosition","projectorMatrixInverse","copy","invert","generate","setAttribute","i","decalVertices","vertex","normal","geometry","isGeometry","console","error","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","pushDecalVertex","clipGeometry","set","length","decalVertex","push","x","y","applyMatrix4","z","matrixWorld","transformDirection","DecalVertex","clone","inVertices","outVertices","s","Math","abs","dot","v1Out","v2Out","v3Out","total","nV1","nV2","nV3","nV4","d1","d2","d3","clip","v0","v1","p","d0","s0","v"],"mappings":"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","sourcesContent":["import { BufferGeometry, Vector3, Matrix4, Float32BufferAttribute } from 'three';\n\n/**\n * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\n * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\n *\n * Constructor parameter:\n *\n * mesh — Any mesh object\n * position — Position of the decal projector\n * orientation — Orientation of the decal projector\n * size — Size of the decal projector\n *\n * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\n *\n */\n\nclass DecalGeometry extends BufferGeometry {\n  constructor(mesh, position, orientation, size) {\n    super(); // buffers\n\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helpers\n\n    const plane = new Vector3(); // this matrix represents the transformation of the decal projector\n\n    const projectorMatrix = new Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    const projectorMatrixInverse = new Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert(); // generate buffers\n\n    generate(); // build geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function generate() {\n      let i;\n      let decalVertices = [];\n      const vertex = new Vector3();\n      const normal = new Vector3(); // handle different geometry types\n\n      if (mesh.geometry.isGeometry === true) {\n        console.error('THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.');\n        return;\n      }\n\n      const geometry = mesh.geometry;\n      const positionAttribute = geometry.attributes.position;\n      const normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects\n      // three consecutive 'DecalVertex' objects represent a single face\n      //\n      // this data structure will be later used to perform the clipping\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        const index = geometry.index;\n\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        // non-indexed BufferGeometry\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } // second, clip the geometry so that it doesn't extend out from the projector\n\n\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1)); // third, generate final vertices, normals and uvs\n\n      for (i = 0; i < decalVertices.length; i++) {\n        const decalVertex = decalVertices[i]; // create texture coordinates (we are still in projector space)\n\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y); // transform the vertex back to world space\n\n        decalVertex.position.applyMatrix4(projectorMatrix); // now create vertex and normal buffer data\n\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      // transform the vertex to world space, then to projector space\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n\n    function clipGeometry(inVertices, plane) {\n      const outVertices = [];\n      const s = 0.5 * Math.abs(size.dot(plane)); // a single iteration clips one face,\n      // which consists of three consecutive 'DecalVertex' objects\n\n      for (let i = 0; i < inVertices.length; i += 3) {\n        let v1Out,\n            v2Out,\n            v3Out,\n            total = 0;\n        let nV1, nV2, nV3, nV4;\n        const d1 = inVertices[i + 0].position.dot(plane) - s;\n        const d2 = inVertices[i + 1].position.dot(plane) - s;\n        const d3 = inVertices[i + 2].position.dot(plane) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane\n\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n        switch (total) {\n          case 0:\n            {\n              // the entire face lies inside of the plane, no clipping needed\n              outVertices.push(inVertices[i]);\n              outVertices.push(inVertices[i + 1]);\n              outVertices.push(inVertices[i + 2]);\n              break;\n            }\n\n          case 1:\n            {\n              // one vertex lies outside of the plane, perform clipping\n              if (v1Out) {\n                nV1 = inVertices[i + 1];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i], nV1, plane, s);\n                nV4 = clip(inVertices[i], nV2, plane, s);\n              }\n\n              if (v2Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i + 1], nV1, plane, s);\n                nV4 = clip(inVertices[i + 1], nV2, plane, s);\n                outVertices.push(nV3);\n                outVertices.push(nV2.clone());\n                outVertices.push(nV1.clone());\n                outVertices.push(nV2.clone());\n                outVertices.push(nV3.clone());\n                outVertices.push(nV4);\n                break;\n              }\n\n              if (v3Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 1];\n                nV3 = clip(inVertices[i + 2], nV1, plane, s);\n                nV4 = clip(inVertices[i + 2], nV2, plane, s);\n              }\n\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3);\n              outVertices.push(nV4);\n              outVertices.push(nV3.clone());\n              outVertices.push(nV2.clone());\n              break;\n            }\n\n          case 2:\n            {\n              // two vertices lies outside of the plane, perform clipping\n              if (!v1Out) {\n                nV1 = inVertices[i].clone();\n                nV2 = clip(nV1, inVertices[i + 1], plane, s);\n                nV3 = clip(nV1, inVertices[i + 2], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v2Out) {\n                nV1 = inVertices[i + 1].clone();\n                nV2 = clip(nV1, inVertices[i + 2], plane, s);\n                nV3 = clip(nV1, inVertices[i], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v3Out) {\n                nV1 = inVertices[i + 2].clone();\n                nV2 = clip(nV1, inVertices[i], plane, s);\n                nV3 = clip(nV1, inVertices[i + 1], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return outVertices;\n    }\n\n    function clip(v0, v1, p, s) {\n      const d0 = v0.position.dot(p) - s;\n      const d1 = v1.position.dot(p) - s;\n      const s0 = d0 / (d0 - d1);\n      const v = new DecalVertex(new Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z))); // need to clip more values (texture coordinates)? do it this way:\n      // intersectpoint.value = a.value + s * ( b.value - a.value );\n\n      return v;\n    }\n  }\n\n} // helper\n\n\nclass DecalVertex {\n  constructor(position, normal) {\n    this.position = position;\n    this.normal = normal;\n  }\n\n  clone() {\n    return new this.constructor(this.position.clone(), this.normal.clone());\n  }\n\n}\n\nexport { DecalGeometry, DecalVertex };\n"]},"metadata":{},"sourceType":"module"}