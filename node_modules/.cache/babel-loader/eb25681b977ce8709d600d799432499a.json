{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Group, MeshPhongMaterial, DoubleSide, AdditiveBlending, BufferGeometry, Mesh, Float32BufferAttribute, Matrix4, TextureLoader, Color } from 'three';\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.debug = false;\n    this.group = null;\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n  }\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  /**\n   * Parse arraybuffer data and load 3ds file.\n   *\n   * @method parse\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   * @return {Group} Group loaded from 3ds file.\n   */\n\n\n  parse(arraybuffer, path) {\n    this.group = new Group();\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n    this.readFile(arraybuffer, path);\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i]);\n    }\n\n    return this.group;\n  }\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @method readFile\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   */\n\n\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer);\n    const chunk = this.readChunk(data);\n\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = this.nextChunk(data, chunk);\n\n      while (next !== 0) {\n        if (next === M3D_VERSION) {\n          const version = this.readDWord(data);\n          this.debugMessage('3DS file version: ' + version);\n        } else if (next === MDATA) {\n          this.resetPosition(data);\n          this.readMeshData(data, path);\n        } else {\n          this.debugMessage('Unknown main chunk: ' + next.toString(16));\n        }\n\n        next = this.nextChunk(data, chunk);\n      }\n    }\n\n    this.debugMessage('Parsed ' + this.meshes.length + ' meshes');\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMeshData\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n\n\n  readMeshData(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n\n    while (next !== 0) {\n      if (next === MESH_VERSION) {\n        const version = +this.readDWord(data);\n        this.debugMessage('Mesh Version: ' + version);\n      } else if (next === MASTER_SCALE) {\n        const scale = this.readFloat(data);\n        this.debugMessage('Master scale: ' + scale);\n        this.group.scale.set(scale, scale, scale);\n      } else if (next === NAMED_OBJECT) {\n        this.debugMessage('Named Object');\n        this.resetPosition(data);\n        this.readNamedObject(data);\n      } else if (next === MAT_ENTRY) {\n        this.debugMessage('Material');\n        this.resetPosition(data);\n        this.readMaterialEntry(data, path);\n      } else {\n        this.debugMessage('Unknown MDATA chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n  }\n  /**\n   * Read named object chunk.\n   *\n   * @method readNamedObject\n   * @param {Dataview} data Dataview in use.\n   */\n\n\n  readNamedObject(data) {\n    const chunk = this.readChunk(data);\n    const name = this.readString(data, 64);\n    chunk.cur = this.position;\n    let next = this.nextChunk(data, chunk);\n\n    while (next !== 0) {\n      if (next === N_TRI_OBJECT) {\n        this.resetPosition(data);\n        const mesh = this.readMesh(data);\n        mesh.name = name;\n        this.meshes.push(mesh);\n      } else {\n        this.debugMessage('Unknown named object chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n  }\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @method readMaterialEntry\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n\n\n  readMaterialEntry(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const material = new MeshPhongMaterial();\n\n    while (next !== 0) {\n      if (next === MAT_NAME) {\n        material.name = this.readString(data, 64);\n        this.debugMessage('   Name: ' + material.name);\n      } else if (next === MAT_WIRE) {\n        this.debugMessage('   Wireframe');\n        material.wireframe = true;\n      } else if (next === MAT_WIRE_SIZE) {\n        const value = this.readByte(data);\n        material.wireframeLinewidth = value;\n        this.debugMessage('   Wireframe Thickness: ' + value);\n      } else if (next === MAT_TWO_SIDE) {\n        material.side = DoubleSide;\n        this.debugMessage('   DoubleSided');\n      } else if (next === MAT_ADDITIVE) {\n        this.debugMessage('   Additive Blending');\n        material.blending = AdditiveBlending;\n      } else if (next === MAT_DIFFUSE) {\n        this.debugMessage('   Diffuse Color');\n        material.color = this.readColor(data);\n      } else if (next === MAT_SPECULAR) {\n        this.debugMessage('   Specular Color');\n        material.specular = this.readColor(data);\n      } else if (next === MAT_AMBIENT) {\n        this.debugMessage('   Ambient color');\n        material.color = this.readColor(data);\n      } else if (next === MAT_SHININESS) {\n        const shininess = this.readPercentage(data);\n        material.shininess = shininess * 100;\n        this.debugMessage('   Shininess : ' + shininess);\n      } else if (next === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(data);\n        material.opacity = 1 - transparency;\n        this.debugMessage('  Transparency : ' + transparency);\n        material.transparent = material.opacity < 1 ? true : false;\n      } else if (next === MAT_TEXMAP) {\n        this.debugMessage('   ColorMap');\n        this.resetPosition(data);\n        material.map = this.readMap(data, path);\n      } else if (next === MAT_BUMPMAP) {\n        this.debugMessage('   BumpMap');\n        this.resetPosition(data);\n        material.bumpMap = this.readMap(data, path);\n      } else if (next === MAT_OPACMAP) {\n        this.debugMessage('   OpacityMap');\n        this.resetPosition(data);\n        material.alphaMap = this.readMap(data, path);\n      } else if (next === MAT_SPECMAP) {\n        this.debugMessage('   SpecularMap');\n        this.resetPosition(data);\n        material.specularMap = this.readMap(data, path);\n      } else {\n        this.debugMessage('   Unknown material chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n    this.materials[material.name] = material;\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMesh\n   * @param {Dataview} data Dataview in use.\n   * @return {Mesh} The parsed mesh.\n   */\n\n\n  readMesh(data) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const geometry = new BufferGeometry();\n    const material = new MeshPhongMaterial();\n    const mesh = new Mesh(geometry, material);\n    mesh.name = 'mesh';\n\n    while (next !== 0) {\n      if (next === POINT_ARRAY) {\n        const points = this.readWord(data);\n        this.debugMessage('   Vertex: ' + points); //BufferGeometry\n\n        const vertices = [];\n\n        for (let i = 0; i < points; i++) {\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n      } else if (next === FACE_ARRAY) {\n        this.resetPosition(data);\n        this.readFaceArray(data, mesh);\n      } else if (next === TEX_VERTS) {\n        const texels = this.readWord(data);\n        this.debugMessage('   UV: ' + texels); //BufferGeometry\n\n        const uvs = [];\n\n        for (let i = 0; i < texels; i++) {\n          uvs.push(this.readFloat(data));\n          uvs.push(this.readFloat(data));\n        }\n\n        geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n      } else if (next === MESH_MATRIX) {\n        this.debugMessage('   Tranformation Matrix (TODO)');\n        const values = [];\n\n        for (let i = 0; i < 12; i++) {\n          values[i] = this.readFloat(data);\n        }\n\n        const matrix = new Matrix4(); //X Line\n\n        matrix.elements[0] = values[0];\n        matrix.elements[1] = values[6];\n        matrix.elements[2] = values[3];\n        matrix.elements[3] = values[9]; //Y Line\n\n        matrix.elements[4] = values[2];\n        matrix.elements[5] = values[8];\n        matrix.elements[6] = values[5];\n        matrix.elements[7] = values[11]; //Z Line\n\n        matrix.elements[8] = values[1];\n        matrix.elements[9] = values[7];\n        matrix.elements[10] = values[4];\n        matrix.elements[11] = values[10]; //W Line\n\n        matrix.elements[12] = 0;\n        matrix.elements[13] = 0;\n        matrix.elements[14] = 0;\n        matrix.elements[15] = 1;\n        matrix.transpose();\n        const inverse = new Matrix4();\n        inverse.copy(matrix).invert();\n        geometry.applyMatrix4(inverse);\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n      } else {\n        this.debugMessage('   Unknown mesh chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n    geometry.computeVertexNormals();\n    return mesh;\n  }\n  /**\n   * Read face array data chunk.\n   *\n   * @method readFaceArray\n   * @param {Dataview} data Dataview in use.\n   * @param {Mesh} mesh Mesh to be filled with the data read.\n   */\n\n\n  readFaceArray(data, mesh) {\n    const chunk = this.readChunk(data);\n    const faces = this.readWord(data);\n    this.debugMessage('   Faces: ' + faces);\n    const index = [];\n\n    for (let i = 0; i < faces; ++i) {\n      index.push(this.readWord(data), this.readWord(data), this.readWord(data));\n      this.readWord(data); // visibility\n    }\n\n    mesh.geometry.setIndex(index); //The rest of the FACE_ARRAY chunk is subchunks\n\n    let materialIndex = 0;\n    let start = 0;\n\n    while (this.position < chunk.end) {\n      const subchunk = this.readChunk(data);\n\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage('      Material Group');\n        this.resetPosition(data);\n        const group = this.readMaterialGroup(data);\n        const count = group.index.length * 3; // assuming successive indices\n\n        mesh.geometry.addGroup(start, count, materialIndex);\n        start += count;\n        materialIndex++;\n        const material = this.materials[group.name];\n        if (Array.isArray(mesh.material) === false) mesh.material = [];\n\n        if (material !== undefined) {\n          mesh.material.push(material);\n        }\n      } else {\n        this.debugMessage('      Unknown face array chunk: ' + subchunk.toString(16));\n      }\n\n      this.endChunk(subchunk);\n    }\n\n    if (mesh.material.length === 1) mesh.material = mesh.material[0]; // for backwards compatibility\n\n    this.endChunk(chunk);\n  }\n  /**\n   * Read texture map data chunk.\n   *\n   * @method readMap\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n\n\n  readMap(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    let texture = {};\n    const loader = new TextureLoader(this.manager);\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n\n    while (next !== 0) {\n      if (next === MAT_MAPNAME) {\n        const name = this.readString(data, 128);\n        texture = loader.load(name);\n        this.debugMessage('      File: ' + path + name);\n      } else if (next === MAT_MAP_UOFFSET) {\n        texture.offset.x = this.readFloat(data);\n        this.debugMessage('      OffsetX: ' + texture.offset.x);\n      } else if (next === MAT_MAP_VOFFSET) {\n        texture.offset.y = this.readFloat(data);\n        this.debugMessage('      OffsetY: ' + texture.offset.y);\n      } else if (next === MAT_MAP_USCALE) {\n        texture.repeat.x = this.readFloat(data);\n        this.debugMessage('      RepeatX: ' + texture.repeat.x);\n      } else if (next === MAT_MAP_VSCALE) {\n        texture.repeat.y = this.readFloat(data);\n        this.debugMessage('      RepeatY: ' + texture.repeat.y);\n      } else {\n        this.debugMessage('      Unknown map chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n    return texture;\n  }\n  /**\n   * Read material group data chunk.\n   *\n   * @method readMaterialGroup\n   * @param {Dataview} data Dataview in use.\n   * @return {Object} Object with name and index of the object.\n   */\n\n\n  readMaterialGroup(data) {\n    this.readChunk(data);\n    const name = this.readString(data, 64);\n    const numFaces = this.readWord(data);\n    this.debugMessage('         Name: ' + name);\n    this.debugMessage('         Faces: ' + numFaces);\n    const index = [];\n\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(this.readWord(data));\n    }\n\n    return {\n      name: name,\n      index: index\n    };\n  }\n  /**\n   * Read a color value.\n   *\n   * @method readColor\n   * @param {DataView} data Dataview.\n   * @return {Color} Color value read..\n   */\n\n\n  readColor(data) {\n    const chunk = this.readChunk(data);\n    const color = new Color();\n\n    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n      const r = this.readByte(data);\n      const g = this.readByte(data);\n      const b = this.readByte(data);\n      color.setRGB(r / 255, g / 255, b / 255);\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n      const r = this.readFloat(data);\n      const g = this.readFloat(data);\n      const b = this.readFloat(data);\n      color.setRGB(r, g, b);\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n    } else {\n      this.debugMessage('      Unknown color chunk: ' + chunk.toString(16));\n    }\n\n    this.endChunk(chunk);\n    return color;\n  }\n  /**\n   * Read next chunk of data.\n   *\n   * @method readChunk\n   * @param {DataView} data Dataview.\n   * @return {Object} Chunk of data read.\n   */\n\n\n  readChunk(data) {\n    const chunk = {};\n    chunk.cur = this.position;\n    chunk.id = this.readWord(data);\n    chunk.size = this.readDWord(data);\n    chunk.end = chunk.cur + chunk.size;\n    chunk.cur += 6;\n    return chunk;\n  }\n  /**\n   * Set position to the end of the current chunk of data.\n   *\n   * @method endChunk\n   * @param {Object} chunk Data chunk.\n   */\n\n\n  endChunk(chunk) {\n    this.position = chunk.end;\n  }\n  /**\n   * Move to the next data chunk.\n   *\n   * @method nextChunk\n   * @param {DataView} data Dataview.\n   * @param {Object} chunk Data chunk.\n   */\n\n\n  nextChunk(data, chunk) {\n    if (chunk.cur >= chunk.end) {\n      return 0;\n    }\n\n    this.position = chunk.cur;\n\n    try {\n      const next = this.readChunk(data);\n      chunk.cur += next.size;\n      return next.id;\n    } catch (e) {\n      this.debugMessage('Unable to read chunk at ' + this.position);\n      return 0;\n    }\n  }\n  /**\n   * Reset dataview position.\n   *\n   * @method resetPosition\n   */\n\n\n  resetPosition() {\n    this.position -= 6;\n  }\n  /**\n   * Read byte value.\n   *\n   * @method readByte\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readByte(data) {\n    const v = data.getUint8(this.position, true);\n    this.position += 1;\n    return v;\n  }\n  /**\n   * Read 32 bit float value.\n   *\n   * @method readFloat\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readFloat(data) {\n    try {\n      const v = data.getFloat32(this.position, true);\n      this.position += 4;\n      return v;\n    } catch (e) {\n      this.debugMessage(e + ' ' + this.position + ' ' + data.byteLength);\n    }\n  }\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @method readInt\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readInt(data) {\n    const v = data.getInt32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @method readShort\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readShort(data) {\n    const v = data.getInt16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @method readDWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readDWord(data) {\n    const v = data.getUint32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @method readWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readWord(data) {\n    const v = data.getUint16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read string value.\n   *\n   * @method readString\n   * @param {DataView} data Dataview to read data from.\n   * @param {Number} maxLength Max size of the string to be read.\n   * @return {String} Data read from the dataview.\n   */\n\n\n  readString(data, maxLength) {\n    let s = '';\n\n    for (let i = 0; i < maxLength; i++) {\n      const c = this.readByte(data);\n\n      if (!c) {\n        break;\n      }\n\n      s += String.fromCharCode(c);\n    }\n\n    return s;\n  }\n  /**\n   * Read percentage value.\n   *\n   * @method readPercentage\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readPercentage(data) {\n    const chunk = this.readChunk(data);\n    let value;\n\n    switch (chunk.id) {\n      case INT_PERCENTAGE:\n        value = this.readShort(data) / 100;\n        break;\n\n      case FLOAT_PERCENTAGE:\n        value = this.readFloat(data);\n        break;\n\n      default:\n        this.debugMessage('      Unknown percentage chunk: ' + chunk.toString(16));\n    }\n\n    this.endChunk(chunk);\n    return value;\n  }\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @method debugMessage\n   * @param {Object} message Debug message to print to the console.\n   */\n\n\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message);\n    }\n  }\n\n} // const NULL_CHUNK = 0x0000;\n\n\nconst M3DMAGIC = 0x4d4d; // const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\n\nconst MLIBMAGIC = 0x3daa; // const MATMAGIC = 0x3DFF;\n\nconst CMAGIC = 0xc23d;\nconst M3D_VERSION = 0x0002; // const M3D_KFVERSION = 0x0005;\n\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3d3d;\nconst MESH_VERSION = 0x3d3e;\nconst MASTER_SCALE = 0x0100; // const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\n\nconst MAT_ENTRY = 0xafff;\nconst MAT_NAME = 0xa000;\nconst MAT_AMBIENT = 0xa010;\nconst MAT_DIFFUSE = 0xa020;\nconst MAT_SPECULAR = 0xa030;\nconst MAT_SHININESS = 0xa040; // const MAT_SHIN2PCT = 0xA041;\n\nconst MAT_TRANSPARENCY = 0xa050; // const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\n\nconst MAT_TWO_SIDE = 0xa081; // const MAT_DECAL = 0xA082;\n\nconst MAT_ADDITIVE = 0xa083;\nconst MAT_WIRE = 0xa085; // const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\n\nconst MAT_WIRE_SIZE = 0xa087;\nconst MAT_TEXMAP = 0xa200; // const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\n\nconst MAT_OPACMAP = 0xa210; // const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\n\nconst MAT_BUMPMAP = 0xa230; // const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\n\nconst MAT_SPECMAP = 0xa204; // const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\n\nconst MAT_MAPNAME = 0xa300; // const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\n\nconst MAT_MAP_USCALE = 0xa354;\nconst MAT_MAP_VSCALE = 0xa356;\nconst MAT_MAP_UOFFSET = 0xa358;\nconst MAT_MAP_VOFFSET = 0xa35a; // const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\n\nconst NAMED_OBJECT = 0x4000; // const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\n\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110; // const POINT_FLAG_ARRAY = 0x4111;\n\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130; // const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\n\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160; // const MESH_COLOR = 0x4165;\n\nexport { TDSLoader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/loaders/TDSLoader.js"],"names":["Loader","LoaderUtils","FileLoader","Group","MeshPhongMaterial","DoubleSide","AdditiveBlending","BufferGeometry","Mesh","Float32BufferAttribute","Matrix4","TextureLoader","Color","TDSLoader","constructor","manager","debug","group","position","materials","meshes","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","arraybuffer","readFile","i","length","add","DataView","chunk","readChunk","id","MLIBMAGIC","CMAGIC","M3DMAGIC","next","nextChunk","M3D_VERSION","version","readDWord","debugMessage","MDATA","resetPosition","readMeshData","toString","MESH_VERSION","MASTER_SCALE","scale","readFloat","set","NAMED_OBJECT","readNamedObject","MAT_ENTRY","readMaterialEntry","name","readString","cur","N_TRI_OBJECT","mesh","readMesh","push","endChunk","material","MAT_NAME","MAT_WIRE","wireframe","MAT_WIRE_SIZE","value","readByte","wireframeLinewidth","MAT_TWO_SIDE","side","MAT_ADDITIVE","blending","MAT_DIFFUSE","color","readColor","MAT_SPECULAR","specular","MAT_AMBIENT","MAT_SHININESS","shininess","readPercentage","MAT_TRANSPARENCY","transparency","opacity","transparent","MAT_TEXMAP","map","readMap","MAT_BUMPMAP","bumpMap","MAT_OPACMAP","alphaMap","MAT_SPECMAP","specularMap","geometry","POINT_ARRAY","points","readWord","vertices","setAttribute","FACE_ARRAY","readFaceArray","TEX_VERTS","texels","uvs","MESH_MATRIX","values","matrix","elements","transpose","inverse","copy","invert","applyMatrix4","decompose","quaternion","computeVertexNormals","faces","index","setIndex","materialIndex","start","end","subchunk","MSH_MAT_GROUP","readMaterialGroup","count","addGroup","Array","isArray","undefined","texture","resourcePath","setCrossOrigin","crossOrigin","MAT_MAPNAME","MAT_MAP_UOFFSET","offset","x","MAT_MAP_VOFFSET","y","MAT_MAP_USCALE","repeat","MAT_MAP_VSCALE","numFaces","COLOR_24","LIN_COLOR_24","r","g","b","setRGB","COLOR_F","LIN_COLOR_F","size","v","getUint8","getFloat32","byteLength","readInt","getInt32","readShort","getInt16","getUint32","getUint16","maxLength","s","c","String","fromCharCode","INT_PERCENTAGE","FLOAT_PERCENTAGE","message","log"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, Group, MeshPhongMaterial, DoubleSide, AdditiveBlending, BufferGeometry, Mesh, Float32BufferAttribute, Matrix4, TextureLoader, Color } from 'three';\n\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.debug = false;\n    this.group = null;\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n  }\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  /**\n   * Parse arraybuffer data and load 3ds file.\n   *\n   * @method parse\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   * @return {Group} Group loaded from 3ds file.\n   */\n\n\n  parse(arraybuffer, path) {\n    this.group = new Group();\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n    this.readFile(arraybuffer, path);\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i]);\n    }\n\n    return this.group;\n  }\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @method readFile\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   */\n\n\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer);\n    const chunk = this.readChunk(data);\n\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = this.nextChunk(data, chunk);\n\n      while (next !== 0) {\n        if (next === M3D_VERSION) {\n          const version = this.readDWord(data);\n          this.debugMessage('3DS file version: ' + version);\n        } else if (next === MDATA) {\n          this.resetPosition(data);\n          this.readMeshData(data, path);\n        } else {\n          this.debugMessage('Unknown main chunk: ' + next.toString(16));\n        }\n\n        next = this.nextChunk(data, chunk);\n      }\n    }\n\n    this.debugMessage('Parsed ' + this.meshes.length + ' meshes');\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMeshData\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n\n\n  readMeshData(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n\n    while (next !== 0) {\n      if (next === MESH_VERSION) {\n        const version = +this.readDWord(data);\n        this.debugMessage('Mesh Version: ' + version);\n      } else if (next === MASTER_SCALE) {\n        const scale = this.readFloat(data);\n        this.debugMessage('Master scale: ' + scale);\n        this.group.scale.set(scale, scale, scale);\n      } else if (next === NAMED_OBJECT) {\n        this.debugMessage('Named Object');\n        this.resetPosition(data);\n        this.readNamedObject(data);\n      } else if (next === MAT_ENTRY) {\n        this.debugMessage('Material');\n        this.resetPosition(data);\n        this.readMaterialEntry(data, path);\n      } else {\n        this.debugMessage('Unknown MDATA chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n  }\n  /**\n   * Read named object chunk.\n   *\n   * @method readNamedObject\n   * @param {Dataview} data Dataview in use.\n   */\n\n\n  readNamedObject(data) {\n    const chunk = this.readChunk(data);\n    const name = this.readString(data, 64);\n    chunk.cur = this.position;\n    let next = this.nextChunk(data, chunk);\n\n    while (next !== 0) {\n      if (next === N_TRI_OBJECT) {\n        this.resetPosition(data);\n        const mesh = this.readMesh(data);\n        mesh.name = name;\n        this.meshes.push(mesh);\n      } else {\n        this.debugMessage('Unknown named object chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n  }\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @method readMaterialEntry\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n\n\n  readMaterialEntry(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const material = new MeshPhongMaterial();\n\n    while (next !== 0) {\n      if (next === MAT_NAME) {\n        material.name = this.readString(data, 64);\n        this.debugMessage('   Name: ' + material.name);\n      } else if (next === MAT_WIRE) {\n        this.debugMessage('   Wireframe');\n        material.wireframe = true;\n      } else if (next === MAT_WIRE_SIZE) {\n        const value = this.readByte(data);\n        material.wireframeLinewidth = value;\n        this.debugMessage('   Wireframe Thickness: ' + value);\n      } else if (next === MAT_TWO_SIDE) {\n        material.side = DoubleSide;\n        this.debugMessage('   DoubleSided');\n      } else if (next === MAT_ADDITIVE) {\n        this.debugMessage('   Additive Blending');\n        material.blending = AdditiveBlending;\n      } else if (next === MAT_DIFFUSE) {\n        this.debugMessage('   Diffuse Color');\n        material.color = this.readColor(data);\n      } else if (next === MAT_SPECULAR) {\n        this.debugMessage('   Specular Color');\n        material.specular = this.readColor(data);\n      } else if (next === MAT_AMBIENT) {\n        this.debugMessage('   Ambient color');\n        material.color = this.readColor(data);\n      } else if (next === MAT_SHININESS) {\n        const shininess = this.readPercentage(data);\n        material.shininess = shininess * 100;\n        this.debugMessage('   Shininess : ' + shininess);\n      } else if (next === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(data);\n        material.opacity = 1 - transparency;\n        this.debugMessage('  Transparency : ' + transparency);\n        material.transparent = material.opacity < 1 ? true : false;\n      } else if (next === MAT_TEXMAP) {\n        this.debugMessage('   ColorMap');\n        this.resetPosition(data);\n        material.map = this.readMap(data, path);\n      } else if (next === MAT_BUMPMAP) {\n        this.debugMessage('   BumpMap');\n        this.resetPosition(data);\n        material.bumpMap = this.readMap(data, path);\n      } else if (next === MAT_OPACMAP) {\n        this.debugMessage('   OpacityMap');\n        this.resetPosition(data);\n        material.alphaMap = this.readMap(data, path);\n      } else if (next === MAT_SPECMAP) {\n        this.debugMessage('   SpecularMap');\n        this.resetPosition(data);\n        material.specularMap = this.readMap(data, path);\n      } else {\n        this.debugMessage('   Unknown material chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n    this.materials[material.name] = material;\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMesh\n   * @param {Dataview} data Dataview in use.\n   * @return {Mesh} The parsed mesh.\n   */\n\n\n  readMesh(data) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const geometry = new BufferGeometry();\n    const material = new MeshPhongMaterial();\n    const mesh = new Mesh(geometry, material);\n    mesh.name = 'mesh';\n\n    while (next !== 0) {\n      if (next === POINT_ARRAY) {\n        const points = this.readWord(data);\n        this.debugMessage('   Vertex: ' + points); //BufferGeometry\n\n        const vertices = [];\n\n        for (let i = 0; i < points; i++) {\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n      } else if (next === FACE_ARRAY) {\n        this.resetPosition(data);\n        this.readFaceArray(data, mesh);\n      } else if (next === TEX_VERTS) {\n        const texels = this.readWord(data);\n        this.debugMessage('   UV: ' + texels); //BufferGeometry\n\n        const uvs = [];\n\n        for (let i = 0; i < texels; i++) {\n          uvs.push(this.readFloat(data));\n          uvs.push(this.readFloat(data));\n        }\n\n        geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n      } else if (next === MESH_MATRIX) {\n        this.debugMessage('   Tranformation Matrix (TODO)');\n        const values = [];\n\n        for (let i = 0; i < 12; i++) {\n          values[i] = this.readFloat(data);\n        }\n\n        const matrix = new Matrix4(); //X Line\n\n        matrix.elements[0] = values[0];\n        matrix.elements[1] = values[6];\n        matrix.elements[2] = values[3];\n        matrix.elements[3] = values[9]; //Y Line\n\n        matrix.elements[4] = values[2];\n        matrix.elements[5] = values[8];\n        matrix.elements[6] = values[5];\n        matrix.elements[7] = values[11]; //Z Line\n\n        matrix.elements[8] = values[1];\n        matrix.elements[9] = values[7];\n        matrix.elements[10] = values[4];\n        matrix.elements[11] = values[10]; //W Line\n\n        matrix.elements[12] = 0;\n        matrix.elements[13] = 0;\n        matrix.elements[14] = 0;\n        matrix.elements[15] = 1;\n        matrix.transpose();\n        const inverse = new Matrix4();\n        inverse.copy(matrix).invert();\n        geometry.applyMatrix4(inverse);\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n      } else {\n        this.debugMessage('   Unknown mesh chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n    geometry.computeVertexNormals();\n    return mesh;\n  }\n  /**\n   * Read face array data chunk.\n   *\n   * @method readFaceArray\n   * @param {Dataview} data Dataview in use.\n   * @param {Mesh} mesh Mesh to be filled with the data read.\n   */\n\n\n  readFaceArray(data, mesh) {\n    const chunk = this.readChunk(data);\n    const faces = this.readWord(data);\n    this.debugMessage('   Faces: ' + faces);\n    const index = [];\n\n    for (let i = 0; i < faces; ++i) {\n      index.push(this.readWord(data), this.readWord(data), this.readWord(data));\n      this.readWord(data); // visibility\n    }\n\n    mesh.geometry.setIndex(index); //The rest of the FACE_ARRAY chunk is subchunks\n\n    let materialIndex = 0;\n    let start = 0;\n\n    while (this.position < chunk.end) {\n      const subchunk = this.readChunk(data);\n\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage('      Material Group');\n        this.resetPosition(data);\n        const group = this.readMaterialGroup(data);\n        const count = group.index.length * 3; // assuming successive indices\n\n        mesh.geometry.addGroup(start, count, materialIndex);\n        start += count;\n        materialIndex++;\n        const material = this.materials[group.name];\n        if (Array.isArray(mesh.material) === false) mesh.material = [];\n\n        if (material !== undefined) {\n          mesh.material.push(material);\n        }\n      } else {\n        this.debugMessage('      Unknown face array chunk: ' + subchunk.toString(16));\n      }\n\n      this.endChunk(subchunk);\n    }\n\n    if (mesh.material.length === 1) mesh.material = mesh.material[0]; // for backwards compatibility\n\n    this.endChunk(chunk);\n  }\n  /**\n   * Read texture map data chunk.\n   *\n   * @method readMap\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n\n\n  readMap(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    let texture = {};\n    const loader = new TextureLoader(this.manager);\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n\n    while (next !== 0) {\n      if (next === MAT_MAPNAME) {\n        const name = this.readString(data, 128);\n        texture = loader.load(name);\n        this.debugMessage('      File: ' + path + name);\n      } else if (next === MAT_MAP_UOFFSET) {\n        texture.offset.x = this.readFloat(data);\n        this.debugMessage('      OffsetX: ' + texture.offset.x);\n      } else if (next === MAT_MAP_VOFFSET) {\n        texture.offset.y = this.readFloat(data);\n        this.debugMessage('      OffsetY: ' + texture.offset.y);\n      } else if (next === MAT_MAP_USCALE) {\n        texture.repeat.x = this.readFloat(data);\n        this.debugMessage('      RepeatX: ' + texture.repeat.x);\n      } else if (next === MAT_MAP_VSCALE) {\n        texture.repeat.y = this.readFloat(data);\n        this.debugMessage('      RepeatY: ' + texture.repeat.y);\n      } else {\n        this.debugMessage('      Unknown map chunk: ' + next.toString(16));\n      }\n\n      next = this.nextChunk(data, chunk);\n    }\n\n    this.endChunk(chunk);\n    return texture;\n  }\n  /**\n   * Read material group data chunk.\n   *\n   * @method readMaterialGroup\n   * @param {Dataview} data Dataview in use.\n   * @return {Object} Object with name and index of the object.\n   */\n\n\n  readMaterialGroup(data) {\n    this.readChunk(data);\n    const name = this.readString(data, 64);\n    const numFaces = this.readWord(data);\n    this.debugMessage('         Name: ' + name);\n    this.debugMessage('         Faces: ' + numFaces);\n    const index = [];\n\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(this.readWord(data));\n    }\n\n    return {\n      name: name,\n      index: index\n    };\n  }\n  /**\n   * Read a color value.\n   *\n   * @method readColor\n   * @param {DataView} data Dataview.\n   * @return {Color} Color value read..\n   */\n\n\n  readColor(data) {\n    const chunk = this.readChunk(data);\n    const color = new Color();\n\n    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n      const r = this.readByte(data);\n      const g = this.readByte(data);\n      const b = this.readByte(data);\n      color.setRGB(r / 255, g / 255, b / 255);\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n      const r = this.readFloat(data);\n      const g = this.readFloat(data);\n      const b = this.readFloat(data);\n      color.setRGB(r, g, b);\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n    } else {\n      this.debugMessage('      Unknown color chunk: ' + chunk.toString(16));\n    }\n\n    this.endChunk(chunk);\n    return color;\n  }\n  /**\n   * Read next chunk of data.\n   *\n   * @method readChunk\n   * @param {DataView} data Dataview.\n   * @return {Object} Chunk of data read.\n   */\n\n\n  readChunk(data) {\n    const chunk = {};\n    chunk.cur = this.position;\n    chunk.id = this.readWord(data);\n    chunk.size = this.readDWord(data);\n    chunk.end = chunk.cur + chunk.size;\n    chunk.cur += 6;\n    return chunk;\n  }\n  /**\n   * Set position to the end of the current chunk of data.\n   *\n   * @method endChunk\n   * @param {Object} chunk Data chunk.\n   */\n\n\n  endChunk(chunk) {\n    this.position = chunk.end;\n  }\n  /**\n   * Move to the next data chunk.\n   *\n   * @method nextChunk\n   * @param {DataView} data Dataview.\n   * @param {Object} chunk Data chunk.\n   */\n\n\n  nextChunk(data, chunk) {\n    if (chunk.cur >= chunk.end) {\n      return 0;\n    }\n\n    this.position = chunk.cur;\n\n    try {\n      const next = this.readChunk(data);\n      chunk.cur += next.size;\n      return next.id;\n    } catch (e) {\n      this.debugMessage('Unable to read chunk at ' + this.position);\n      return 0;\n    }\n  }\n  /**\n   * Reset dataview position.\n   *\n   * @method resetPosition\n   */\n\n\n  resetPosition() {\n    this.position -= 6;\n  }\n  /**\n   * Read byte value.\n   *\n   * @method readByte\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readByte(data) {\n    const v = data.getUint8(this.position, true);\n    this.position += 1;\n    return v;\n  }\n  /**\n   * Read 32 bit float value.\n   *\n   * @method readFloat\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readFloat(data) {\n    try {\n      const v = data.getFloat32(this.position, true);\n      this.position += 4;\n      return v;\n    } catch (e) {\n      this.debugMessage(e + ' ' + this.position + ' ' + data.byteLength);\n    }\n  }\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @method readInt\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readInt(data) {\n    const v = data.getInt32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @method readShort\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readShort(data) {\n    const v = data.getInt16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @method readDWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readDWord(data) {\n    const v = data.getUint32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @method readWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readWord(data) {\n    const v = data.getUint16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read string value.\n   *\n   * @method readString\n   * @param {DataView} data Dataview to read data from.\n   * @param {Number} maxLength Max size of the string to be read.\n   * @return {String} Data read from the dataview.\n   */\n\n\n  readString(data, maxLength) {\n    let s = '';\n\n    for (let i = 0; i < maxLength; i++) {\n      const c = this.readByte(data);\n\n      if (!c) {\n        break;\n      }\n\n      s += String.fromCharCode(c);\n    }\n\n    return s;\n  }\n  /**\n   * Read percentage value.\n   *\n   * @method readPercentage\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n\n\n  readPercentage(data) {\n    const chunk = this.readChunk(data);\n    let value;\n\n    switch (chunk.id) {\n      case INT_PERCENTAGE:\n        value = this.readShort(data) / 100;\n        break;\n\n      case FLOAT_PERCENTAGE:\n        value = this.readFloat(data);\n        break;\n\n      default:\n        this.debugMessage('      Unknown percentage chunk: ' + chunk.toString(16));\n    }\n\n    this.endChunk(chunk);\n    return value;\n  }\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @method debugMessage\n   * @param {Object} message Debug message to print to the console.\n   */\n\n\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message);\n    }\n  }\n\n} // const NULL_CHUNK = 0x0000;\n\n\nconst M3DMAGIC = 0x4d4d; // const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\n\nconst MLIBMAGIC = 0x3daa; // const MATMAGIC = 0x3DFF;\n\nconst CMAGIC = 0xc23d;\nconst M3D_VERSION = 0x0002; // const M3D_KFVERSION = 0x0005;\n\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3d3d;\nconst MESH_VERSION = 0x3d3e;\nconst MASTER_SCALE = 0x0100; // const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\n\nconst MAT_ENTRY = 0xafff;\nconst MAT_NAME = 0xa000;\nconst MAT_AMBIENT = 0xa010;\nconst MAT_DIFFUSE = 0xa020;\nconst MAT_SPECULAR = 0xa030;\nconst MAT_SHININESS = 0xa040; // const MAT_SHIN2PCT = 0xA041;\n\nconst MAT_TRANSPARENCY = 0xa050; // const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\n\nconst MAT_TWO_SIDE = 0xa081; // const MAT_DECAL = 0xA082;\n\nconst MAT_ADDITIVE = 0xa083;\nconst MAT_WIRE = 0xa085; // const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\n\nconst MAT_WIRE_SIZE = 0xa087;\nconst MAT_TEXMAP = 0xa200; // const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\n\nconst MAT_OPACMAP = 0xa210; // const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\n\nconst MAT_BUMPMAP = 0xa230; // const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\n\nconst MAT_SPECMAP = 0xa204; // const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\n\nconst MAT_MAPNAME = 0xa300; // const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\n\nconst MAT_MAP_USCALE = 0xa354;\nconst MAT_MAP_VSCALE = 0xa356;\nconst MAT_MAP_UOFFSET = 0xa358;\nconst MAT_MAP_VOFFSET = 0xa35a; // const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\n\nconst NAMED_OBJECT = 0x4000; // const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\n\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110; // const POINT_FLAG_ARRAY = 0x4111;\n\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130; // const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\n\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160; // const MESH_COLOR = 0x4165;\n\nexport { TDSLoader };\n"]},"metadata":{},"sourceType":"module"}