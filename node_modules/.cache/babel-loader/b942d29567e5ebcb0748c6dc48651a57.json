{"ast":null,"code":"import { DataTexture, FloatType, IntType, UnsignedIntType, ByteType, UnsignedByteType, ShortType, UnsignedShortType, RedFormat, RGFormat, RGBFormat, RGBAFormat, RedIntegerFormat, RGIntegerFormat, RGBIntegerFormat, RGBAIntegerFormat, NearestFilter } from 'three';\n\nfunction countToStringFormat(count) {\n  switch (count) {\n    case 1:\n      return 'R';\n\n    case 2:\n      return 'RG';\n\n    case 3:\n      return 'RGB';\n\n    case 4:\n      return 'RGBA';\n  }\n\n  throw new Error();\n}\n\nfunction countToFormat(count) {\n  switch (count) {\n    case 1:\n      return RedFormat;\n\n    case 2:\n      return RGFormat;\n\n    case 3:\n      return RGBFormat;\n\n    case 4:\n      return RGBAFormat;\n  }\n}\n\nfunction countToIntFormat(count) {\n  switch (count) {\n    case 1:\n      return RedIntegerFormat;\n\n    case 2:\n      return RGIntegerFormat;\n\n    case 3:\n      return RGBIntegerFormat;\n\n    case 4:\n      return RGBAIntegerFormat;\n  }\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n  constructor() {\n    super();\n    this.minFilter = NearestFilter;\n    this.magFilter = NearestFilter;\n    this.generateMipmaps = false;\n    this.overrideItemSize = null;\n    this._forcedType = null;\n  }\n\n  updateFrom(attr) {\n    const overrideItemSize = this.overrideItemSize;\n    const originalItemSize = attr.itemSize;\n    const originalCount = attr.count;\n\n    if (overrideItemSize !== null) {\n      if (originalItemSize * originalCount % overrideItemSize !== 0.0) {\n        throw new Error('VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.');\n      }\n\n      attr.itemSize = overrideItemSize;\n      attr.count = originalCount * originalItemSize / overrideItemSize;\n    }\n\n    const itemSize = attr.itemSize;\n    const count = attr.count;\n    const normalized = attr.normalized;\n    const originalBufferCons = attr.array.constructor;\n    const byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n    let targetType = this._forcedType; // derive the type of texture this should be in the shader\n\n    if (targetType === null) {\n      switch (originalBufferCons) {\n        case Float32Array:\n          targetType = FloatType;\n          break;\n\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n          targetType = UnsignedIntType;\n          break;\n\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n          targetType = IntType;\n          break;\n      }\n    } // get the target format to store the texture as\n\n\n    let type, format, normalizeValue, targetBufferCons;\n    let internalFormat = countToStringFormat(itemSize);\n\n    switch (targetType) {\n      case FloatType:\n        normalizeValue = 1.0;\n        format = countToFormat(itemSize);\n\n        if (normalized && byteCount === 1) {\n          targetBufferCons = originalBufferCons;\n          internalFormat += '8';\n\n          if (originalBufferCons === Uint8Array) {\n            type = UnsignedByteType;\n          } else {\n            type = ByteType;\n            internalFormat += '_SNORM';\n          }\n        } else {\n          targetBufferCons = Float32Array;\n          internalFormat += '32F';\n          type = FloatType;\n        }\n\n        break;\n\n      case IntType:\n        internalFormat += byteCount * 8 + 'I';\n        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n        format = countToIntFormat(itemSize);\n\n        if (byteCount === 1) {\n          targetBufferCons = Int8Array;\n          type = ByteType;\n        } else if (byteCount === 2) {\n          targetBufferCons = Int16Array;\n          type = ShortType;\n        } else {\n          targetBufferCons = Int32Array;\n          type = IntType;\n        }\n\n        break;\n\n      case UnsignedIntType:\n        internalFormat += byteCount * 8 + 'UI';\n        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n        format = countToIntFormat(itemSize);\n\n        if (byteCount === 1) {\n          targetBufferCons = Uint8Array;\n          type = UnsignedByteType;\n        } else if (byteCount === 2) {\n          targetBufferCons = Uint16Array;\n          type = UnsignedShortType;\n        } else {\n          targetBufferCons = Uint32Array;\n          type = UnsignedIntType;\n        }\n\n        break;\n    } // copy the data over to the new texture array\n\n\n    const dimension = Math.ceil(Math.sqrt(count));\n    const length = itemSize * dimension * dimension;\n    const dataArray = new targetBufferCons(length);\n\n    for (let i = 0; i < count; i++) {\n      const ii = itemSize * i;\n      dataArray[ii] = attr.getX(i) / normalizeValue;\n\n      if (itemSize >= 2) {\n        dataArray[ii + 1] = attr.getY(i) / normalizeValue;\n      }\n\n      if (itemSize >= 3) {\n        dataArray[ii + 2] = attr.getZ(i) / normalizeValue;\n      }\n\n      if (itemSize >= 4) {\n        dataArray[ii + 3] = attr.getW(i) / normalizeValue;\n      }\n    }\n\n    this.internalFormat = internalFormat;\n    this.format = format;\n    this.type = type;\n    this.image.width = dimension;\n    this.image.height = dimension;\n    this.image.data = dataArray;\n    this.needsUpdate = true;\n    attr.itemSize = originalItemSize;\n    attr.count = originalCount;\n  }\n\n}\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n  constructor() {\n    super();\n    this._forcedType = UnsignedIntType;\n  }\n\n}\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n  constructor() {\n    super();\n    this._forcedType = IntType;\n  }\n\n}\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n  constructor() {\n    super();\n    this._forcedType = FloatType;\n  }\n\n}","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js"],"names":["DataTexture","FloatType","IntType","UnsignedIntType","ByteType","UnsignedByteType","ShortType","UnsignedShortType","RedFormat","RGFormat","RGBFormat","RGBAFormat","RedIntegerFormat","RGIntegerFormat","RGBIntegerFormat","RGBAIntegerFormat","NearestFilter","countToStringFormat","count","Error","countToFormat","countToIntFormat","VertexAttributeTexture","constructor","minFilter","magFilter","generateMipmaps","overrideItemSize","_forcedType","updateFrom","attr","originalItemSize","itemSize","originalCount","normalized","originalBufferCons","array","byteCount","BYTES_PER_ELEMENT","targetType","Float32Array","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","type","format","normalizeValue","targetBufferCons","internalFormat","Math","pow","dimension","ceil","sqrt","length","dataArray","i","ii","getX","getY","getZ","getW","image","width","height","data","needsUpdate","UIntVertexAttributeTexture","IntVertexAttributeTexture","FloatVertexAttributeTexture"],"mappings":"AAAA,SACCA,WADD,EAECC,SAFD,EAGCC,OAHD,EAICC,eAJD,EAKCC,QALD,EAMCC,gBAND,EAOCC,SAPD,EAQCC,iBARD,EAUCC,SAVD,EAWCC,QAXD,EAYCC,SAZD,EAaCC,UAbD,EAeCC,gBAfD,EAgBCC,eAhBD,EAiBCC,gBAjBD,EAkBCC,iBAlBD,EAoBCC,aApBD,QAqBO,OArBP;;AAuBA,SAASC,mBAAT,CAA8BC,KAA9B,EAAsC;AAErC,UAASA,KAAT;AAEC,SAAK,CAAL;AAAQ,aAAO,GAAP;;AACR,SAAK,CAAL;AAAQ,aAAO,IAAP;;AACR,SAAK,CAAL;AAAQ,aAAO,KAAP;;AACR,SAAK,CAAL;AAAQ,aAAO,MAAP;AALT;;AASA,QAAM,IAAIC,KAAJ,EAAN;AAEA;;AAED,SAASC,aAAT,CAAwBF,KAAxB,EAAgC;AAE/B,UAASA,KAAT;AAEC,SAAK,CAAL;AAAQ,aAAOV,SAAP;;AACR,SAAK,CAAL;AAAQ,aAAOC,QAAP;;AACR,SAAK,CAAL;AAAQ,aAAOC,SAAP;;AACR,SAAK,CAAL;AAAQ,aAAOC,UAAP;AALT;AASA;;AAED,SAASU,gBAAT,CAA2BH,KAA3B,EAAmC;AAElC,UAASA,KAAT;AAEC,SAAK,CAAL;AAAQ,aAAON,gBAAP;;AACR,SAAK,CAAL;AAAQ,aAAOC,eAAP;;AACR,SAAK,CAAL;AAAQ,aAAOC,gBAAP;;AACR,SAAK,CAAL;AAAQ,aAAOC,iBAAP;AALT;AASA;;AAED,OAAO,MAAMO,sBAAN,SAAqCtB,WAArC,CAAiD;AAEvDuB,EAAAA,WAAW,GAAG;AAEb;AACA,SAAKC,SAAL,GAAiBR,aAAjB;AACA,SAAKS,SAAL,GAAiBT,aAAjB;AACA,SAAKU,eAAL,GAAuB,KAAvB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AAEA;;AAEDC,EAAAA,UAAU,CAAEC,IAAF,EAAS;AAElB,UAAMH,gBAAgB,GAAG,KAAKA,gBAA9B;AACA,UAAMI,gBAAgB,GAAGD,IAAI,CAACE,QAA9B;AACA,UAAMC,aAAa,GAAGH,IAAI,CAACZ,KAA3B;;AACA,QAAKS,gBAAgB,KAAK,IAA1B,EAAiC;AAEhC,UAAOI,gBAAgB,GAAGE,aAArB,GAAuCN,gBAAvC,KAA4D,GAAjE,EAAuE;AAEtE,cAAM,IAAIR,KAAJ,CAAW,iFAAX,CAAN;AAEA;;AAEDW,MAAAA,IAAI,CAACE,QAAL,GAAgBL,gBAAhB;AACAG,MAAAA,IAAI,CAACZ,KAAL,GAAae,aAAa,GAAGF,gBAAhB,GAAmCJ,gBAAhD;AAEA;;AAED,UAAMK,QAAQ,GAAGF,IAAI,CAACE,QAAtB;AACA,UAAMd,KAAK,GAAGY,IAAI,CAACZ,KAAnB;AACA,UAAMgB,UAAU,GAAGJ,IAAI,CAACI,UAAxB;AACA,UAAMC,kBAAkB,GAAGL,IAAI,CAACM,KAAL,CAAWb,WAAtC;AACA,UAAMc,SAAS,GAAGF,kBAAkB,CAACG,iBAArC;AACA,QAAIC,UAAU,GAAG,KAAKX,WAAtB,CAvBkB,CAyBlB;;AACA,QAAKW,UAAU,KAAK,IAApB,EAA2B;AAE1B,cAASJ,kBAAT;AAEC,aAAKK,YAAL;AACCD,UAAAA,UAAU,GAAGtC,SAAb;AACA;;AAED,aAAKwC,UAAL;AACA,aAAKC,WAAL;AACA,aAAKC,WAAL;AACCJ,UAAAA,UAAU,GAAGpC,eAAb;AACA;;AAED,aAAKyC,SAAL;AACA,aAAKC,UAAL;AACA,aAAKC,UAAL;AACCP,UAAAA,UAAU,GAAGrC,OAAb;AACA;AAhBF;AAoBA,KAhDiB,CAkDlB;;;AACA,QAAI6C,IAAJ,EAAUC,MAAV,EAAkBC,cAAlB,EAAkCC,gBAAlC;AACA,QAAIC,cAAc,GAAGlC,mBAAmB,CAAEe,QAAF,CAAxC;;AACA,YAASO,UAAT;AAEC,WAAKtC,SAAL;AACCgD,QAAAA,cAAc,GAAG,GAAjB;AACAD,QAAAA,MAAM,GAAG5B,aAAa,CAAEY,QAAF,CAAtB;;AAEA,YAAKE,UAAU,IAAIG,SAAS,KAAK,CAAjC,EAAqC;AAEpCa,UAAAA,gBAAgB,GAAGf,kBAAnB;AACAgB,UAAAA,cAAc,IAAI,GAAlB;;AAEA,cAAKhB,kBAAkB,KAAKM,UAA5B,EAAyC;AAExCM,YAAAA,IAAI,GAAG1C,gBAAP;AAEA,WAJD,MAIO;AAEN0C,YAAAA,IAAI,GAAG3C,QAAP;AACA+C,YAAAA,cAAc,IAAI,QAAlB;AAEA;AAED,SAhBD,MAgBO;AAEND,UAAAA,gBAAgB,GAAGV,YAAnB;AACAW,UAAAA,cAAc,IAAI,KAAlB;AACAJ,UAAAA,IAAI,GAAG9C,SAAP;AAEA;;AAED;;AAED,WAAKC,OAAL;AACCiD,QAAAA,cAAc,IAAId,SAAS,GAAG,CAAZ,GAAgB,GAAlC;AACAY,QAAAA,cAAc,GAAGf,UAAU,GAAGkB,IAAI,CAACC,GAAL,CAAU,CAAV,EAAalB,kBAAkB,CAACG,iBAAnB,GAAuC,CAAvC,GAA2C,CAAxD,CAAH,GAAiE,GAA5F;AACAU,QAAAA,MAAM,GAAG3B,gBAAgB,CAAEW,QAAF,CAAzB;;AAEA,YAAKK,SAAS,KAAK,CAAnB,EAAuB;AAEtBa,UAAAA,gBAAgB,GAAGN,SAAnB;AACAG,UAAAA,IAAI,GAAG3C,QAAP;AAEA,SALD,MAKO,IAAKiC,SAAS,KAAK,CAAnB,EAAuB;AAE7Ba,UAAAA,gBAAgB,GAAGL,UAAnB;AACAE,UAAAA,IAAI,GAAGzC,SAAP;AAEA,SALM,MAKA;AAEN4C,UAAAA,gBAAgB,GAAGJ,UAAnB;AACAC,UAAAA,IAAI,GAAG7C,OAAP;AAEA;;AAED;;AAED,WAAKC,eAAL;AACCgD,QAAAA,cAAc,IAAId,SAAS,GAAG,CAAZ,GAAgB,IAAlC;AACAY,QAAAA,cAAc,GAAGf,UAAU,GAAGkB,IAAI,CAACC,GAAL,CAAU,CAAV,EAAalB,kBAAkB,CAACG,iBAAnB,GAAuC,CAAvC,GAA2C,CAAxD,CAAH,GAAiE,GAA5F;AACAU,QAAAA,MAAM,GAAG3B,gBAAgB,CAAEW,QAAF,CAAzB;;AAEA,YAAKK,SAAS,KAAK,CAAnB,EAAuB;AAEtBa,UAAAA,gBAAgB,GAAGT,UAAnB;AACAM,UAAAA,IAAI,GAAG1C,gBAAP;AAEA,SALD,MAKO,IAAKgC,SAAS,KAAK,CAAnB,EAAuB;AAE7Ba,UAAAA,gBAAgB,GAAGR,WAAnB;AACAK,UAAAA,IAAI,GAAGxC,iBAAP;AAEA,SALM,MAKA;AAEN2C,UAAAA,gBAAgB,GAAGP,WAAnB;AACAI,UAAAA,IAAI,GAAG5C,eAAP;AAEA;;AAED;AA9EF,KArDkB,CAuIlB;;;AACA,UAAMmD,SAAS,GAAGF,IAAI,CAACG,IAAL,CAAWH,IAAI,CAACI,IAAL,CAAWtC,KAAX,CAAX,CAAlB;AACA,UAAMuC,MAAM,GAAGzB,QAAQ,GAAGsB,SAAX,GAAuBA,SAAtC;AACA,UAAMI,SAAS,GAAG,IAAIR,gBAAJ,CAAsBO,MAAtB,CAAlB;;AACA,SAAM,IAAIE,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGzC,KAArB,EAA4ByC,CAAC,EAA7B,EAAmC;AAElC,YAAMC,EAAE,GAAG5B,QAAQ,GAAG2B,CAAtB;AACAD,MAAAA,SAAS,CAAEE,EAAF,CAAT,GAAkB9B,IAAI,CAAC+B,IAAL,CAAWF,CAAX,IAAiBV,cAAnC;;AAEA,UAAKjB,QAAQ,IAAI,CAAjB,EAAqB;AAEpB0B,QAAAA,SAAS,CAAEE,EAAE,GAAG,CAAP,CAAT,GAAsB9B,IAAI,CAACgC,IAAL,CAAWH,CAAX,IAAiBV,cAAvC;AAEA;;AAED,UAAKjB,QAAQ,IAAI,CAAjB,EAAqB;AAEpB0B,QAAAA,SAAS,CAAEE,EAAE,GAAG,CAAP,CAAT,GAAsB9B,IAAI,CAACiC,IAAL,CAAWJ,CAAX,IAAiBV,cAAvC;AAEA;;AAED,UAAKjB,QAAQ,IAAI,CAAjB,EAAqB;AAEpB0B,QAAAA,SAAS,CAAEE,EAAE,GAAG,CAAP,CAAT,GAAsB9B,IAAI,CAACkC,IAAL,CAAWL,CAAX,IAAiBV,cAAvC;AAEA;AAED;;AAED,SAAKE,cAAL,GAAsBA,cAAtB;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKkB,KAAL,CAAWC,KAAX,GAAmBZ,SAAnB;AACA,SAAKW,KAAL,CAAWE,MAAX,GAAoBb,SAApB;AACA,SAAKW,KAAL,CAAWG,IAAX,GAAkBV,SAAlB;AACA,SAAKW,WAAL,GAAmB,IAAnB;AAEAvC,IAAAA,IAAI,CAACE,QAAL,GAAgBD,gBAAhB;AACAD,IAAAA,IAAI,CAACZ,KAAL,GAAae,aAAb;AAEA;;AA5LsD;AAgMxD,OAAO,MAAMqC,0BAAN,SAAyChD,sBAAzC,CAAgE;AAEtEC,EAAAA,WAAW,GAAG;AAEb;AACA,SAAKK,WAAL,GAAmBzB,eAAnB;AAEA;;AAPqE;AAWvE,OAAO,MAAMoE,yBAAN,SAAwCjD,sBAAxC,CAA+D;AAErEC,EAAAA,WAAW,GAAG;AAEb;AACA,SAAKK,WAAL,GAAmB1B,OAAnB;AAEA;;AAPoE;AAYtE,OAAO,MAAMsE,2BAAN,SAA0ClD,sBAA1C,CAAiE;AAEvEC,EAAAA,WAAW,GAAG;AAEb;AACA,SAAKK,WAAL,GAAmB3B,SAAnB;AAEA;;AAPsE","sourcesContent":["import {\r\n\tDataTexture,\r\n\tFloatType,\r\n\tIntType,\r\n\tUnsignedIntType,\r\n\tByteType,\r\n\tUnsignedByteType,\r\n\tShortType,\r\n\tUnsignedShortType,\r\n\r\n\tRedFormat,\r\n\tRGFormat,\r\n\tRGBFormat,\r\n\tRGBAFormat,\r\n\r\n\tRedIntegerFormat,\r\n\tRGIntegerFormat,\r\n\tRGBIntegerFormat,\r\n\tRGBAIntegerFormat,\r\n\r\n\tNearestFilter,\r\n} from 'three';\r\n\r\nfunction countToStringFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return 'R';\r\n\t\tcase 2: return 'RG';\r\n\t\tcase 3: return 'RGB';\r\n\t\tcase 4: return 'RGBA';\r\n\r\n\t}\r\n\r\n\tthrow new Error();\r\n\r\n}\r\n\r\nfunction countToFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return RedFormat;\r\n\t\tcase 2: return RGFormat;\r\n\t\tcase 3: return RGBFormat;\r\n\t\tcase 4: return RGBAFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction countToIntFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return RedIntegerFormat;\r\n\t\tcase 2: return RGIntegerFormat;\r\n\t\tcase 3: return RGBIntegerFormat;\r\n\t\tcase 4: return RGBAIntegerFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class VertexAttributeTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\t\tthis.generateMipmaps = false;\r\n\t\tthis.overrideItemSize = null;\r\n\t\tthis._forcedType = null;\r\n\r\n\t}\r\n\r\n\tupdateFrom( attr ) {\r\n\r\n\t\tconst overrideItemSize = this.overrideItemSize;\r\n\t\tconst originalItemSize = attr.itemSize;\r\n\t\tconst originalCount = attr.count;\r\n\t\tif ( overrideItemSize !== null ) {\r\n\r\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattr.itemSize = overrideItemSize;\r\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\r\n\r\n\t\t}\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tconst count = attr.count;\r\n\t\tconst normalized = attr.normalized;\r\n\t\tconst originalBufferCons = attr.array.constructor;\r\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\r\n\t\tlet targetType = this._forcedType;\r\n\r\n\t\t// derive the type of texture this should be in the shader\r\n\t\tif ( targetType === null ) {\r\n\r\n\t\t\tswitch ( originalBufferCons ) {\r\n\r\n\t\t\t\tcase Float32Array:\r\n\t\t\t\t\ttargetType = FloatType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Uint8Array:\r\n\t\t\t\tcase Uint16Array:\r\n\t\t\t\tcase Uint32Array:\r\n\t\t\t\t\ttargetType = UnsignedIntType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Int8Array:\r\n\t\t\t\tcase Int16Array:\r\n\t\t\t\tcase Int32Array:\r\n\t\t\t\t\ttargetType = IntType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// get the target format to store the texture as\r\n\t\tlet type, format, normalizeValue, targetBufferCons;\r\n\t\tlet internalFormat = countToStringFormat( itemSize );\r\n\t\tswitch ( targetType ) {\r\n\r\n\t\t\tcase FloatType:\r\n\t\t\t\tnormalizeValue = 1.0;\r\n\t\t\t\tformat = countToFormat( itemSize );\r\n\r\n\t\t\t\tif ( normalized && byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\r\n\t\t\t\t\tinternalFormat += '8';\r\n\r\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\r\n\r\n\t\t\t\t\t\ttype = UnsignedByteType;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttype = ByteType;\r\n\t\t\t\t\t\tinternalFormat += '_SNORM';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Float32Array;\r\n\t\t\t\t\tinternalFormat += '32F';\r\n\t\t\t\t\ttype = FloatType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase IntType:\r\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\r\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\r\n\t\t\t\tformat = countToIntFormat( itemSize );\r\n\r\n\t\t\t\tif ( byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int8Array;\r\n\t\t\t\t\ttype = ByteType;\r\n\r\n\t\t\t\t} else if ( byteCount === 2 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int16Array;\r\n\t\t\t\t\ttype = ShortType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int32Array;\r\n\t\t\t\t\ttype = IntType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase UnsignedIntType:\r\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\r\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\r\n\t\t\t\tformat = countToIntFormat( itemSize );\r\n\r\n\t\t\t\tif ( byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint8Array;\r\n\t\t\t\t\ttype = UnsignedByteType;\r\n\r\n\t\t\t\t} else if ( byteCount === 2 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint16Array;\r\n\t\t\t\t\ttype = UnsignedShortType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint32Array;\r\n\t\t\t\t\ttype = UnsignedIntType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t// copy the data over to the new texture array\r\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\r\n\t\tconst length = itemSize * dimension * dimension;\r\n\t\tconst dataArray = new targetBufferCons( length );\r\n\t\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\t\tconst ii = itemSize * i;\r\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\r\n\r\n\t\t\tif ( itemSize >= 2 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( itemSize >= 3 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( itemSize >= 4 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.internalFormat = internalFormat;\r\n\t\tthis.format = format;\r\n\t\tthis.type = type;\r\n\t\tthis.image.width = dimension;\r\n\t\tthis.image.height = dimension;\r\n\t\tthis.image.data = dataArray;\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t\tattr.itemSize = originalItemSize;\r\n\t\tattr.count = originalCount;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = UnsignedIntType;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = IntType;\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = FloatType;\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}