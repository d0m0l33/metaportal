{"ast":null,"code":"import { Loader, FileLoader, DataTexture, RGBFormat, UnsignedByteType, LinearFilter, ClampToEdgeWrapping, DataTexture3D } from 'three'; // http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492\n\nclass LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('text');\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(str) {\n    // remove empty lines and comment lints\n    str = str.replace(/^#.*?(\\n|\\r)/gm, '').replace(/^\\s*?(\\n|\\r)/gm, '').trim();\n    const lines = str.split(/[\\n\\r]+/g); // first line is the positions on the grid that are provided by the LUT\n\n    const gridLines = lines[0].trim().split(/\\s+/g).map(e => parseFloat(e));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error('LUT3dlLoader: Inconsistent grid size not supported.');\n      }\n    }\n\n    const dataArray = new Array(size * size * size * 3);\n    let index = 0;\n    let maxOutputValue = 0.0;\n\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      const r = parseFloat(split[0]);\n      const g = parseFloat(split[1]);\n      const b = parseFloat(split[2]);\n      maxOutputValue = Math.max(maxOutputValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / (size * size)) % size; // b grows first, then g, then r\n\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer;\n      dataArray[3 * pixelIndex + 0] = r;\n      dataArray[3 * pixelIndex + 1] = g;\n      dataArray[3 * pixelIndex + 2] = b;\n      index += 1;\n    } // Find the apparent bit depth of the stored RGB values and scale the\n    // values to [ 0, 255 ].\n\n\n    const bits = Math.ceil(Math.log2(maxOutputValue));\n    const maxBitValue = Math.pow(2.0, bits);\n\n    for (let i = 0, l = dataArray.length; i < l; i++) {\n      const val = dataArray[i];\n      dataArray[i] = 255 * val / maxBitValue;\n    }\n\n    const data = new Uint8Array(dataArray);\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.format = RGBFormat;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    const texture3D = new DataTexture3D();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.format = RGBFormat;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    return {\n      size,\n      texture,\n      texture3D\n    };\n  }\n\n}\n\nexport { LUT3dlLoader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/loaders/LUT3dlLoader.js"],"names":["Loader","FileLoader","DataTexture","RGBFormat","UnsignedByteType","LinearFilter","ClampToEdgeWrapping","DataTexture3D","LUT3dlLoader","load","url","onLoad","onProgress","onError","loader","manager","setPath","path","setResponseType","text","parse","e","console","error","itemError","str","replace","trim","lines","split","gridLines","map","parseFloat","gridStep","size","length","i","l","Error","dataArray","Array","index","maxOutputValue","line","r","g","b","Math","max","bLayer","gLayer","floor","rLayer","pixelIndex","bits","ceil","log2","maxBitValue","pow","val","data","Uint8Array","texture","image","width","height","format","type","magFilter","minFilter","wrapS","wrapT","generateMipmaps","texture3D","depth","wrapR"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, DataTexture, RGBFormat, UnsignedByteType, LinearFilter, ClampToEdgeWrapping, DataTexture3D } from 'three';\n\n// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492\nclass LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('text');\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(str) {\n    // remove empty lines and comment lints\n    str = str.replace(/^#.*?(\\n|\\r)/gm, '').replace(/^\\s*?(\\n|\\r)/gm, '').trim();\n    const lines = str.split(/[\\n\\r]+/g); // first line is the positions on the grid that are provided by the LUT\n\n    const gridLines = lines[0].trim().split(/\\s+/g).map(e => parseFloat(e));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error('LUT3dlLoader: Inconsistent grid size not supported.');\n      }\n    }\n\n    const dataArray = new Array(size * size * size * 3);\n    let index = 0;\n    let maxOutputValue = 0.0;\n\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      const r = parseFloat(split[0]);\n      const g = parseFloat(split[1]);\n      const b = parseFloat(split[2]);\n      maxOutputValue = Math.max(maxOutputValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / (size * size)) % size; // b grows first, then g, then r\n\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer;\n      dataArray[3 * pixelIndex + 0] = r;\n      dataArray[3 * pixelIndex + 1] = g;\n      dataArray[3 * pixelIndex + 2] = b;\n      index += 1;\n    } // Find the apparent bit depth of the stored RGB values and scale the\n    // values to [ 0, 255 ].\n\n\n    const bits = Math.ceil(Math.log2(maxOutputValue));\n    const maxBitValue = Math.pow(2.0, bits);\n\n    for (let i = 0, l = dataArray.length; i < l; i++) {\n      const val = dataArray[i];\n      dataArray[i] = 255 * val / maxBitValue;\n    }\n\n    const data = new Uint8Array(dataArray);\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.format = RGBFormat;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    const texture3D = new DataTexture3D();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.format = RGBFormat;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    return {\n      size,\n      texture,\n      texture3D\n    };\n  }\n\n}\n\nexport { LUT3dlLoader };\n"]},"metadata":{},"sourceType":"module"}