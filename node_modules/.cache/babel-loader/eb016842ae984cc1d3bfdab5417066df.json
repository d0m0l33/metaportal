{"ast":null,"code":"import { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from 'three';\nimport Frustum from './Frustum.js';\nimport Shader from './Shader.js';\n\nconst _cameraToLightMatrix = new Matrix4();\n\nconst _lightSpaceFrustum = new Frustum();\n\nconst _center = new Vector3();\n\nconst _bbox = new Box3();\n\nconst _uniformArray = [];\nconst _logArray = [];\n\nclass CSM {\n  constructor(data) {\n    data = data || {};\n    this.camera = data.camera;\n    this.parent = data.parent;\n    this.cascades = data.cascades || 3;\n    this.maxFar = data.maxFar || 100000;\n    this.mode = data.mode || 'practical';\n    this.shadowMapSize = data.shadowMapSize || 2048;\n    this.shadowBias = data.shadowBias || 0.000001;\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n    this.lightIntensity = data.lightIntensity || 1;\n    this.lightNear = data.lightNear || 1;\n    this.lightFar = data.lightFar || 2000;\n    this.lightMargin = data.lightMargin || 200;\n    this.customSplitsCallback = data.customSplitsCallback;\n    this.fade = false;\n    this.mainFrustum = new Frustum();\n    this.frustums = [];\n    this.breaks = [];\n    this.lights = [];\n    this.shaders = new Map();\n    this.createLights();\n    this.updateFrustums();\n    this.injectInclude();\n  }\n\n  createLights() {\n    for (let i = 0; i < this.cascades; i++) {\n      const light = new DirectionalLight(0xffffff, this.lightIntensity);\n      light.castShadow = true;\n      light.shadow.mapSize.width = this.shadowMapSize;\n      light.shadow.mapSize.height = this.shadowMapSize;\n      light.shadow.camera.near = this.lightNear;\n      light.shadow.camera.far = this.lightFar;\n      light.shadow.bias = this.shadowBias;\n      this.parent.add(light);\n      this.parent.add(light.target);\n      this.lights.push(light);\n    }\n  }\n\n  initCascades() {\n    const camera = this.camera;\n    camera.updateProjectionMatrix();\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n    this.mainFrustum.split(this.breaks, this.frustums);\n  }\n\n  updateShadowBounds() {\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const frustum = this.frustums[i]; // Get the two points that represent that furthest points on the frustum assuming\n      // that's either the diagonal across the far plane or the diagonal across the whole\n      // frustum itself.\n\n      const nearVerts = frustum.vertices.near;\n      const farVerts = frustum.vertices.far;\n      const point1 = farVerts[0];\n      let point2;\n\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n        point2 = farVerts[2];\n      } else {\n        point2 = nearVerts[2];\n      }\n\n      let squaredBBWidth = point1.distanceTo(point2);\n\n      if (this.fade) {\n        // expand the shadow extents by the fade margin if fade is enabled.\n        const camera = this.camera;\n        const far = Math.max(camera.far, this.maxFar);\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n        const margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);\n        squaredBBWidth += margin;\n      }\n\n      shadowCam.left = -squaredBBWidth / 2;\n      shadowCam.right = squaredBBWidth / 2;\n      shadowCam.top = squaredBBWidth / 2;\n      shadowCam.bottom = -squaredBBWidth / 2;\n      shadowCam.updateProjectionMatrix();\n    }\n  }\n\n  getBreaks() {\n    const camera = this.camera;\n    const far = Math.min(camera.far, this.maxFar);\n    this.breaks.length = 0;\n\n    switch (this.mode) {\n      case 'uniform':\n        uniformSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'logarithmic':\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'practical':\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n        break;\n\n      case 'custom':\n        if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n        break;\n    }\n\n    function uniformSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near + (far - near) * i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function logarithmicSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push(near * (far / near) ** (i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function practicalSplit(amount, near, far, lambda, target) {\n      _uniformArray.length = 0;\n      _logArray.length = 0;\n      logarithmicSplit(amount, near, far, _logArray);\n      uniformSplit(amount, near, far, _uniformArray);\n\n      for (let i = 1; i < amount; i++) {\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n      }\n\n      target.push(1);\n    }\n  }\n\n  update() {\n    const camera = this.camera;\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n      light.shadow.camera.updateMatrixWorld(true);\n\n      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\n\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n      const nearVerts = _lightSpaceFrustum.vertices.near;\n      const farVerts = _lightSpaceFrustum.vertices.far;\n\n      _bbox.makeEmpty();\n\n      for (let j = 0; j < 4; j++) {\n        _bbox.expandByPoint(nearVerts[j]);\n\n        _bbox.expandByPoint(farVerts[j]);\n      }\n\n      _bbox.getCenter(_center);\n\n      _center.z = _bbox.max.z + this.lightMargin;\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n\n      _center.applyMatrix4(light.shadow.camera.matrixWorld);\n\n      light.position.copy(_center);\n      light.target.position.copy(_center);\n      light.target.position.x += this.lightDirection.x;\n      light.target.position.y += this.lightDirection.y;\n      light.target.position.z += this.lightDirection.z;\n    }\n  }\n\n  injectInclude() {\n    ShaderChunk.lights_fragment_begin = Shader.lights_fragment_begin;\n    ShaderChunk.lights_pars_begin = Shader.lights_pars_begin;\n  }\n\n  setupMaterial(material) {\n    material.defines = material.defines || {};\n    material.defines.USE_CSM = 1;\n    material.defines.CSM_CASCADES = this.cascades;\n\n    if (this.fade) {\n      material.defines.CSM_FADE = '';\n    }\n\n    const breaksVec2 = [];\n    const scope = this;\n    const shaders = this.shaders;\n\n    material.onBeforeCompile = shader => {\n      const far = Math.min(scope.camera.far, scope.maxFar);\n      scope.getExtendedBreaks(breaksVec2);\n      shader.uniforms.CSM_cascades = {\n        value: breaksVec2\n      };\n      shader.uniforms.cameraNear = {\n        value: scope.camera.near\n      };\n      shader.uniforms.shadowFar = {\n        value: far\n      };\n      shaders.set(material, shader);\n    };\n\n    shaders.set(material, null);\n  }\n\n  updateUniforms() {\n    const far = Math.min(this.camera.far, this.maxFar);\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      if (shader !== null) {\n        const uniforms = shader.uniforms;\n        this.getExtendedBreaks(uniforms.CSM_cascades.value);\n        uniforms.cameraNear.value = this.camera.near;\n        uniforms.shadowFar.value = far;\n      }\n\n      if (!this.fade && 'CSM_FADE' in material.defines) {\n        delete material.defines.CSM_FADE;\n        material.needsUpdate = true;\n      } else if (this.fade && !('CSM_FADE' in material.defines)) {\n        material.defines.CSM_FADE = '';\n        material.needsUpdate = true;\n      }\n    }, this);\n  }\n\n  getExtendedBreaks(target) {\n    while (target.length < this.breaks.length) {\n      target.push(new Vector2());\n    }\n\n    target.length = this.breaks.length;\n\n    for (let i = 0; i < this.cascades; i++) {\n      const amount = this.breaks[i];\n      const prev = this.breaks[i - 1] || 0;\n      target[i].x = prev;\n      target[i].y = amount;\n    }\n  }\n\n  updateFrustums() {\n    this.getBreaks();\n    this.initCascades();\n    this.updateShadowBounds();\n    this.updateUniforms();\n  }\n\n  remove() {\n    for (let i = 0; i < this.lights.length; i++) {\n      this.parent.remove(this.lights[i]);\n    }\n  }\n\n  dispose() {\n    const shaders = this.shaders;\n    shaders.forEach((shader, material) => {\n      delete material.onBeforeCompile;\n      delete material.defines.USE_CSM;\n      delete material.defines.CSM_CASCADES;\n      delete material.defines.CSM_FADE;\n\n      if (shader !== null) {\n        delete shader.uniforms.CSM_cascades;\n        delete shader.uniforms.cameraNear;\n        delete shader.uniforms.shadowFar;\n      }\n\n      material.needsUpdate = true;\n    });\n    shaders.clear();\n  }\n\n}\n\nexport { CSM };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/csm/CSM.js"],"names":["Matrix4","Vector3","Box3","DirectionalLight","MathUtils","ShaderChunk","Vector2","Frustum","Shader","_cameraToLightMatrix","_lightSpaceFrustum","_center","_bbox","_uniformArray","_logArray","CSM","constructor","data","camera","parent","cascades","maxFar","mode","shadowMapSize","shadowBias","lightDirection","normalize","lightIntensity","lightNear","lightFar","lightMargin","customSplitsCallback","fade","mainFrustum","frustums","breaks","lights","shaders","Map","createLights","updateFrustums","injectInclude","i","light","castShadow","shadow","mapSize","width","height","near","far","bias","add","target","push","initCascades","updateProjectionMatrix","setFromProjectionMatrix","projectionMatrix","split","updateShadowBounds","length","shadowCam","frustum","nearVerts","vertices","farVerts","point1","point2","distanceTo","squaredBBWidth","Math","max","linearDepth","z","margin","pow","left","right","top","bottom","getBreaks","min","uniformSplit","logarithmicSplit","practicalSplit","undefined","console","error","amount","lambda","lerp","update","texelWidth","texelHeight","updateMatrixWorld","multiplyMatrices","matrixWorldInverse","matrixWorld","toSpace","makeEmpty","j","expandByPoint","getCenter","x","floor","y","applyMatrix4","position","copy","lights_fragment_begin","lights_pars_begin","setupMaterial","material","defines","USE_CSM","CSM_CASCADES","CSM_FADE","breaksVec2","scope","onBeforeCompile","shader","getExtendedBreaks","uniforms","CSM_cascades","value","cameraNear","shadowFar","set","updateUniforms","forEach","needsUpdate","prev","remove","dispose","clear"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,OAAlB,EAA2BC,IAA3B,EAAiCC,gBAAjC,EAAmDC,SAAnD,EAA8DC,WAA9D,EAA2EC,OAA3E,QAA0F,OAA1F;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,MAAP,MAAmB,aAAnB;;AAEA,MAAMC,oBAAoB,GAAG,IAAIT,OAAJ,EAA7B;;AAEA,MAAMU,kBAAkB,GAAG,IAAIH,OAAJ,EAA3B;;AAEA,MAAMI,OAAO,GAAG,IAAIV,OAAJ,EAAhB;;AAEA,MAAMW,KAAK,GAAG,IAAIV,IAAJ,EAAd;;AAEA,MAAMW,aAAa,GAAG,EAAtB;AACA,MAAMC,SAAS,GAAG,EAAlB;;AACA,MAAMC,GAAN,CAAU;AACRC,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChBA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,SAAKC,MAAL,GAAcD,IAAI,CAACC,MAAnB;AACA,SAAKC,MAAL,GAAcF,IAAI,CAACE,MAAnB;AACA,SAAKC,QAAL,GAAgBH,IAAI,CAACG,QAAL,IAAiB,CAAjC;AACA,SAAKC,MAAL,GAAcJ,IAAI,CAACI,MAAL,IAAe,MAA7B;AACA,SAAKC,IAAL,GAAYL,IAAI,CAACK,IAAL,IAAa,WAAzB;AACA,SAAKC,aAAL,GAAqBN,IAAI,CAACM,aAAL,IAAsB,IAA3C;AACA,SAAKC,UAAL,GAAkBP,IAAI,CAACO,UAAL,IAAmB,QAArC;AACA,SAAKC,cAAL,GAAsBR,IAAI,CAACQ,cAAL,IAAuB,IAAIxB,OAAJ,CAAY,CAAZ,EAAe,CAAC,CAAhB,EAAmB,CAAnB,EAAsByB,SAAtB,EAA7C;AACA,SAAKC,cAAL,GAAsBV,IAAI,CAACU,cAAL,IAAuB,CAA7C;AACA,SAAKC,SAAL,GAAiBX,IAAI,CAACW,SAAL,IAAkB,CAAnC;AACA,SAAKC,QAAL,GAAgBZ,IAAI,CAACY,QAAL,IAAiB,IAAjC;AACA,SAAKC,WAAL,GAAmBb,IAAI,CAACa,WAAL,IAAoB,GAAvC;AACA,SAAKC,oBAAL,GAA4Bd,IAAI,CAACc,oBAAjC;AACA,SAAKC,IAAL,GAAY,KAAZ;AACA,SAAKC,WAAL,GAAmB,IAAI1B,OAAJ,EAAnB;AACA,SAAK2B,QAAL,GAAgB,EAAhB;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;AACA,SAAKC,YAAL;AACA,SAAKC,cAAL;AACA,SAAKC,aAAL;AACD;;AAEDF,EAAAA,YAAY,GAAG;AACb,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtB,QAAzB,EAAmCsB,CAAC,EAApC,EAAwC;AACtC,YAAMC,KAAK,GAAG,IAAIxC,gBAAJ,CAAqB,QAArB,EAA+B,KAAKwB,cAApC,CAAd;AACAgB,MAAAA,KAAK,CAACC,UAAN,GAAmB,IAAnB;AACAD,MAAAA,KAAK,CAACE,MAAN,CAAaC,OAAb,CAAqBC,KAArB,GAA6B,KAAKxB,aAAlC;AACAoB,MAAAA,KAAK,CAACE,MAAN,CAAaC,OAAb,CAAqBE,MAArB,GAA8B,KAAKzB,aAAnC;AACAoB,MAAAA,KAAK,CAACE,MAAN,CAAa3B,MAAb,CAAoB+B,IAApB,GAA2B,KAAKrB,SAAhC;AACAe,MAAAA,KAAK,CAACE,MAAN,CAAa3B,MAAb,CAAoBgC,GAApB,GAA0B,KAAKrB,QAA/B;AACAc,MAAAA,KAAK,CAACE,MAAN,CAAaM,IAAb,GAAoB,KAAK3B,UAAzB;AACA,WAAKL,MAAL,CAAYiC,GAAZ,CAAgBT,KAAhB;AACA,WAAKxB,MAAL,CAAYiC,GAAZ,CAAgBT,KAAK,CAACU,MAAtB;AACA,WAAKjB,MAAL,CAAYkB,IAAZ,CAAiBX,KAAjB;AACD;AACF;;AAEDY,EAAAA,YAAY,GAAG;AACb,UAAMrC,MAAM,GAAG,KAAKA,MAApB;AACAA,IAAAA,MAAM,CAACsC,sBAAP;AACA,SAAKvB,WAAL,CAAiBwB,uBAAjB,CAAyCvC,MAAM,CAACwC,gBAAhD,EAAkE,KAAKrC,MAAvE;AACA,SAAKY,WAAL,CAAiB0B,KAAjB,CAAuB,KAAKxB,MAA5B,EAAoC,KAAKD,QAAzC;AACD;;AAED0B,EAAAA,kBAAkB,GAAG;AACnB,UAAM1B,QAAQ,GAAG,KAAKA,QAAtB;;AAEA,SAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,QAAQ,CAAC2B,MAA7B,EAAqCnB,CAAC,EAAtC,EAA0C;AACxC,YAAMC,KAAK,GAAG,KAAKP,MAAL,CAAYM,CAAZ,CAAd;AACA,YAAMoB,SAAS,GAAGnB,KAAK,CAACE,MAAN,CAAa3B,MAA/B;AACA,YAAM6C,OAAO,GAAG,KAAK7B,QAAL,CAAcQ,CAAd,CAAhB,CAHwC,CAGN;AAClC;AACA;;AAEA,YAAMsB,SAAS,GAAGD,OAAO,CAACE,QAAR,CAAiBhB,IAAnC;AACA,YAAMiB,QAAQ,GAAGH,OAAO,CAACE,QAAR,CAAiBf,GAAlC;AACA,YAAMiB,MAAM,GAAGD,QAAQ,CAAC,CAAD,CAAvB;AACA,UAAIE,MAAJ;;AAEA,UAAID,MAAM,CAACE,UAAP,CAAkBH,QAAQ,CAAC,CAAD,CAA1B,IAAiCC,MAAM,CAACE,UAAP,CAAkBL,SAAS,CAAC,CAAD,CAA3B,CAArC,EAAsE;AACpEI,QAAAA,MAAM,GAAGF,QAAQ,CAAC,CAAD,CAAjB;AACD,OAFD,MAEO;AACLE,QAAAA,MAAM,GAAGJ,SAAS,CAAC,CAAD,CAAlB;AACD;;AAED,UAAIM,cAAc,GAAGH,MAAM,CAACE,UAAP,CAAkBD,MAAlB,CAArB;;AAEA,UAAI,KAAKpC,IAAT,EAAe;AACb;AACA,cAAMd,MAAM,GAAG,KAAKA,MAApB;AACA,cAAMgC,GAAG,GAAGqB,IAAI,CAACC,GAAL,CAAStD,MAAM,CAACgC,GAAhB,EAAqB,KAAK7B,MAA1B,CAAZ;AACA,cAAMoD,WAAW,GAAGV,OAAO,CAACE,QAAR,CAAiBf,GAAjB,CAAqB,CAArB,EAAwBwB,CAAxB,IAA6BxB,GAAG,GAAGhC,MAAM,CAAC+B,IAA1C,CAApB;AACA,cAAM0B,MAAM,GAAG,OAAOJ,IAAI,CAACK,GAAL,CAASH,WAAT,EAAsB,GAAtB,CAAP,IAAqCvB,GAAG,GAAGhC,MAAM,CAAC+B,IAAlD,CAAf;AACAqB,QAAAA,cAAc,IAAIK,MAAlB;AACD;;AAEDb,MAAAA,SAAS,CAACe,IAAV,GAAiB,CAACP,cAAD,GAAkB,CAAnC;AACAR,MAAAA,SAAS,CAACgB,KAAV,GAAkBR,cAAc,GAAG,CAAnC;AACAR,MAAAA,SAAS,CAACiB,GAAV,GAAgBT,cAAc,GAAG,CAAjC;AACAR,MAAAA,SAAS,CAACkB,MAAV,GAAmB,CAACV,cAAD,GAAkB,CAArC;AACAR,MAAAA,SAAS,CAACN,sBAAV;AACD;AACF;;AAEDyB,EAAAA,SAAS,GAAG;AACV,UAAM/D,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMgC,GAAG,GAAGqB,IAAI,CAACW,GAAL,CAAShE,MAAM,CAACgC,GAAhB,EAAqB,KAAK7B,MAA1B,CAAZ;AACA,SAAKc,MAAL,CAAY0B,MAAZ,GAAqB,CAArB;;AAEA,YAAQ,KAAKvC,IAAb;AACE,WAAK,SAAL;AACE6D,QAAAA,YAAY,CAAC,KAAK/D,QAAN,EAAgBF,MAAM,CAAC+B,IAAvB,EAA6BC,GAA7B,EAAkC,KAAKf,MAAvC,CAAZ;AACA;;AAEF,WAAK,aAAL;AACEiD,QAAAA,gBAAgB,CAAC,KAAKhE,QAAN,EAAgBF,MAAM,CAAC+B,IAAvB,EAA6BC,GAA7B,EAAkC,KAAKf,MAAvC,CAAhB;AACA;;AAEF,WAAK,WAAL;AACEkD,QAAAA,cAAc,CAAC,KAAKjE,QAAN,EAAgBF,MAAM,CAAC+B,IAAvB,EAA6BC,GAA7B,EAAkC,GAAlC,EAAuC,KAAKf,MAA5C,CAAd;AACA;;AAEF,WAAK,QAAL;AACE,YAAI,KAAKJ,oBAAL,KAA8BuD,SAAlC,EAA6CC,OAAO,CAACC,KAAR,CAAc,gDAAd;AAC7C,aAAKzD,oBAAL,CAA0B,KAAKX,QAA/B,EAAyCF,MAAM,CAAC+B,IAAhD,EAAsDC,GAAtD,EAA2D,KAAKf,MAAhE;AACA;AAhBJ;;AAmBA,aAASgD,YAAT,CAAsBM,MAAtB,EAA8BxC,IAA9B,EAAoCC,GAApC,EAAyCG,MAAzC,EAAiD;AAC/C,WAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+C,MAApB,EAA4B/C,CAAC,EAA7B,EAAiC;AAC/BW,QAAAA,MAAM,CAACC,IAAP,CAAY,CAACL,IAAI,GAAG,CAACC,GAAG,GAAGD,IAAP,IAAeP,CAAf,GAAmB+C,MAA3B,IAAqCvC,GAAjD;AACD;;AAEDG,MAAAA,MAAM,CAACC,IAAP,CAAY,CAAZ;AACD;;AAED,aAAS8B,gBAAT,CAA0BK,MAA1B,EAAkCxC,IAAlC,EAAwCC,GAAxC,EAA6CG,MAA7C,EAAqD;AACnD,WAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+C,MAApB,EAA4B/C,CAAC,EAA7B,EAAiC;AAC/BW,QAAAA,MAAM,CAACC,IAAP,CAAYL,IAAI,GAAG,CAACC,GAAG,GAAGD,IAAP,MAAiBP,CAAC,GAAG+C,MAArB,CAAP,GAAsCvC,GAAlD;AACD;;AAEDG,MAAAA,MAAM,CAACC,IAAP,CAAY,CAAZ;AACD;;AAED,aAAS+B,cAAT,CAAwBI,MAAxB,EAAgCxC,IAAhC,EAAsCC,GAAtC,EAA2CwC,MAA3C,EAAmDrC,MAAnD,EAA2D;AACzDxC,MAAAA,aAAa,CAACgD,MAAd,GAAuB,CAAvB;AACA/C,MAAAA,SAAS,CAAC+C,MAAV,GAAmB,CAAnB;AACAuB,MAAAA,gBAAgB,CAACK,MAAD,EAASxC,IAAT,EAAeC,GAAf,EAAoBpC,SAApB,CAAhB;AACAqE,MAAAA,YAAY,CAACM,MAAD,EAASxC,IAAT,EAAeC,GAAf,EAAoBrC,aAApB,CAAZ;;AAEA,WAAK,IAAI6B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+C,MAApB,EAA4B/C,CAAC,EAA7B,EAAiC;AAC/BW,QAAAA,MAAM,CAACC,IAAP,CAAYlD,SAAS,CAACuF,IAAV,CAAe9E,aAAa,CAAC6B,CAAC,GAAG,CAAL,CAA5B,EAAqC5B,SAAS,CAAC4B,CAAC,GAAG,CAAL,CAA9C,EAAuDgD,MAAvD,CAAZ;AACD;;AAEDrC,MAAAA,MAAM,CAACC,IAAP,CAAY,CAAZ;AACD;AACF;;AAEDsC,EAAAA,MAAM,GAAG;AACP,UAAM1E,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMgB,QAAQ,GAAG,KAAKA,QAAtB;;AAEA,SAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,QAAQ,CAAC2B,MAA7B,EAAqCnB,CAAC,EAAtC,EAA0C;AACxC,YAAMC,KAAK,GAAG,KAAKP,MAAL,CAAYM,CAAZ,CAAd;AACA,YAAMoB,SAAS,GAAGnB,KAAK,CAACE,MAAN,CAAa3B,MAA/B;AACA,YAAM2E,UAAU,GAAG,CAAC/B,SAAS,CAACgB,KAAV,GAAkBhB,SAAS,CAACe,IAA7B,IAAqC,KAAKtD,aAA7D;AACA,YAAMuE,WAAW,GAAG,CAAChC,SAAS,CAACiB,GAAV,GAAgBjB,SAAS,CAACkB,MAA3B,IAAqC,KAAKzD,aAA9D;AACAoB,MAAAA,KAAK,CAACE,MAAN,CAAa3B,MAAb,CAAoB6E,iBAApB,CAAsC,IAAtC;;AAEAtF,MAAAA,oBAAoB,CAACuF,gBAArB,CAAsCrD,KAAK,CAACE,MAAN,CAAa3B,MAAb,CAAoB+E,kBAA1D,EAA8E/E,MAAM,CAACgF,WAArF;;AAEAhE,MAAAA,QAAQ,CAACQ,CAAD,CAAR,CAAYyD,OAAZ,CAAoB1F,oBAApB,EAA0CC,kBAA1C;AACA,YAAMsD,SAAS,GAAGtD,kBAAkB,CAACuD,QAAnB,CAA4BhB,IAA9C;AACA,YAAMiB,QAAQ,GAAGxD,kBAAkB,CAACuD,QAAnB,CAA4Bf,GAA7C;;AAEAtC,MAAAA,KAAK,CAACwF,SAAN;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1BzF,QAAAA,KAAK,CAAC0F,aAAN,CAAoBtC,SAAS,CAACqC,CAAD,CAA7B;;AAEAzF,QAAAA,KAAK,CAAC0F,aAAN,CAAoBpC,QAAQ,CAACmC,CAAD,CAA5B;AACD;;AAEDzF,MAAAA,KAAK,CAAC2F,SAAN,CAAgB5F,OAAhB;;AAEAA,MAAAA,OAAO,CAAC+D,CAAR,GAAY9D,KAAK,CAAC4D,GAAN,CAAUE,CAAV,GAAc,KAAK5C,WAA/B;AACAnB,MAAAA,OAAO,CAAC6F,CAAR,GAAYjC,IAAI,CAACkC,KAAL,CAAW9F,OAAO,CAAC6F,CAAR,GAAYX,UAAvB,IAAqCA,UAAjD;AACAlF,MAAAA,OAAO,CAAC+F,CAAR,GAAYnC,IAAI,CAACkC,KAAL,CAAW9F,OAAO,CAAC+F,CAAR,GAAYZ,WAAvB,IAAsCA,WAAlD;;AAEAnF,MAAAA,OAAO,CAACgG,YAAR,CAAqBhE,KAAK,CAACE,MAAN,CAAa3B,MAAb,CAAoBgF,WAAzC;;AAEAvD,MAAAA,KAAK,CAACiE,QAAN,CAAeC,IAAf,CAAoBlG,OAApB;AACAgC,MAAAA,KAAK,CAACU,MAAN,CAAauD,QAAb,CAAsBC,IAAtB,CAA2BlG,OAA3B;AACAgC,MAAAA,KAAK,CAACU,MAAN,CAAauD,QAAb,CAAsBJ,CAAtB,IAA2B,KAAK/E,cAAL,CAAoB+E,CAA/C;AACA7D,MAAAA,KAAK,CAACU,MAAN,CAAauD,QAAb,CAAsBF,CAAtB,IAA2B,KAAKjF,cAAL,CAAoBiF,CAA/C;AACA/D,MAAAA,KAAK,CAACU,MAAN,CAAauD,QAAb,CAAsBlC,CAAtB,IAA2B,KAAKjD,cAAL,CAAoBiD,CAA/C;AACD;AACF;;AAEDjC,EAAAA,aAAa,GAAG;AACdpC,IAAAA,WAAW,CAACyG,qBAAZ,GAAoCtG,MAAM,CAACsG,qBAA3C;AACAzG,IAAAA,WAAW,CAAC0G,iBAAZ,GAAgCvG,MAAM,CAACuG,iBAAvC;AACD;;AAEDC,EAAAA,aAAa,CAACC,QAAD,EAAW;AACtBA,IAAAA,QAAQ,CAACC,OAAT,GAAmBD,QAAQ,CAACC,OAAT,IAAoB,EAAvC;AACAD,IAAAA,QAAQ,CAACC,OAAT,CAAiBC,OAAjB,GAA2B,CAA3B;AACAF,IAAAA,QAAQ,CAACC,OAAT,CAAiBE,YAAjB,GAAgC,KAAKhG,QAArC;;AAEA,QAAI,KAAKY,IAAT,EAAe;AACbiF,MAAAA,QAAQ,CAACC,OAAT,CAAiBG,QAAjB,GAA4B,EAA5B;AACD;;AAED,UAAMC,UAAU,GAAG,EAAnB;AACA,UAAMC,KAAK,GAAG,IAAd;AACA,UAAMlF,OAAO,GAAG,KAAKA,OAArB;;AAEA4E,IAAAA,QAAQ,CAACO,eAAT,GAA2BC,MAAM,IAAI;AACnC,YAAMvE,GAAG,GAAGqB,IAAI,CAACW,GAAL,CAASqC,KAAK,CAACrG,MAAN,CAAagC,GAAtB,EAA2BqE,KAAK,CAAClG,MAAjC,CAAZ;AACAkG,MAAAA,KAAK,CAACG,iBAAN,CAAwBJ,UAAxB;AACAG,MAAAA,MAAM,CAACE,QAAP,CAAgBC,YAAhB,GAA+B;AAC7BC,QAAAA,KAAK,EAAEP;AADsB,OAA/B;AAGAG,MAAAA,MAAM,CAACE,QAAP,CAAgBG,UAAhB,GAA6B;AAC3BD,QAAAA,KAAK,EAAEN,KAAK,CAACrG,MAAN,CAAa+B;AADO,OAA7B;AAGAwE,MAAAA,MAAM,CAACE,QAAP,CAAgBI,SAAhB,GAA4B;AAC1BF,QAAAA,KAAK,EAAE3E;AADmB,OAA5B;AAGAb,MAAAA,OAAO,CAAC2F,GAAR,CAAYf,QAAZ,EAAsBQ,MAAtB;AACD,KAbD;;AAeApF,IAAAA,OAAO,CAAC2F,GAAR,CAAYf,QAAZ,EAAsB,IAAtB;AACD;;AAEDgB,EAAAA,cAAc,GAAG;AACf,UAAM/E,GAAG,GAAGqB,IAAI,CAACW,GAAL,CAAS,KAAKhE,MAAL,CAAYgC,GAArB,EAA0B,KAAK7B,MAA/B,CAAZ;AACA,UAAMgB,OAAO,GAAG,KAAKA,OAArB;AACAA,IAAAA,OAAO,CAAC6F,OAAR,CAAgB,UAAUT,MAAV,EAAkBR,QAAlB,EAA4B;AAC1C,UAAIQ,MAAM,KAAK,IAAf,EAAqB;AACnB,cAAME,QAAQ,GAAGF,MAAM,CAACE,QAAxB;AACA,aAAKD,iBAAL,CAAuBC,QAAQ,CAACC,YAAT,CAAsBC,KAA7C;AACAF,QAAAA,QAAQ,CAACG,UAAT,CAAoBD,KAApB,GAA4B,KAAK3G,MAAL,CAAY+B,IAAxC;AACA0E,QAAAA,QAAQ,CAACI,SAAT,CAAmBF,KAAnB,GAA2B3E,GAA3B;AACD;;AAED,UAAI,CAAC,KAAKlB,IAAN,IAAc,cAAciF,QAAQ,CAACC,OAAzC,EAAkD;AAChD,eAAOD,QAAQ,CAACC,OAAT,CAAiBG,QAAxB;AACAJ,QAAAA,QAAQ,CAACkB,WAAT,GAAuB,IAAvB;AACD,OAHD,MAGO,IAAI,KAAKnG,IAAL,IAAa,EAAE,cAAciF,QAAQ,CAACC,OAAzB,CAAjB,EAAoD;AACzDD,QAAAA,QAAQ,CAACC,OAAT,CAAiBG,QAAjB,GAA4B,EAA5B;AACAJ,QAAAA,QAAQ,CAACkB,WAAT,GAAuB,IAAvB;AACD;AACF,KAfD,EAeG,IAfH;AAgBD;;AAEDT,EAAAA,iBAAiB,CAACrE,MAAD,EAAS;AACxB,WAAOA,MAAM,CAACQ,MAAP,GAAgB,KAAK1B,MAAL,CAAY0B,MAAnC,EAA2C;AACzCR,MAAAA,MAAM,CAACC,IAAP,CAAY,IAAIhD,OAAJ,EAAZ;AACD;;AAED+C,IAAAA,MAAM,CAACQ,MAAP,GAAgB,KAAK1B,MAAL,CAAY0B,MAA5B;;AAEA,SAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtB,QAAzB,EAAmCsB,CAAC,EAApC,EAAwC;AACtC,YAAM+C,MAAM,GAAG,KAAKtD,MAAL,CAAYO,CAAZ,CAAf;AACA,YAAM0F,IAAI,GAAG,KAAKjG,MAAL,CAAYO,CAAC,GAAG,CAAhB,KAAsB,CAAnC;AACAW,MAAAA,MAAM,CAACX,CAAD,CAAN,CAAU8D,CAAV,GAAc4B,IAAd;AACA/E,MAAAA,MAAM,CAACX,CAAD,CAAN,CAAUgE,CAAV,GAAcjB,MAAd;AACD;AACF;;AAEDjD,EAAAA,cAAc,GAAG;AACf,SAAKyC,SAAL;AACA,SAAK1B,YAAL;AACA,SAAKK,kBAAL;AACA,SAAKqE,cAAL;AACD;;AAEDI,EAAAA,MAAM,GAAG;AACP,SAAK,IAAI3F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKN,MAAL,CAAYyB,MAAhC,EAAwCnB,CAAC,EAAzC,EAA6C;AAC3C,WAAKvB,MAAL,CAAYkH,MAAZ,CAAmB,KAAKjG,MAAL,CAAYM,CAAZ,CAAnB;AACD;AACF;;AAED4F,EAAAA,OAAO,GAAG;AACR,UAAMjG,OAAO,GAAG,KAAKA,OAArB;AACAA,IAAAA,OAAO,CAAC6F,OAAR,CAAgB,CAACT,MAAD,EAASR,QAAT,KAAsB;AACpC,aAAOA,QAAQ,CAACO,eAAhB;AACA,aAAOP,QAAQ,CAACC,OAAT,CAAiBC,OAAxB;AACA,aAAOF,QAAQ,CAACC,OAAT,CAAiBE,YAAxB;AACA,aAAOH,QAAQ,CAACC,OAAT,CAAiBG,QAAxB;;AAEA,UAAII,MAAM,KAAK,IAAf,EAAqB;AACnB,eAAOA,MAAM,CAACE,QAAP,CAAgBC,YAAvB;AACA,eAAOH,MAAM,CAACE,QAAP,CAAgBG,UAAvB;AACA,eAAOL,MAAM,CAACE,QAAP,CAAgBI,SAAvB;AACD;;AAEDd,MAAAA,QAAQ,CAACkB,WAAT,GAAuB,IAAvB;AACD,KAbD;AAcA9F,IAAAA,OAAO,CAACkG,KAAR;AACD;;AA9RO;;AAkSV,SAASxH,GAAT","sourcesContent":["import { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from 'three';\nimport Frustum from './Frustum.js';\nimport Shader from './Shader.js';\n\nconst _cameraToLightMatrix = new Matrix4();\n\nconst _lightSpaceFrustum = new Frustum();\n\nconst _center = new Vector3();\n\nconst _bbox = new Box3();\n\nconst _uniformArray = [];\nconst _logArray = [];\nclass CSM {\n  constructor(data) {\n    data = data || {};\n    this.camera = data.camera;\n    this.parent = data.parent;\n    this.cascades = data.cascades || 3;\n    this.maxFar = data.maxFar || 100000;\n    this.mode = data.mode || 'practical';\n    this.shadowMapSize = data.shadowMapSize || 2048;\n    this.shadowBias = data.shadowBias || 0.000001;\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n    this.lightIntensity = data.lightIntensity || 1;\n    this.lightNear = data.lightNear || 1;\n    this.lightFar = data.lightFar || 2000;\n    this.lightMargin = data.lightMargin || 200;\n    this.customSplitsCallback = data.customSplitsCallback;\n    this.fade = false;\n    this.mainFrustum = new Frustum();\n    this.frustums = [];\n    this.breaks = [];\n    this.lights = [];\n    this.shaders = new Map();\n    this.createLights();\n    this.updateFrustums();\n    this.injectInclude();\n  }\n\n  createLights() {\n    for (let i = 0; i < this.cascades; i++) {\n      const light = new DirectionalLight(0xffffff, this.lightIntensity);\n      light.castShadow = true;\n      light.shadow.mapSize.width = this.shadowMapSize;\n      light.shadow.mapSize.height = this.shadowMapSize;\n      light.shadow.camera.near = this.lightNear;\n      light.shadow.camera.far = this.lightFar;\n      light.shadow.bias = this.shadowBias;\n      this.parent.add(light);\n      this.parent.add(light.target);\n      this.lights.push(light);\n    }\n  }\n\n  initCascades() {\n    const camera = this.camera;\n    camera.updateProjectionMatrix();\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n    this.mainFrustum.split(this.breaks, this.frustums);\n  }\n\n  updateShadowBounds() {\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const frustum = this.frustums[i]; // Get the two points that represent that furthest points on the frustum assuming\n      // that's either the diagonal across the far plane or the diagonal across the whole\n      // frustum itself.\n\n      const nearVerts = frustum.vertices.near;\n      const farVerts = frustum.vertices.far;\n      const point1 = farVerts[0];\n      let point2;\n\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n        point2 = farVerts[2];\n      } else {\n        point2 = nearVerts[2];\n      }\n\n      let squaredBBWidth = point1.distanceTo(point2);\n\n      if (this.fade) {\n        // expand the shadow extents by the fade margin if fade is enabled.\n        const camera = this.camera;\n        const far = Math.max(camera.far, this.maxFar);\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n        const margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);\n        squaredBBWidth += margin;\n      }\n\n      shadowCam.left = -squaredBBWidth / 2;\n      shadowCam.right = squaredBBWidth / 2;\n      shadowCam.top = squaredBBWidth / 2;\n      shadowCam.bottom = -squaredBBWidth / 2;\n      shadowCam.updateProjectionMatrix();\n    }\n  }\n\n  getBreaks() {\n    const camera = this.camera;\n    const far = Math.min(camera.far, this.maxFar);\n    this.breaks.length = 0;\n\n    switch (this.mode) {\n      case 'uniform':\n        uniformSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'logarithmic':\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'practical':\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n        break;\n\n      case 'custom':\n        if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n        break;\n    }\n\n    function uniformSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near + (far - near) * i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function logarithmicSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push(near * (far / near) ** (i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function practicalSplit(amount, near, far, lambda, target) {\n      _uniformArray.length = 0;\n      _logArray.length = 0;\n      logarithmicSplit(amount, near, far, _logArray);\n      uniformSplit(amount, near, far, _uniformArray);\n\n      for (let i = 1; i < amount; i++) {\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n      }\n\n      target.push(1);\n    }\n  }\n\n  update() {\n    const camera = this.camera;\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n      light.shadow.camera.updateMatrixWorld(true);\n\n      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\n\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n      const nearVerts = _lightSpaceFrustum.vertices.near;\n      const farVerts = _lightSpaceFrustum.vertices.far;\n\n      _bbox.makeEmpty();\n\n      for (let j = 0; j < 4; j++) {\n        _bbox.expandByPoint(nearVerts[j]);\n\n        _bbox.expandByPoint(farVerts[j]);\n      }\n\n      _bbox.getCenter(_center);\n\n      _center.z = _bbox.max.z + this.lightMargin;\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n\n      _center.applyMatrix4(light.shadow.camera.matrixWorld);\n\n      light.position.copy(_center);\n      light.target.position.copy(_center);\n      light.target.position.x += this.lightDirection.x;\n      light.target.position.y += this.lightDirection.y;\n      light.target.position.z += this.lightDirection.z;\n    }\n  }\n\n  injectInclude() {\n    ShaderChunk.lights_fragment_begin = Shader.lights_fragment_begin;\n    ShaderChunk.lights_pars_begin = Shader.lights_pars_begin;\n  }\n\n  setupMaterial(material) {\n    material.defines = material.defines || {};\n    material.defines.USE_CSM = 1;\n    material.defines.CSM_CASCADES = this.cascades;\n\n    if (this.fade) {\n      material.defines.CSM_FADE = '';\n    }\n\n    const breaksVec2 = [];\n    const scope = this;\n    const shaders = this.shaders;\n\n    material.onBeforeCompile = shader => {\n      const far = Math.min(scope.camera.far, scope.maxFar);\n      scope.getExtendedBreaks(breaksVec2);\n      shader.uniforms.CSM_cascades = {\n        value: breaksVec2\n      };\n      shader.uniforms.cameraNear = {\n        value: scope.camera.near\n      };\n      shader.uniforms.shadowFar = {\n        value: far\n      };\n      shaders.set(material, shader);\n    };\n\n    shaders.set(material, null);\n  }\n\n  updateUniforms() {\n    const far = Math.min(this.camera.far, this.maxFar);\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      if (shader !== null) {\n        const uniforms = shader.uniforms;\n        this.getExtendedBreaks(uniforms.CSM_cascades.value);\n        uniforms.cameraNear.value = this.camera.near;\n        uniforms.shadowFar.value = far;\n      }\n\n      if (!this.fade && 'CSM_FADE' in material.defines) {\n        delete material.defines.CSM_FADE;\n        material.needsUpdate = true;\n      } else if (this.fade && !('CSM_FADE' in material.defines)) {\n        material.defines.CSM_FADE = '';\n        material.needsUpdate = true;\n      }\n    }, this);\n  }\n\n  getExtendedBreaks(target) {\n    while (target.length < this.breaks.length) {\n      target.push(new Vector2());\n    }\n\n    target.length = this.breaks.length;\n\n    for (let i = 0; i < this.cascades; i++) {\n      const amount = this.breaks[i];\n      const prev = this.breaks[i - 1] || 0;\n      target[i].x = prev;\n      target[i].y = amount;\n    }\n  }\n\n  updateFrustums() {\n    this.getBreaks();\n    this.initCascades();\n    this.updateShadowBounds();\n    this.updateUniforms();\n  }\n\n  remove() {\n    for (let i = 0; i < this.lights.length; i++) {\n      this.parent.remove(this.lights[i]);\n    }\n  }\n\n  dispose() {\n    const shaders = this.shaders;\n    shaders.forEach((shader, material) => {\n      delete material.onBeforeCompile;\n      delete material.defines.USE_CSM;\n      delete material.defines.CSM_CASCADES;\n      delete material.defines.CSM_FADE;\n\n      if (shader !== null) {\n        delete shader.uniforms.CSM_cascades;\n        delete shader.uniforms.cameraNear;\n        delete shader.uniforms.shadowFar;\n      }\n\n      material.needsUpdate = true;\n    });\n    shaders.clear();\n  }\n\n}\n\nexport { CSM };\n"]},"metadata":{},"sourceType":"module"}