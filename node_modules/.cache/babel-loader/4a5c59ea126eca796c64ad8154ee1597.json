{"ast":null,"code":"import { TransactionLevel, CriteriaComparions } from \"./BadgeHelperTypes\";\nexport const parseResponseForItems = response => {\n  if (!response || !response.data || !response.data.data) {\n    return null;\n  }\n\n  return response.data.data.items;\n};\nexport const getSuccessfulTransactionCount = items => {\n  let successCount = 0;\n  items.forEach(item => {\n    if (item.successful === true) {\n      successCount++;\n    }\n  });\n  return successCount;\n};\nexport const parseForBadgesForTypes = values => {\n  return [...extractBadgesForBadgeCriteria('successfulTransactions', values[0]), ...extractBadgesForBadgeCriteria('accountCreation', 1)];\n};\nexport const extractBadgesForBadgeCriteria = (badgeType, valueAchieved) => {\n  let successCount = 0;\n  let extractedBadges = [];\n  ALL_BADGES['metaPortal'][badgeType]['greaterThan'].forEach(badgeItem => {\n    if (valueAchieved > badgeItem.value) {\n      extractedBadges.push(badgeItem);\n    }\n  });\n  return extractedBadges;\n};\nexport const RANDOM_VISOR_COLORS = ['black', 'white', 'grey', 'green', 'blue', 'hot-pink', 'purple', 'silver', 'bronze', 'gold'];\nexport const ALL_BADGES = {\n  metaPortal: {\n    accountCreation: {\n      greaterThan: [{\n        value: 0,\n        badgeName: 'Space Cadet'\n      }, {\n        value: 0,\n        badgeName: 'GM Rank 1'\n      }]\n    },\n    successfulTransactions: {\n      greaterThan: [{\n        value: 25,\n        badgeName: 'Explorer Rank 1'\n      }, {\n        value: 50,\n        badgeName: 'Explorer Rank 2'\n      }, {\n        value: 75,\n        badgeName: 'Explorer Rank 3'\n      }, {\n        value: 100,\n        badgeName: 'Sky Captain Rank 1'\n      }]\n    }\n  }\n};\nexport const calculateFrequencyForKeyValueMatches = (transactions, key, value, valueMatching) => {\n  if (valueMatching) {\n    // matches if 'key' found && key maps to 'value'\n    return getKeyValueMatchCount(transactions, key, value);\n  } else {\n    // matches if 'key' found\n    return getKeyMatchCount(transactions, key);\n  }\n};\nexport const parseTransactionsForRules = transactions => {\n  const rules = [{\n    level: TransactionLevel.Root,\n    keyValueObject: {\n      name: 'successful',\n      value: true\n    },\n    useKeyValueMatching: true\n  }];\n};\nexport const getKeyValueMatchCount = (items, key, value) => {\n  let count = 0;\n  items.forEach(item => {\n    if (item[key] && item[key] === value) {\n      count++;\n    }\n  });\n  return count;\n};\nexport const getKeyMatchCount = (items, key) => {\n  let count = 0;\n  items.forEach(item => {\n    if (item[key]) {\n      count++;\n    }\n  });\n  return count;\n};\nexport const getValidBadges = (badges, transactions) => {\n  let validBadges = [];\n  badges.forEach(badge => {\n    if (validateBadgeAgainstTransactions(badge, transactions)) {\n      validBadges.push(badge);\n    }\n  });\n  return validBadges;\n};\nexport const validateBadgeAgainstTransactions = (badge, transactions) => {\n  let isValid = false;\n\n  switch (badge.parseRules.level) {\n    case TransactionLevel.Root:\n      // compare with rules\n      isValid = executeRootLevelChecksForBadge(badge.parseRules, transactions);\n      return isValid;\n\n    default:\n      return false;\n  }\n};\nexport const executeRootLevelChecksForBadge = (rules, transactions) => {\n  // defaulting to Key Match frequency comparisons\n  return executeFrequencyRuleForBadge(rules.keyValueObject.name, rules.keyValueObject.value, rules.criteria.comparison, rules.criteria.value, rules.useKeyValueMatching, transactions);\n};\nexport const executeFrequencyRuleForBadge = (key, value, criteriaRule, criteriaValue, isValueMathing, transactions) => {\n  // defaulting to Key Match frequency comparisons\n  let isValid = false;\n  const frequency = calculateFrequencyForKeyValueMatches(transactions, key, value, isValueMathing);\n\n  switch (criteriaRule) {\n    case CriteriaComparions.GT:\n      return frequency > criteriaValue;\n\n    case CriteriaComparions.LT:\n      return frequency < criteriaValue;\n\n    default:\n      return false;\n  }\n\n  return isValid;\n};","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/src/portalHooks/BadgeHelper.ts"],"names":["TransactionLevel","CriteriaComparions","parseResponseForItems","response","data","items","getSuccessfulTransactionCount","successCount","forEach","item","successful","parseForBadgesForTypes","values","extractBadgesForBadgeCriteria","badgeType","valueAchieved","extractedBadges","ALL_BADGES","badgeItem","value","push","RANDOM_VISOR_COLORS","metaPortal","accountCreation","greaterThan","badgeName","successfulTransactions","calculateFrequencyForKeyValueMatches","transactions","key","valueMatching","getKeyValueMatchCount","getKeyMatchCount","parseTransactionsForRules","rules","level","Root","keyValueObject","name","useKeyValueMatching","count","getValidBadges","badges","validBadges","badge","validateBadgeAgainstTransactions","isValid","parseRules","executeRootLevelChecksForBadge","executeFrequencyRuleForBadge","criteria","comparison","criteriaRule","criteriaValue","isValueMathing","frequency","GT","LT"],"mappings":"AAEA,SAASA,gBAAT,EAAwCC,kBAAxC,QAAkE,oBAAlE;AAGA,OAAO,MAAMC,qBAAqB,GAAGC,QAAD,IAA2C;AAC3E,MAAG,CAACA,QAAD,IAAa,CAACA,QAAQ,CAACC,IAAvB,IAA+B,CAACD,QAAQ,CAACC,IAAT,CAAcA,IAAjD,EAAuD;AACrD,WAAO,IAAP;AACD;;AACD,SAAOD,QAAQ,CAACC,IAAT,CAAcA,IAAd,CAAmBC,KAA1B;AACD,CALI;AAOL,OAAO,MAAMC,6BAA6B,GAAGD,KAAD,IAA0B;AACpE,MAAIE,YAAY,GAAG,CAAnB;AACAF,EAAAA,KAAK,CAACG,OAAN,CAAeC,IAAD,IAAU;AACtB,QAAGA,IAAI,CAACC,UAAL,KAAoB,IAAvB,EAA6B;AAC3BH,MAAAA,YAAY;AACb;AACF,GAJD;AAKA,SAAOA,YAAP;AACD,CARM;AAWP,OAAO,MAAMI,sBAAsB,GAAGC,MAAD,IAA6B;AAChE,SAAO,CACL,GAAGC,6BAA6B,CAAC,wBAAD,EAA0BD,MAAM,CAAC,CAAD,CAAhC,CAD3B,EAEL,GAAGC,6BAA6B,CAAC,iBAAD,EAAmB,CAAnB,CAF3B,CAAP;AAID,CALM;AAQP,OAAO,MAAMA,6BAA6B,GAAG,CAACC,SAAD,EAAoBC,aAApB,KAAqD;AAChG,MAAIR,YAAY,GAAG,CAAnB;AACA,MAAIS,eAAsB,GAAG,EAA7B;AAEAC,EAAAA,UAAU,CAAC,YAAD,CAAV,CAAyBH,SAAzB,EAAoC,aAApC,EAAmDN,OAAnD,CAA4DU,SAAD,IAAoB;AAC7E,QAAGH,aAAa,GAAGG,SAAS,CAACC,KAA7B,EAAqC;AACnCH,MAAAA,eAAe,CAACI,IAAhB,CAAqBF,SAArB;AACD;AACF,GAJD;AAKA,SAAOF,eAAP;AACD,CAVM;AAYP,OAAO,MAAMK,mBAAmB,GAAG,CACjC,OADiC,EAEjC,OAFiC,EAGjC,MAHiC,EAIjC,OAJiC,EAKjC,MALiC,EAMjC,UANiC,EAOjC,QAPiC,EAQjC,QARiC,EASjC,QATiC,EAUjC,MAViC,CAA5B;AAaP,OAAO,MAAMJ,UAAe,GAAG;AAC7BK,EAAAA,UAAU,EAAG;AACXC,IAAAA,eAAe,EAAG;AAChBC,MAAAA,WAAW,EAAE,CACX;AACEL,QAAAA,KAAK,EAAE,CADT;AAEEM,QAAAA,SAAS,EAAE;AAFb,OADW,EAKX;AACEN,QAAAA,KAAK,EAAE,CADT;AAEEM,QAAAA,SAAS,EAAE;AAFb,OALW;AADG,KADP;AAaXC,IAAAA,sBAAsB,EAAG;AAEvBF,MAAAA,WAAW,EAAE,CACX;AACEL,QAAAA,KAAK,EAAE,EADT;AAEEM,QAAAA,SAAS,EAAE;AAFb,OADW,EAKX;AACEN,QAAAA,KAAK,EAAE,EADT;AAEEM,QAAAA,SAAS,EAAE;AAFb,OALW,EASX;AACEN,QAAAA,KAAK,EAAE,EADT;AAEEM,QAAAA,SAAS,EAAE;AAFb,OATW,EAaX;AACEN,QAAAA,KAAK,EAAE,GADT;AAEEM,QAAAA,SAAS,EAAE;AAFb,OAbW;AAFU;AAbd;AADgB,CAAxB;AAuCP,OAAO,MAAME,oCAAoC,GAAE,CACjDC,YADiD,EAEjDC,GAFiD,EAGjDV,KAHiD,EAIjDW,aAJiD,KAKnC;AACZ,MAAGA,aAAH,EAAkB;AAChB;AACA,WAAOC,qBAAqB,CAACH,YAAD,EAAeC,GAAf,EAAoBV,KAApB,CAA5B;AACD,GAHD,MAGO;AACH;AACA,WAAOa,gBAAgB,CAACJ,YAAD,EAAeC,GAAf,CAAvB;AACH;AACJ,CAbM;AAgBP,OAAO,MAAMI,yBAAyB,GAAGL,YAAD,IAAyB;AAE/D,QAAMM,KAAY,GAAG,CACnB;AACEC,IAAAA,KAAK,EAAEnC,gBAAgB,CAACoC,IAD1B;AAEEC,IAAAA,cAAc,EAAE;AAACC,MAAAA,IAAI,EAAE,YAAP;AAAqBnB,MAAAA,KAAK,EAAE;AAA5B,KAFlB;AAGEoB,IAAAA,mBAAmB,EAAE;AAHvB,GADmB,CAArB;AAQD,CAVM;AAaP,OAAO,MAAMR,qBAAqB,GAAG,CAAC1B,KAAD,EAAewB,GAAf,EAA4BV,KAA5B,KAA4C;AAC7E,MAAIqB,KAAK,GAAG,CAAZ;AACAnC,EAAAA,KAAK,CAACG,OAAN,CAAeC,IAAD,IAAU;AACtB,QAAGA,IAAI,CAACoB,GAAD,CAAJ,IAAapB,IAAI,CAACoB,GAAD,CAAJ,KAAcV,KAA9B,EAAqC;AACnCqB,MAAAA,KAAK;AACN;AACF,GAJD;AAKA,SAAOA,KAAP;AACH,CARM;AAUP,OAAO,MAAMR,gBAAgB,GAAG,CAAC3B,KAAD,EAAewB,GAAf,KAAgC;AAC9D,MAAIW,KAAK,GAAG,CAAZ;AACAnC,EAAAA,KAAK,CAACG,OAAN,CAAeC,IAAD,IAAU;AACtB,QAAGA,IAAI,CAACoB,GAAD,CAAP,EAAc;AACZW,MAAAA,KAAK;AACN;AACF,GAJD;AAKA,SAAOA,KAAP;AACH,CARQ;AAWT,OAAO,MAAMC,cAAc,GAAG,CAACC,MAAD,EAAkBd,YAAlB,KAAqD;AACjF,MAAIe,WAAoB,GAAG,EAA3B;AACAD,EAAAA,MAAM,CAAClC,OAAP,CAAgBoC,KAAD,IAAkB;AAC/B,QAAGC,gCAAgC,CAACD,KAAD,EAAOhB,YAAP,CAAnC,EAAwD;AACtDe,MAAAA,WAAW,CAACvB,IAAZ,CAAiBwB,KAAjB;AACD;AACF,GAJD;AAKA,SAAOD,WAAP;AACD,CARM;AAWP,OAAO,MAAME,gCAAgC,GAAG,CAACD,KAAD,EAAehB,YAAf,KAAiD;AAC/F,MAAIkB,OAAO,GAAG,KAAd;;AACA,UAAOF,KAAK,CAACG,UAAN,CAAiBZ,KAAxB;AACE,SAAKnC,gBAAgB,CAACoC,IAAtB;AACI;AACAU,MAAAA,OAAO,GAAGE,8BAA8B,CAACJ,KAAK,CAACG,UAAP,EAAkBnB,YAAlB,CAAxC;AACF,aAAOkB,OAAP;;AACF;AACE,aAAO,KAAP;AANJ;AAQD,CAVM;AAaP,OAAO,MAAME,8BAA8B,GAAG,CAACd,KAAD,EAAqBN,YAArB,KAAuD;AACnG;AACA,SAAOqB,4BAA4B,CACjCf,KAAK,CAACG,cAAN,CAAqBC,IADY,EAEjCJ,KAAK,CAACG,cAAN,CAAqBlB,KAFY,EAGjCe,KAAK,CAACgB,QAAN,CAAeC,UAHkB,EAIjCjB,KAAK,CAACgB,QAAN,CAAe/B,KAJkB,EAKjCe,KAAK,CAACK,mBAL2B,EAMjCX,YANiC,CAAnC;AAQD,CAVM;AAaP,OAAO,MAAMqB,4BAA4B,GAAG,CAC1CpB,GAD0C,EAE1CV,KAF0C,EAG1CiC,YAH0C,EAI1CC,aAJ0C,EAK1CC,cAL0C,EAM1C1B,YAN0C,KAMN;AACpC;AACA,MAAIkB,OAAO,GAAG,KAAd;AACA,QAAMS,SAAS,GAAG5B,oCAAoC,CAACC,YAAD,EAAeC,GAAf,EAAoBV,KAApB,EAA2BmC,cAA3B,CAAtD;;AAEA,UAAOF,YAAP;AACE,SAAKnD,kBAAkB,CAACuD,EAAxB;AACE,aAAOD,SAAS,GAAGF,aAAnB;;AAEF,SAAKpD,kBAAkB,CAACwD,EAAxB;AACE,aAAOF,SAAS,GAAGF,aAAnB;;AAEF;AACE,aAAO,KAAP;AARJ;;AAWA,SAAOP,OAAP;AACD,CAvBM","sourcesContent":["import { AxiosResponse } from \"axios\";\nimport { Badge } from \"react-bootstrap\";\nimport { TransactionLevel, ParseParams, CriteriaComparions } from \"./BadgeHelperTypes\";\n\n\nexport const parseResponseForItems =(response: AxiosResponse): (any[]|null) => {\n    if(!response || !response.data || !response.data.data) {\n      return null;\n    }\n    return response.data.data.items;\n  }\n  \n  export const getSuccessfulTransactionCount =(items: any[]): number => {\n    let successCount = 0;\n    items.forEach((item) => {\n      if(item.successful === true) {\n        successCount++;\n      }\n    });\n    return successCount;\n  }\n  \n  \n  export const parseForBadgesForTypes =(values: number[]): any[] => {\n    return [\n      ...extractBadgesForBadgeCriteria('successfulTransactions',values[0]),\n      ...extractBadgesForBadgeCriteria('accountCreation',1)\n    ]\n  }\n  \n  \n  export const extractBadgesForBadgeCriteria = (badgeType: string, valueAchieved: number): any[] => {\n    let successCount = 0;\n    let extractedBadges: any[] = [];\n    \n    ALL_BADGES['metaPortal'][badgeType]['greaterThan'].forEach((badgeItem: any) => {\n      if(valueAchieved > badgeItem.value ) {\n        extractedBadges.push(badgeItem);\n      }\n    });\n    return extractedBadges;\n  }\n\n  export const RANDOM_VISOR_COLORS = [\n    'black',\n    'white',\n    'grey',\n    'green',\n    'blue',\n    'hot-pink',\n    'purple',\n    'silver',\n    'bronze',\n    'gold'\n  ]\n  \n  export const ALL_BADGES: any = {\n    metaPortal : {\n      accountCreation : {\n        greaterThan: [\n          {\n            value: 0,\n            badgeName: 'Space Cadet',\n          },\n          {\n            value: 0,\n            badgeName: 'GM Rank 1',\n          },\n        ]\n      },\n      successfulTransactions : {\n  \n        greaterThan: [\n          {\n            value: 25,\n            badgeName: 'Explorer Rank 1',\n          },\n          {\n            value: 50,\n            badgeName: 'Explorer Rank 2',\n          },\n          {\n            value: 75,\n            badgeName: 'Explorer Rank 3',\n          },\n          {\n            value: 100,\n            badgeName: 'Sky Captain Rank 1',\n          }\n        ]\n      }\n    }\n  }\n\n\n  export const calculateFrequencyForKeyValueMatches =(\n    transactions: any[], \n    key: string, \n    value: number, \n    valueMatching: boolean\n    ) : number => {\n      if(valueMatching) {\n        // matches if 'key' found && key maps to 'value'\n        return getKeyValueMatchCount(transactions, key, value);\n      } else {\n          // matches if 'key' found\n          return getKeyMatchCount(transactions, key);\n      }\n  }\n\n\n  export const parseTransactionsForRules =(transactions: any[]) => {\n\n    const rules: any[] = [\n      {\n        level: TransactionLevel.Root,\n        keyValueObject: {name: 'successful', value: true} ,\n        useKeyValueMatching: true\n      }\n    ]\n\n  }\n\n\n  export const getKeyValueMatchCount = (items: any[], key: string, value: any) =>  {\n      let count = 0;\n      items.forEach((item) => {\n        if(item[key] && item[key] === value) {\n          count++;\n        }\n      });\n      return count;\n  }\n\n  export const getKeyMatchCount = (items: any[], key: string) =>  {\n    let count = 0;\n    items.forEach((item) => {\n      if(item[key]) {\n        count++;\n      }\n    });\n    return count;\n}\n\n\nexport const getValidBadges = (badges: Badge[], transactions: any[]) : Badge[] =>  {\n  let validBadges: Badge[] = [];\n  badges.forEach((badge: Badge) => {\n    if(validateBadgeAgainstTransactions(badge,transactions)){\n      validBadges.push(badge);\n    }\n  });\n  return validBadges;\n}\n\n\nexport const validateBadgeAgainstTransactions = (badge: Badge, transactions: any[]): boolean =>  {\n  let isValid = false;\n  switch(badge.parseRules.level) {\n    case TransactionLevel.Root :\n        // compare with rules\n        isValid = executeRootLevelChecksForBadge(badge.parseRules,transactions);\n      return isValid;\n    default:\n      return false;\n  }\n}\n\n\nexport const executeRootLevelChecksForBadge = (rules: ParseParams, transactions: any[]): boolean =>  {\n  // defaulting to Key Match frequency comparisons\n  return executeFrequencyRuleForBadge(\n    rules.keyValueObject.name, \n    rules.keyValueObject.value,\n    rules.criteria.comparison,\n    rules.criteria.value,\n    rules.useKeyValueMatching,\n    transactions\n    );\n}\n\n\nexport const executeFrequencyRuleForBadge = (\n  key: string, \n  value: any, \n  criteriaRule: CriteriaComparions,\n  criteriaValue: number,\n  isValueMathing: boolean,\n  transactions: any[], ): boolean =>  {\n  // defaulting to Key Match frequency comparisons\n  let isValid = false;\n  const frequency = calculateFrequencyForKeyValueMatches(transactions, key, value, isValueMathing);\n\n  switch(criteriaRule) {\n    case CriteriaComparions.GT : \n      return frequency > criteriaValue;\n\n    case CriteriaComparions.LT : \n      return frequency < criteriaValue;\n\n    default:\n      return false;\n  }\n\n  return isValid;\n}"]},"metadata":{},"sourceType":"module"}