{"ast":null,"code":"import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nconst boundingBox = /* @__PURE__ */new Box3();\n\nclass MeshBVHRootVisualizer extends Object3D {\n  get isMesh() {\n    return !this.displayEdges;\n  }\n\n  get isLineSegments() {\n    return this.displayEdges;\n  }\n\n  get isLine() {\n    return this.displayEdges;\n  }\n\n  constructor(mesh, material) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    let group = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    super();\n    this.material = material;\n    this.geometry = new BufferGeometry();\n    this.name = 'MeshBVHRootVisualizer';\n    this.depth = depth;\n    this.displayParents = false;\n    this.mesh = mesh;\n    this.displayEdges = true;\n    this._group = group;\n  }\n\n  raycast() {}\n\n  update() {\n    const geometry = this.geometry;\n    const boundsTree = this.mesh.geometry.boundsTree;\n    const group = this._group;\n    geometry.dispose();\n    this.visible = false;\n\n    if (boundsTree) {\n      // count the number of bounds required\n      const targetDepth = this.depth - 1;\n      const displayParents = this.displayParents;\n      let boundsCount = 0;\n      boundsTree.traverse((depth, isLeaf) => {\n        if (depth === targetDepth || isLeaf) {\n          boundsCount++;\n          return true;\n        } else if (displayParents) {\n          boundsCount++;\n        }\n      }, group); // fill in the position buffer with the bounds corners\n\n      let posIndex = 0;\n      const positionArray = new Float32Array(8 * 3 * boundsCount);\n      boundsTree.traverse((depth, isLeaf, boundingData) => {\n        const terminate = depth === targetDepth || isLeaf;\n\n        if (terminate || displayParents) {\n          arrayToBox(0, boundingData, boundingBox);\n          const {\n            min,\n            max\n          } = boundingBox;\n\n          for (let x = -1; x <= 1; x += 2) {\n            const xVal = x < 0 ? min.x : max.x;\n\n            for (let y = -1; y <= 1; y += 2) {\n              const yVal = y < 0 ? min.y : max.y;\n\n              for (let z = -1; z <= 1; z += 2) {\n                const zVal = z < 0 ? min.z : max.z;\n                positionArray[posIndex + 0] = xVal;\n                positionArray[posIndex + 1] = yVal;\n                positionArray[posIndex + 2] = zVal;\n                posIndex += 3;\n              }\n            }\n          }\n\n          return terminate;\n        }\n      }, group);\n      let indexArray;\n      let indices;\n\n      if (this.displayEdges) {\n        // fill in the index buffer to point to the corner points\n        indices = new Uint8Array([// x axis\n        0, 4, 1, 5, 2, 6, 3, 7, // y axis\n        0, 2, 1, 3, 4, 6, 5, 7, // z axis\n        0, 1, 2, 3, 4, 5, 6, 7]);\n      } else {\n        indices = new Uint8Array([// X-, X+\n        0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5, // Y-, Y+\n        1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6, // Z-, Z+\n        0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]);\n      }\n\n      if (positionArray.length > 65535) {\n        indexArray = new Uint32Array(indices.length * boundsCount);\n      } else {\n        indexArray = new Uint16Array(indices.length * boundsCount);\n      }\n\n      const indexLength = indices.length;\n\n      for (let i = 0; i < boundsCount; i++) {\n        const posOffset = i * 8;\n        const indexOffset = i * indexLength;\n\n        for (let j = 0; j < indexLength; j++) {\n          indexArray[indexOffset + j] = posOffset + indices[j];\n        }\n      } // update the geometry\n\n\n      geometry.setIndex(new BufferAttribute(indexArray, 1, false));\n      geometry.setAttribute('position', new BufferAttribute(positionArray, 3, false));\n      this.visible = true;\n    }\n  }\n\n}\n\nclass MeshBVHVisualizer extends Group {\n  get color() {\n    return this.edgeMaterial.color;\n  }\n\n  get opacity() {\n    return this.edgeMaterial.opacity;\n  }\n\n  set opacity(v) {\n    this.edgeMaterial.opacity = v;\n    this.meshMaterial.opacity = v;\n  }\n\n  constructor(mesh) {\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    super();\n    this.name = 'MeshBVHVisualizer';\n    this.depth = depth;\n    this.mesh = mesh;\n    this.displayParents = false;\n    this.displayEdges = true;\n    this._roots = [];\n    const edgeMaterial = new LineBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    const meshMaterial = new MeshBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    meshMaterial.color = edgeMaterial.color;\n    this.edgeMaterial = edgeMaterial;\n    this.meshMaterial = meshMaterial;\n    this.update();\n  }\n\n  update() {\n    const bvh = this.mesh.geometry.boundsTree;\n    const totalRoots = bvh ? bvh._roots.length : 0;\n\n    while (this._roots.length > totalRoots) {\n      this._roots.pop();\n    }\n\n    for (let i = 0; i < totalRoots; i++) {\n      if (i >= this._roots.length) {\n        const root = new MeshBVHRootVisualizer(this.mesh, this.edgeMaterial, this.depth, i);\n        this.add(root);\n\n        this._roots.push(root);\n      }\n\n      const root = this._roots[i];\n      root.depth = this.depth;\n      root.mesh = this.mesh;\n      root.displayParents = this.displayParents;\n      root.displayEdges = this.displayEdges;\n      root.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n      root.update();\n    }\n  }\n\n  updateMatrixWorld() {\n    this.position.copy(this.mesh.position);\n    this.rotation.copy(this.mesh.rotation);\n    this.scale.copy(this.mesh.scale);\n    super.updateMatrixWorld(...arguments);\n  }\n\n  copy(source) {\n    this.depth = source.depth;\n    this.mesh = source.mesh;\n  }\n\n  clone() {\n    return new MeshBVHVisualizer(this.mesh, this.depth);\n  }\n\n  dispose() {\n    this.edgeMaterial.dispose();\n    this.meshMaterial.dispose();\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].geometry.dispose();\n    }\n  }\n\n}\n\nexport { MeshBVHVisualizer };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js"],"names":["LineBasicMaterial","BufferAttribute","Box3","Group","MeshBasicMaterial","Object3D","BufferGeometry","arrayToBox","boundingBox","MeshBVHRootVisualizer","isMesh","displayEdges","isLineSegments","isLine","constructor","mesh","material","depth","group","geometry","name","displayParents","_group","raycast","update","boundsTree","dispose","visible","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","min","max","x","xVal","y","yVal","z","zVal","indexArray","indices","Uint8Array","length","Uint32Array","Uint16Array","indexLength","i","posOffset","indexOffset","j","setIndex","setAttribute","MeshBVHVisualizer","color","edgeMaterial","opacity","v","meshMaterial","_roots","transparent","depthWrite","bvh","totalRoots","pop","root","add","push","updateMatrixWorld","position","copy","rotation","scale","source","clone","children","l"],"mappings":"AAAA,SAASA,iBAAT,EAA4BC,eAA5B,EAA6CC,IAA7C,EAAmDC,KAAnD,EAA0DC,iBAA1D,EAA6EC,QAA7E,EAAuFC,cAAvF,QAA6G,OAA7G;AACA,SAASC,UAAT,QAA2B,+BAA3B;AAEA,MAAMC,WAAW,GAAG,eAAgB,IAAIN,IAAJ,EAApC;;AACA,MAAMO,qBAAN,SAAoCJ,QAApC,CAA6C;AAElC,MAANK,MAAM,GAAG;AAEZ,WAAO,CAAE,KAAKC,YAAd;AAEA;;AAEiB,MAAdC,cAAc,GAAG;AAEpB,WAAO,KAAKD,YAAZ;AAEA;;AAES,MAANE,MAAM,GAAG;AAEZ,WAAO,KAAKF,YAAZ;AAEA;;AAEDG,EAAAA,WAAW,CAAEC,IAAF,EAAQC,QAAR,EAA0C;AAAA,QAAxBC,KAAwB,uEAAhB,EAAgB;AAAA,QAAZC,KAAY,uEAAJ,CAAI;AAEpD;AAEA,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKG,QAAL,GAAgB,IAAIb,cAAJ,EAAhB;AACA,SAAKc,IAAL,GAAY,uBAAZ;AACA,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKI,cAAL,GAAsB,KAAtB;AACA,SAAKN,IAAL,GAAYA,IAAZ;AACA,SAAKJ,YAAL,GAAoB,IAApB;AACA,SAAKW,MAAL,GAAcJ,KAAd;AAEA;;AAEDK,EAAAA,OAAO,GAAG,CAAE;;AAEZC,EAAAA,MAAM,GAAG;AAER,UAAML,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMM,UAAU,GAAG,KAAKV,IAAL,CAAUI,QAAV,CAAmBM,UAAtC;AACA,UAAMP,KAAK,GAAG,KAAKI,MAAnB;AACAH,IAAAA,QAAQ,CAACO,OAAT;AACA,SAAKC,OAAL,GAAe,KAAf;;AACA,QAAKF,UAAL,EAAkB;AAEjB;AACA,YAAMG,WAAW,GAAG,KAAKX,KAAL,GAAa,CAAjC;AACA,YAAMI,cAAc,GAAG,KAAKA,cAA5B;AACA,UAAIQ,WAAW,GAAG,CAAlB;AACAJ,MAAAA,UAAU,CAACK,QAAX,CAAqB,CAAEb,KAAF,EAASc,MAAT,KAAqB;AAEzC,YAAKd,KAAK,KAAKW,WAAV,IAAyBG,MAA9B,EAAuC;AAEtCF,UAAAA,WAAW;AACX,iBAAO,IAAP;AAEA,SALD,MAKO,IAAKR,cAAL,EAAsB;AAE5BQ,UAAAA,WAAW;AAEX;AAED,OAbD,EAaGX,KAbH,EANiB,CAqBjB;;AACA,UAAIc,QAAQ,GAAG,CAAf;AACA,YAAMC,aAAa,GAAG,IAAIC,YAAJ,CAAkB,IAAI,CAAJ,GAAQL,WAA1B,CAAtB;AACAJ,MAAAA,UAAU,CAACK,QAAX,CAAqB,CAAEb,KAAF,EAASc,MAAT,EAAiBI,YAAjB,KAAmC;AAEvD,cAAMC,SAAS,GAAGnB,KAAK,KAAKW,WAAV,IAAyBG,MAA3C;;AACA,YAAKK,SAAS,IAAIf,cAAlB,EAAmC;AAElCd,UAAAA,UAAU,CAAE,CAAF,EAAK4B,YAAL,EAAmB3B,WAAnB,CAAV;AAEA,gBAAM;AAAE6B,YAAAA,GAAF;AAAOC,YAAAA;AAAP,cAAe9B,WAArB;;AACA,eAAM,IAAI+B,CAAC,GAAG,CAAE,CAAhB,EAAmBA,CAAC,IAAI,CAAxB,EAA2BA,CAAC,IAAI,CAAhC,EAAoC;AAEnC,kBAAMC,IAAI,GAAGD,CAAC,GAAG,CAAJ,GAAQF,GAAG,CAACE,CAAZ,GAAgBD,GAAG,CAACC,CAAjC;;AACA,iBAAM,IAAIE,CAAC,GAAG,CAAE,CAAhB,EAAmBA,CAAC,IAAI,CAAxB,EAA2BA,CAAC,IAAI,CAAhC,EAAoC;AAEnC,oBAAMC,IAAI,GAAGD,CAAC,GAAG,CAAJ,GAAQJ,GAAG,CAACI,CAAZ,GAAgBH,GAAG,CAACG,CAAjC;;AACA,mBAAM,IAAIE,CAAC,GAAG,CAAE,CAAhB,EAAmBA,CAAC,IAAI,CAAxB,EAA2BA,CAAC,IAAI,CAAhC,EAAoC;AAEnC,sBAAMC,IAAI,GAAGD,CAAC,GAAG,CAAJ,GAAQN,GAAG,CAACM,CAAZ,GAAgBL,GAAG,CAACK,CAAjC;AACAV,gBAAAA,aAAa,CAAED,QAAQ,GAAG,CAAb,CAAb,GAAgCQ,IAAhC;AACAP,gBAAAA,aAAa,CAAED,QAAQ,GAAG,CAAb,CAAb,GAAgCU,IAAhC;AACAT,gBAAAA,aAAa,CAAED,QAAQ,GAAG,CAAb,CAAb,GAAgCY,IAAhC;AAEAZ,gBAAAA,QAAQ,IAAI,CAAZ;AAEA;AAED;AAED;;AAED,iBAAOI,SAAP;AAEA;AAED,OAjCD,EAiCGlB,KAjCH;AAmCA,UAAI2B,UAAJ;AACA,UAAIC,OAAJ;;AACA,UAAK,KAAKnC,YAAV,EAAyB;AAExB;AACAmC,QAAAA,OAAO,GAAG,IAAIC,UAAJ,CAAgB,CACzB;AACA,SAFyB,EAEtB,CAFsB,EAGzB,CAHyB,EAGtB,CAHsB,EAIzB,CAJyB,EAItB,CAJsB,EAKzB,CALyB,EAKtB,CALsB,EAOzB;AACA,SARyB,EAQtB,CARsB,EASzB,CATyB,EAStB,CATsB,EAUzB,CAVyB,EAUtB,CAVsB,EAWzB,CAXyB,EAWtB,CAXsB,EAazB;AACA,SAdyB,EActB,CAdsB,EAezB,CAfyB,EAetB,CAfsB,EAgBzB,CAhByB,EAgBtB,CAhBsB,EAiBzB,CAjByB,EAiBtB,CAjBsB,CAAhB,CAAV;AAoBA,OAvBD,MAuBO;AAEND,QAAAA,OAAO,GAAG,IAAIC,UAAJ,CAAgB,CAEzB;AACA,SAHyB,EAGtB,CAHsB,EAGnB,CAHmB,EAIzB,CAJyB,EAItB,CAJsB,EAInB,CAJmB,EAMzB,CANyB,EAMtB,CANsB,EAMnB,CANmB,EAOzB,CAPyB,EAOtB,CAPsB,EAOnB,CAPmB,EASzB;AACA,SAVyB,EAUtB,CAVsB,EAUnB,CAVmB,EAWzB,CAXyB,EAWtB,CAXsB,EAWnB,CAXmB,EAazB,CAbyB,EAatB,CAbsB,EAanB,CAbmB,EAczB,CAdyB,EActB,CAdsB,EAcnB,CAdmB,EAgBzB;AACA,SAjByB,EAiBtB,CAjBsB,EAiBnB,CAjBmB,EAkBzB,CAlByB,EAkBtB,CAlBsB,EAkBnB,CAlBmB,EAoBzB,CApByB,EAoBtB,CApBsB,EAoBnB,CApBmB,EAqBzB,CArByB,EAqBtB,CArBsB,EAqBnB,CArBmB,CAAhB,CAAV;AAyBA;;AAED,UAAKd,aAAa,CAACe,MAAd,GAAuB,KAA5B,EAAoC;AAEnCH,QAAAA,UAAU,GAAG,IAAII,WAAJ,CAAiBH,OAAO,CAACE,MAAR,GAAiBnB,WAAlC,CAAb;AAEA,OAJD,MAIO;AAENgB,QAAAA,UAAU,GAAG,IAAIK,WAAJ,CAAiBJ,OAAO,CAACE,MAAR,GAAiBnB,WAAlC,CAAb;AAEA;;AAED,YAAMsB,WAAW,GAAGL,OAAO,CAACE,MAA5B;;AACA,WAAM,IAAII,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGvB,WAArB,EAAkCuB,CAAC,EAAnC,EAAyC;AAExC,cAAMC,SAAS,GAAGD,CAAC,GAAG,CAAtB;AACA,cAAME,WAAW,GAAGF,CAAC,GAAGD,WAAxB;;AACA,aAAM,IAAII,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,WAArB,EAAkCI,CAAC,EAAnC,EAAyC;AAExCV,UAAAA,UAAU,CAAES,WAAW,GAAGC,CAAhB,CAAV,GAAgCF,SAAS,GAAGP,OAAO,CAAES,CAAF,CAAnD;AAEA;AAED,OAtIgB,CAwIjB;;;AACApC,MAAAA,QAAQ,CAACqC,QAAT,CACC,IAAIvD,eAAJ,CAAqB4C,UAArB,EAAiC,CAAjC,EAAoC,KAApC,CADD;AAGA1B,MAAAA,QAAQ,CAACsC,YAAT,CACC,UADD,EAEC,IAAIxD,eAAJ,CAAqBgC,aAArB,EAAoC,CAApC,EAAuC,KAAvC,CAFD;AAIA,WAAKN,OAAL,GAAe,IAAf;AAEA;AAED;;AAhM2C;;AAoM7C,MAAM+B,iBAAN,SAAgCvD,KAAhC,CAAsC;AAE5B,MAALwD,KAAK,GAAG;AAEX,WAAO,KAAKC,YAAL,CAAkBD,KAAzB;AAEA;;AAEU,MAAPE,OAAO,GAAG;AAEb,WAAO,KAAKD,YAAL,CAAkBC,OAAzB;AAEA;;AAEU,MAAPA,OAAO,CAAEC,CAAF,EAAM;AAEhB,SAAKF,YAAL,CAAkBC,OAAlB,GAA4BC,CAA5B;AACA,SAAKC,YAAL,CAAkBF,OAAlB,GAA4BC,CAA5B;AAEA;;AAEDhD,EAAAA,WAAW,CAAEC,IAAF,EAAqB;AAAA,QAAbE,KAAa,uEAAL,EAAK;AAE/B;AAEA,SAAKG,IAAL,GAAY,mBAAZ;AACA,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKM,cAAL,GAAsB,KAAtB;AACA,SAAKV,YAAL,GAAoB,IAApB;AACA,SAAKqD,MAAL,GAAc,EAAd;AAEA,UAAMJ,YAAY,GAAG,IAAI5D,iBAAJ,CAAuB;AAC3C2D,MAAAA,KAAK,EAAE,QADoC;AAE3CM,MAAAA,WAAW,EAAE,IAF8B;AAG3CJ,MAAAA,OAAO,EAAE,GAHkC;AAI3CK,MAAAA,UAAU,EAAE;AAJ+B,KAAvB,CAArB;AAOA,UAAMH,YAAY,GAAG,IAAI3D,iBAAJ,CAAuB;AAC3CuD,MAAAA,KAAK,EAAE,QADoC;AAE3CM,MAAAA,WAAW,EAAE,IAF8B;AAG3CJ,MAAAA,OAAO,EAAE,GAHkC;AAI3CK,MAAAA,UAAU,EAAE;AAJ+B,KAAvB,CAArB;AAOAH,IAAAA,YAAY,CAACJ,KAAb,GAAqBC,YAAY,CAACD,KAAlC;AAEA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKG,YAAL,GAAoBA,YAApB;AAEA,SAAKvC,MAAL;AAEA;;AAEDA,EAAAA,MAAM,GAAG;AAER,UAAM2C,GAAG,GAAG,KAAKpD,IAAL,CAAUI,QAAV,CAAmBM,UAA/B;AACA,UAAM2C,UAAU,GAAGD,GAAG,GAAGA,GAAG,CAACH,MAAJ,CAAWhB,MAAd,GAAuB,CAA7C;;AACA,WAAQ,KAAKgB,MAAL,CAAYhB,MAAZ,GAAqBoB,UAA7B,EAA0C;AAEzC,WAAKJ,MAAL,CAAYK,GAAZ;AAEA;;AAED,SAAM,IAAIjB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGgB,UAArB,EAAiChB,CAAC,EAAlC,EAAwC;AAEvC,UAAKA,CAAC,IAAI,KAAKY,MAAL,CAAYhB,MAAtB,EAA+B;AAE9B,cAAMsB,IAAI,GAAG,IAAI7D,qBAAJ,CAA2B,KAAKM,IAAhC,EAAsC,KAAK6C,YAA3C,EAAyD,KAAK3C,KAA9D,EAAqEmC,CAArE,CAAb;AACA,aAAKmB,GAAL,CAAUD,IAAV;;AACA,aAAKN,MAAL,CAAYQ,IAAZ,CAAkBF,IAAlB;AAEA;;AAED,YAAMA,IAAI,GAAG,KAAKN,MAAL,CAAaZ,CAAb,CAAb;AACAkB,MAAAA,IAAI,CAACrD,KAAL,GAAa,KAAKA,KAAlB;AACAqD,MAAAA,IAAI,CAACvD,IAAL,GAAY,KAAKA,IAAjB;AACAuD,MAAAA,IAAI,CAACjD,cAAL,GAAsB,KAAKA,cAA3B;AACAiD,MAAAA,IAAI,CAAC3D,YAAL,GAAoB,KAAKA,YAAzB;AACA2D,MAAAA,IAAI,CAACtD,QAAL,GAAgB,KAAKL,YAAL,GAAoB,KAAKiD,YAAzB,GAAwC,KAAKG,YAA7D;AACAO,MAAAA,IAAI,CAAC9C,MAAL;AAEA;AAED;;AAEDiD,EAAAA,iBAAiB,GAAY;AAE5B,SAAKC,QAAL,CAAcC,IAAd,CAAoB,KAAK5D,IAAL,CAAU2D,QAA9B;AACA,SAAKE,QAAL,CAAcD,IAAd,CAAoB,KAAK5D,IAAL,CAAU6D,QAA9B;AACA,SAAKC,KAAL,CAAWF,IAAX,CAAiB,KAAK5D,IAAL,CAAU8D,KAA3B;AAEA,UAAMJ,iBAAN,CAAyB,YAAzB;AAEA;;AAEDE,EAAAA,IAAI,CAAEG,MAAF,EAAW;AAEd,SAAK7D,KAAL,GAAa6D,MAAM,CAAC7D,KAApB;AACA,SAAKF,IAAL,GAAY+D,MAAM,CAAC/D,IAAnB;AAEA;;AAEDgE,EAAAA,KAAK,GAAG;AAEP,WAAO,IAAIrB,iBAAJ,CAAuB,KAAK3C,IAA5B,EAAkC,KAAKE,KAAvC,CAAP;AAEA;;AAEDS,EAAAA,OAAO,GAAG;AAET,SAAKkC,YAAL,CAAkBlC,OAAlB;AACA,SAAKqC,YAAL,CAAkBrC,OAAlB;AAEA,UAAMsD,QAAQ,GAAG,KAAKA,QAAtB;;AACA,SAAM,IAAI5B,CAAC,GAAG,CAAR,EAAW6B,CAAC,GAAGD,QAAQ,CAAChC,MAA9B,EAAsCI,CAAC,GAAG6B,CAA1C,EAA6C7B,CAAC,EAA9C,EAAoD;AAEnD4B,MAAAA,QAAQ,CAAE5B,CAAF,CAAR,CAAcjC,QAAd,CAAuBO,OAAvB;AAEA;AAED;;AA1HoC;;AA+HtC,SAASgC,iBAAT","sourcesContent":["import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nclass MeshBVHRootVisualizer extends Object3D {\r\n\r\n\tget isMesh() {\r\n\r\n\t\treturn ! this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLineSegments() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLine() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.name = 'MeshBVHRootVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._group = group;\r\n\r\n\t}\r\n\r\n\traycast() {}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tconst group = this._group;\r\n\t\tgeometry.dispose();\r\n\t\tthis.visible = false;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\t// count the number of bounds required\r\n\t\t\tconst targetDepth = this.depth - 1;\r\n\t\t\tconst displayParents = this.displayParents;\r\n\t\t\tlet boundsCount = 0;\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\r\n\r\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else if ( displayParents ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the position buffer with the bounds corners\r\n\t\t\tlet posIndex = 0;\r\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\r\n\r\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\r\n\t\t\t\tif ( terminate || displayParents ) {\r\n\r\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\r\n\r\n\t\t\t\t\tconst { min, max } = boundingBox;\r\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\r\n\r\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\r\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\r\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\r\n\r\n\t\t\t\t\t\t\t\tposIndex += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn terminate;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\tlet indexArray;\r\n\t\t\tlet indices;\r\n\t\t\tif ( this.displayEdges ) {\r\n\r\n\t\t\t\t// fill in the index buffer to point to the corner points\r\n\t\t\t\tindices = new Uint8Array( [\r\n\t\t\t\t\t// x axis\r\n\t\t\t\t\t0, 4,\r\n\t\t\t\t\t1, 5,\r\n\t\t\t\t\t2, 6,\r\n\t\t\t\t\t3, 7,\r\n\r\n\t\t\t\t\t// y axis\r\n\t\t\t\t\t0, 2,\r\n\t\t\t\t\t1, 3,\r\n\t\t\t\t\t4, 6,\r\n\t\t\t\t\t5, 7,\r\n\r\n\t\t\t\t\t// z axis\r\n\t\t\t\t\t0, 1,\r\n\t\t\t\t\t2, 3,\r\n\t\t\t\t\t4, 5,\r\n\t\t\t\t\t6, 7,\r\n\t\t\t\t] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindices = new Uint8Array( [\r\n\r\n\t\t\t\t\t// X-, X+\r\n\t\t\t\t\t0, 1, 2,\r\n\t\t\t\t\t2, 1, 3,\r\n\r\n\t\t\t\t\t4, 6, 5,\r\n\t\t\t\t\t6, 7, 5,\r\n\r\n\t\t\t\t\t// Y-, Y+\r\n\t\t\t\t\t1, 4, 5,\r\n\t\t\t\t\t0, 4, 1,\r\n\r\n\t\t\t\t\t2, 3, 6,\r\n\t\t\t\t\t3, 7, 6,\r\n\r\n\t\t\t\t\t// Z-, Z+\r\n\t\t\t\t\t0, 2, 4,\r\n\t\t\t\t\t2, 6, 4,\r\n\r\n\t\t\t\t\t1, 5, 3,\r\n\t\t\t\t\t3, 5, 7,\r\n\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positionArray.length > 65535 ) {\r\n\r\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst indexLength = indices.length;\r\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\r\n\r\n\t\t\t\tconst posOffset = i * 8;\r\n\t\t\t\tconst indexOffset = i * indexLength;\r\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\r\n\r\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the geometry\r\n\t\t\tgeometry.setIndex(\r\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\r\n\t\t\t);\r\n\t\t\tgeometry.setAttribute(\r\n\t\t\t\t'position',\r\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\r\n\t\t\t);\r\n\t\t\tthis.visible = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.edgeMaterial.color;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.edgeMaterial.opacity;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tthis.edgeMaterial.opacity = v;\r\n\t\tthis.meshMaterial.opacity = v;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.name = 'MeshBVHVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._roots = [];\r\n\r\n\t\tconst edgeMaterial = new LineBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tconst meshMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tmeshMaterial.color = edgeMaterial.color;\r\n\r\n\t\tthis.edgeMaterial = edgeMaterial;\r\n\t\tthis.meshMaterial = meshMaterial;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tthis._roots.pop();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst root = this._roots[ i ];\r\n\t\t\troot.depth = this.depth;\r\n\t\t\troot.mesh = this.mesh;\r\n\t\t\troot.displayParents = this.displayParents;\r\n\t\t\troot.displayEdges = this.displayEdges;\r\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\r\n\t\t\troot.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.edgeMaterial.dispose();\r\n\t\tthis.meshMaterial.dispose();\r\n\r\n\t\tconst children = this.children;\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].geometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { MeshBVHVisualizer };\r\n"]},"metadata":{},"sourceType":"module"}