{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GastRecorder = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar gast_public_1 = require(\"../../grammar/gast/gast_public\");\n\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\n\nvar tokens_1 = require(\"../../../scan/tokens\");\n\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nvar parser_1 = require(\"../parser\");\n\nvar keys_1 = require(\"../../grammar/keys\");\n\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0, tokens_public_1.createToken)({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: lexer_public_1.Lexer.NA\n});\n(0, tokens_1.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\n\nvar GastRecorder =\n/** @class */\nfunction () {\n  function GastRecorder() {}\n\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function (i) {\n        var idx = i > 0 ? i : \"\";\n\n        _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"OPTION\" + idx] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n\n        _this[\"OR\" + idx] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n\n        _this[\"MANY\" + idx] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n\n        _this[\"MANY_SEP\" + idx] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n\n\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      } // DSL methods with the idx(suffix) as an argument\n\n\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = false; // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete _this[\"CONSUME\" + idx];\n        delete _this[\"SUBRULE\" + idx];\n        delete _this[\"OPTION\" + idx];\n        delete _this[\"OR\" + idx];\n        delete _this[\"MANY\" + idx];\n        delete _this[\"MANY_SEP\" + idx];\n        delete _this[\"AT_LEAST_ONE\" + idx];\n        delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n      }\n\n      delete _this[\"consume\"];\n      delete _this[\"subrule\"];\n      delete _this[\"option\"];\n      delete _this[\"or\"];\n      delete _this[\"many\"];\n      delete _this[\"atLeastOne\"];\n      delete _this.ACTION;\n      delete _this.BACKTRACK;\n      delete _this.LA;\n    });\n  }; // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n\n\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n    return;\n  }; // Executing backtracking logic will break our recording logic assumptions\n\n\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  }; // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n\n\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return parser_1.END_OF_FILE;\n  };\n\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new gast_public_1.Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n\n      throw originalError;\n    }\n  }; // Implementation of parsing DSL\n\n\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!ruleToCall || (0, utils_1.has)(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    var ruleName = ruleToCall[\"ruleName\"];\n    var newNoneTerminal = new gast_public_1.NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {\n      var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    var newNoneTerminal = new gast_public_1.Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n\n  return GastRecorder;\n}();\n\nexports.GastRecorder = GastRecorder;\n\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n  var grammarAction = (0, utils_1.isFunction)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n\n  if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, utils_1.peek)(this.recordingProdStack); // Only an array of alternatives\n\n  var hasOptions = (0, utils_1.isArray)(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new gast_public_1.Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n\n  if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  var hasPredicates = (0, utils_1.some)(alts, function (currAlt) {\n    return (0, utils_1.isFunction)(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  (0, utils_1.forEach)(alts, function (currAlt) {\n    var currAltFlat = new gast_public_1.Alternative({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n\n    if ((0, utils_1.has)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } // **implicit** ignoreAmbiguities due to usage of gate\n    else if ((0, utils_1.has)(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n\n    _this.recordingProdStack.push(currAltFlat);\n\n    currAlt.ALT.call(_this);\n\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\" + idx;\n}\n\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error( // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" + (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/gast_recorder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GastRecorder = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar gast_public_1 = require(\"../../grammar/gast/gast_public\");\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0, tokens_public_1.createToken)({ name: \"RECORDING_PHASE_TOKEN\", pattern: lexer_public_1.Lexer.NA });\n(0, tokens_1.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\" + idx] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\" + idx] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\" + idx] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\" + idx] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete _this[\"CONSUME\" + idx];\n                delete _this[\"SUBRULE\" + idx];\n                delete _this[\"OPTION\" + idx];\n                delete _this[\"OR\" + idx];\n                delete _this[\"MANY\" + idx];\n                delete _this[\"MANY_SEP\" + idx];\n                delete _this[\"AT_LEAST_ONE\" + idx];\n                delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n            }\n            delete _this[\"consume\"];\n            delete _this[\"subrule\"];\n            delete _this[\"option\"];\n            delete _this[\"or\"];\n            delete _this[\"many\"];\n            delete _this[\"atLeastOne\"];\n            delete _this.ACTION;\n            delete _this.BACKTRACK;\n            delete _this.LA;\n        });\n    };\n    // TODO: is there any way to use this method to check no\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n        return;\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return parser_1.END_OF_FILE;\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new gast_public_1.Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || (0, utils_1.has)(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n        var ruleName = ruleToCall[\"ruleName\"];\n        var newNoneTerminal = new gast_public_1.NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {\n            var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n        var newNoneTerminal = new gast_public_1.Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\nexports.GastRecorder = GastRecorder;\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    var grammarAction = (0, utils_1.isFunction)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = (0, utils_1.isArray)(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new gast_public_1.Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = (0, utils_1.some)(alts, function (currAlt) { return (0, utils_1.isFunction)(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    (0, utils_1.forEach)(alts, function (currAlt) {\n        var currAltFlat = new gast_public_1.Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if ((0, utils_1.has)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if ((0, utils_1.has)(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" +\n            (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map"]},"metadata":{},"sourceType":"script"}