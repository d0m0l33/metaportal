{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Matrix4, EventDispatcher, EllipseCurve, BufferGeometry, MathUtils, Vector3, GridHelper, LineBasicMaterial, Line, Raycaster, Vector2, Quaternion, Group, Box3, Sphere } from 'three';\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n}; //cursor center coordinates\n\nconst _center = {\n  x: 0,\n  y: 0\n}; //transformation matrices for gizmos and camera\n\nconst _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n}; //events\n\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\n/**\n *\n * @param {Camera} camera Virtual camera used in the scene\n * @param {HTMLElement} domElement Renderer's dom element\n * @param {Scene} scene The scene to be rendered\n */\n\nclass ArcballControls extends EventDispatcher {\n  constructor(_camera, _domElement) {\n    var _this;\n\n    let scene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super();\n    _this = this;\n\n    _defineProperty(this, \"onWindowResize\", () => {\n      const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      const newRadius = this._tbRadius / scale;\n      const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n      const points = curve.getPoints(this._curvePts);\n      const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n      for (const gizmo in this._gizmos.children) {\n        this._gizmos.children[gizmo].geometry = curveGeometry;\n      }\n\n      this.dispatchEvent(_changeEvent);\n    });\n\n    _defineProperty(this, \"onContextMenu\", event => {\n      if (!this.enabled) {\n        return;\n      }\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == 2) {\n          //prevent only if button 2 is actually used\n          event.preventDefault();\n          break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerCancel\", () => {\n      this._touchStart.splice(0, this._touchStart.length);\n\n      this._touchCurrent.splice(0, this._touchCurrent.length);\n\n      this._input = INPUT.NONE;\n    });\n\n    _defineProperty(this, \"onPointerDown\", event => {\n      if (event.button == 0 && event.isPrimary) {\n        this._downValid = true;\n\n        this._downEvents.push(event);\n\n        this._downStart = performance.now();\n      } else {\n        this._downValid = false;\n      }\n\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        this._touchStart.push(event);\n\n        this._touchCurrent.push(event);\n\n        switch (this._input) {\n          case INPUT.NONE:\n            //singleStart\n            this._input = INPUT.ONE_FINGER;\n            this.onSinglePanStart(event, 'ROTATE');\n            window.addEventListener('pointermove', this.onPointerMove);\n            window.addEventListener('pointerup', this.onPointerUp);\n            break;\n\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            //doubleStart\n            this._input = INPUT.TWO_FINGER;\n            this.onRotateStart();\n            this.onPinchStart();\n            this.onDoublePanStart();\n            break;\n\n          case INPUT.TWO_FINGER:\n            //multipleStart\n            this._input = INPUT.MULT_FINGER;\n            this.onTriplePanStart(event);\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        this._mouseOp = this.getOpFromAction(event.button, modifier);\n\n        if (this._mouseOp != null) {\n          window.addEventListener('pointermove', this.onPointerMove);\n          window.addEventListener('pointerup', this.onPointerUp); //singleStart\n\n          this._input = INPUT.CURSOR;\n          this._button = event.button;\n          this.onSinglePanStart(event, this._mouseOp);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerMove\", event => {\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n            //singleMove\n            this.updateTouchEvent(event);\n            this.onSinglePanMove(event, STATE.ROTATE);\n            break;\n\n          case INPUT.ONE_FINGER_SWITCHED:\n            const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\n\n            if (movement >= this._switchSensibility) {\n              //singleMove\n              this._input = INPUT.ONE_FINGER;\n              this.updateTouchEvent(event);\n              this.onSinglePanStart(event, 'ROTATE');\n              break;\n            }\n\n            break;\n\n          case INPUT.TWO_FINGER:\n            //rotate/pan/pinchMove\n            this.updateTouchEvent(event);\n            this.onRotateMove();\n            this.onPinchMove();\n            this.onDoublePanMove();\n            break;\n\n          case INPUT.MULT_FINGER:\n            //multMove\n            this.updateTouchEvent(event);\n            this.onTriplePanMove(event);\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        const mouseOpState = this.getOpStateFromAction(this._button, modifier);\n\n        if (mouseOpState != null) {\n          this.onSinglePanMove(event, mouseOpState);\n        }\n      } //checkDistance\n\n\n      if (this._downValid) {\n        const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\n\n        if (movement > this._movementThreshold) {\n          this._downValid = false;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerUp\", event => {\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        const nTouch = this._touchCurrent.length;\n\n        for (let i = 0; i < nTouch; i++) {\n          if (this._touchCurrent[i].pointerId == event.pointerId) {\n            this._touchCurrent.splice(i, 1);\n\n            this._touchStart.splice(i, 1);\n\n            break;\n          }\n        }\n\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            //singleEnd\n            window.removeEventListener('pointermove', this.onPointerMove);\n            window.removeEventListener('pointerup', this.onPointerUp);\n            this._input = INPUT.NONE;\n            this.onSinglePanEnd();\n            break;\n\n          case INPUT.TWO_FINGER:\n            //doubleEnd\n            this.onDoublePanEnd(event);\n            this.onPinchEnd(event);\n            this.onRotateEnd(event); //switching to singleStart\n\n            this._input = INPUT.ONE_FINGER_SWITCHED;\n            break;\n\n          case INPUT.MULT_FINGER:\n            if (this._touchCurrent.length == 0) {\n              window.removeEventListener('pointermove', this.onPointerMove);\n              window.removeEventListener('pointerup', this.onPointerUp); //multCancel\n\n              this._input = INPUT.NONE;\n              this.onTriplePanEnd();\n            }\n\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n        window.removeEventListener('pointermove', this.onPointerMove);\n        window.removeEventListener('pointerup', this.onPointerUp);\n        this._input = INPUT.NONE;\n        this.onSinglePanEnd();\n        this._button = -1;\n      }\n\n      if (event.isPrimary) {\n        if (this._downValid) {\n          const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\n\n          if (downTime <= this._maxDownTime) {\n            if (this._nclicks == 0) {\n              //first valid click detected\n              this._nclicks = 1;\n              this._clickStart = performance.now();\n            } else {\n              const clickInterval = event.timeStamp - this._clickStart;\n\n              const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\n\n              if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n                //second valid click detected\n                //fire double tap and reset values\n                this._nclicks = 0;\n\n                this._downEvents.splice(0, this._downEvents.length);\n\n                this.onDoubleTap(event);\n              } else {\n                //new 'first click'\n                this._nclicks = 1;\n\n                this._downEvents.shift();\n\n                this._clickStart = performance.now();\n              }\n            }\n          } else {\n            this._downValid = false;\n            this._nclicks = 0;\n\n            this._downEvents.splice(0, this._downEvents.length);\n          }\n        } else {\n          this._nclicks = 0;\n\n          this._downEvents.splice(0, this._downEvents.length);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onWheel\", event => {\n      if (this.enabled && this.enableZoom) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        const mouseOp = this.getOpFromAction('WHEEL', modifier);\n\n        if (mouseOp != null) {\n          event.preventDefault();\n          this.dispatchEvent(_startEvent);\n          const notchDeltaY = 125; //distance of one notch of mouse wheel\n\n          let sgn = event.deltaY / notchDeltaY;\n          let size = 1;\n\n          if (sgn > 0) {\n            size = 1 / this.scaleFactor;\n          } else if (sgn < 0) {\n            size = this.scaleFactor;\n          }\n\n          switch (mouseOp) {\n            case 'ZOOM':\n              this.updateTbState(STATE.SCALE, true);\n\n              if (sgn > 0) {\n                size = 1 / Math.pow(this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(this.scaleFactor, -sgn);\n              }\n\n              if (this.cursorZoom && this.enablePan) {\n                let scalePoint;\n\n                if (this.camera.isOrthographicCamera) {\n                  scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n                } else if (this.camera.isPerspectiveCamera) {\n                  scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n                }\n\n                this.applyTransformMatrix(this.applyScale(size, scalePoint));\n              } else {\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n\n              if (this._grid != null) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n\n            case 'FOV':\n              if (this.camera.isPerspectiveCamera) {\n                this.updateTbState(STATE.FOV, true); //Vertigo effect\n                //\t  fov / 2\n                //\t\t|\\\n                //\t\t| \\\n                //\t\t|  \\\n                //\tx\t|\t\\\n                //\t\t| \t \\\n                //\t\t| \t  \\\n                //\t\t| _ _ _\\\n                //\t\t\ty\n                //check for iOs shift shortcut\n\n                if (event.deltaX != 0) {\n                  sgn = event.deltaX / notchDeltaY;\n                  size = 1;\n\n                  if (sgn > 0) {\n                    size = 1 / Math.pow(this.scaleFactor, sgn);\n                  } else if (sgn < 0) {\n                    size = Math.pow(this.scaleFactor, -sgn);\n                  }\n                }\n\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n                //check min and max distance\n\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5); //calculate new fov\n\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n                if (newFov > this.maxFov) {\n                  newFov = this.maxFov;\n                } else if (newFov < this.minFov) {\n                  newFov = this.minFov;\n                }\n\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false));\n              }\n\n              if (this._grid != null) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n          }\n        }\n      }\n    });\n\n    _defineProperty(this, \"onKeyDown\", event => {\n      if (event.key == 'c') {\n        if (event.ctrlKey || event.metaKey) {\n          this.copyState();\n        }\n      } else if (event.key == 'v') {\n        if (event.ctrlKey || event.metaKey) {\n          this.pasteState();\n        }\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanStart\", (event, operation) => {\n      if (this.enabled) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n\n        switch (operation) {\n          case 'PAN':\n            if (!this.enablePan) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            this.updateTbState(STATE.PAN, true);\n\n            this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n            if (this.enableGrid) {\n              this.drawGrid();\n              this.dispatchEvent(_changeEvent);\n            }\n\n            break;\n\n          case 'ROTATE':\n            if (!this.enableRotate) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n            }\n\n            this.updateTbState(STATE.ROTATE, true);\n\n            this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n            this.activateGizmos(true);\n\n            if (this.enableAnimations) {\n              this._timePrev = this._timeCurrent = performance.now();\n              this._angleCurrent = this._anglePrev = 0;\n\n              this._cursorPosPrev.copy(this._startCursorPosition);\n\n              this._cursorPosCurr.copy(this._cursorPosPrev);\n\n              this._wCurr = 0;\n              this._wPrev = this._wCurr;\n            }\n\n            this.dispatchEvent(_changeEvent);\n            break;\n\n          case 'FOV':\n            if (!this.camera.isPerspectiveCamera || !this.enableZoom) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            this.updateTbState(STATE.FOV, true);\n\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n            this._currentCursorPosition.copy(this._startCursorPosition);\n\n            break;\n\n          case 'ZOOM':\n            if (!this.enableZoom) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            this.updateTbState(STATE.SCALE, true);\n\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n            this._currentCursorPosition.copy(this._startCursorPosition);\n\n            break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanMove\", (event, opState) => {\n      if (this.enabled) {\n        const restart = opState != this._state;\n        this.setCenter(event.clientX, event.clientY);\n\n        switch (opState) {\n          case STATE.PAN:\n            if (this.enablePan) {\n              if (restart) {\n                //switch to pan operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n                if (this.enableGrid) {\n                  this.drawGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with pan operation\n                this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n                this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\n              }\n            }\n\n            break;\n\n          case STATE.ROTATE:\n            if (this.enableRotate) {\n              if (restart) {\n                //switch to rotate operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(true);\n              } else {\n                //continue with rotate operation\n                this._currentCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n                const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\n\n                const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\n\n                const amount = Math.max(distance / this._tbRadius, angle); //effective rotation angle\n\n                this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\n\n                if (this.enableAnimations) {\n                  this._timePrev = this._timeCurrent;\n                  this._timeCurrent = performance.now();\n                  this._anglePrev = this._angleCurrent;\n                  this._angleCurrent = amount;\n\n                  this._cursorPosPrev.copy(this._cursorPosCurr);\n\n                  this._cursorPosCurr.copy(this._currentCursorPosition);\n\n                  this._wPrev = this._wCurr;\n                  this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\n                }\n              }\n            }\n\n            break;\n\n          case STATE.SCALE:\n            if (this.enableZoom) {\n              if (restart) {\n                //switch to zoom operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                this._currentCursorPosition.copy(this._startCursorPosition);\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with zoom operation\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n            }\n\n            break;\n\n          case STATE.FOV:\n            if (this.enableZoom && this.camera.isPerspectiveCamera) {\n              if (restart) {\n                //switch to fov operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                this._currentCursorPosition.copy(this._startCursorPosition);\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with fov operation\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n                //check min and max distance\n\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n                newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n\n                this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\n\n                const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n                this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n              }\n            }\n\n            break;\n        }\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanEnd\", () => {\n      if (this._state == STATE.ROTATE) {\n        if (!this.enableRotate) {\n          return;\n        }\n\n        if (this.enableAnimations) {\n          //perform rotation animation\n          const deltaTime = performance.now() - this._timeCurrent;\n\n          if (deltaTime < 120) {\n            const w = Math.abs((this._wPrev + this._wCurr) / 2);\n            const self = this;\n            this._animationId = window.requestAnimationFrame(function (t) {\n              self.updateTbState(STATE.ANIMATION_ROTATE, true);\n              const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n              self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n            });\n          } else {\n            //cursor has been standing still for over 120 ms since last movement\n            this.updateTbState(STATE.IDLE, false);\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n        } else {\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n        this.updateTbState(STATE.IDLE, false);\n\n        if (this.enableGrid) {\n          this.disposeGrid();\n        }\n\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onDoubleTap\", event => {\n      if (this.enabled && this.enablePan && this.scene != null) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n        const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);\n\n        if (hitP != null && this.enableAnimations) {\n          const self = this;\n\n          if (this._animationId != -1) {\n            window.cancelAnimationFrame(this._animationId);\n          }\n\n          this._timeStart = -1;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_FOCUS, true);\n            self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n          });\n        } else if (hitP != null && !this.enableAnimations) {\n          this.updateTbState(STATE.FOCUS, true);\n          this.focus(hitP, this.scaleFactor);\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onDoublePanStart\", () => {\n      if (this.enabled && this.enablePan) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.PAN, true);\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n\n        this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n\n        this._currentCursorPosition.copy(this._startCursorPosition);\n\n        this.activateGizmos(false);\n      }\n    });\n\n    _defineProperty(this, \"onDoublePanMove\", () => {\n      if (this.enabled && this.enablePan) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n\n        if (this._state != STATE.PAN) {\n          this.updateTbState(STATE.PAN, true);\n\n          this._startCursorPosition.copy(this._currentCursorPosition);\n        }\n\n        this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n\n        this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onDoublePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onRotateStart\", () => {\n      if (this.enabled && this.enableRotate) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.ZROTATE, true); //this._startFingerRotation = event.rotation;\n\n        this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n        this._currentFingerRotation = this._startFingerRotation;\n        this.camera.getWorldDirection(this._rotationAxis); //rotation axis\n\n        if (!this.enablePan && !this.enableZoom) {\n          this.activateGizmos(true);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onRotateMove\", () => {\n      if (this.enabled && this.enableRotate) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        let rotationPoint;\n\n        if (this._state != STATE.ZROTATE) {\n          this.updateTbState(STATE.ZROTATE, true);\n          this._startFingerRotation = this._currentFingerRotation;\n        } //this._currentFingerRotation = event.rotation;\n\n\n        this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n\n        if (!this.enablePan) {\n          rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\n        } else {\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n          rotationPoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);\n        }\n\n        const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\n        this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onRotateEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.activateGizmos(false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onPinchStart\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true);\n        this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\n        this._currentFingerDistance = this._startFingerDistance;\n        this.activateGizmos(false);\n      }\n    });\n\n    _defineProperty(this, \"onPinchMove\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        const minDistance = 12; //minimum distance between fingers (in css pixels)\n\n        if (this._state != STATE.SCALE) {\n          this._startFingerDistance = this._currentFingerDistance;\n          this.updateTbState(STATE.SCALE, true);\n        }\n\n        this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\n        const amount = this._currentFingerDistance / this._startFingerDistance;\n        let scalePoint;\n\n        if (!this.enablePan) {\n          scalePoint = this._gizmos.position;\n        } else {\n          if (this.camera.isOrthographicCamera) {\n            scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n          } else if (this.camera.isPerspectiveCamera) {\n            scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n          }\n        }\n\n        this.applyTransformMatrix(this.applyScale(amount, scalePoint));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onPinchEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onTriplePanStart\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true); //const center = event.center;\n\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n\n        this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n        this._currentCursorPosition.copy(this._startCursorPosition);\n      }\n    });\n\n    _defineProperty(this, \"onTriplePanMove\", () => {\n      if (this.enabled && this.enableZoom) {\n        //\t  fov / 2\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\tx\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t\t| _ _ _\\\n        //\t\t\ty\n        //const center = event.center;\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n        const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n        this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n        const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n        let size = 1;\n\n        if (movement < 0) {\n          size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n        } else if (movement > 0) {\n          size = Math.pow(this.scaleFactor, movement * screenNotches);\n        }\n\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n        const x = this._v3_1.distanceTo(this._gizmos.position);\n\n        let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n        //check min and max distance\n\n        xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n        const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n        let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n        newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n        const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n        size = x / newDistance;\n\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n        this.setFov(newFov);\n        this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\n\n        const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onTriplePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent); //this.dispatchEvent( _changeEvent );\n    });\n\n    _defineProperty(this, \"setCenter\", (clientX, clientY) => {\n      _center.x = clientX;\n      _center.y = clientY;\n    });\n\n    _defineProperty(this, \"initializeMouseActions\", () => {\n      this.setMouseAction('PAN', 0, 'CTRL');\n      this.setMouseAction('PAN', 2);\n      this.setMouseAction('ROTATE', 0);\n      this.setMouseAction('ZOOM', 'WHEEL');\n      this.setMouseAction('ZOOM', 1);\n      this.setMouseAction('FOV', 'WHEEL', 'SHIFT');\n      this.setMouseAction('FOV', 1, 'SHIFT');\n    });\n\n    _defineProperty(this, \"compareMouseAction\", (action1, action2) => {\n      if (action1.operation == action2.operation) {\n        if (action1.mouse == action2.mouse && action1.key == action2.key) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    });\n\n    _defineProperty(this, \"setMouseAction\", function (operation, mouse) {\n      let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV'];\n      const mouseInput = [0, 1, 2, 'WHEEL'];\n      const keyInput = ['CTRL', 'SHIFT', null];\n      let state;\n\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n        //invalid parameters\n        return false;\n      }\n\n      if (mouse == 'WHEEL') {\n        if (operation != 'ZOOM' && operation != 'FOV') {\n          //cannot associate 2D operation to 1D input\n          return false;\n        }\n      }\n\n      switch (operation) {\n        case 'PAN':\n          state = STATE.PAN;\n          break;\n\n        case 'ROTATE':\n          state = STATE.ROTATE;\n          break;\n\n        case 'ZOOM':\n          state = STATE.SCALE;\n          break;\n\n        case 'FOV':\n          state = STATE.FOV;\n          break;\n      }\n\n      const action = {\n        operation: operation,\n        mouse: mouse,\n        key: key,\n        state: state\n      };\n\n      for (let i = 0; i < _this.mouseActions.length; i++) {\n        if (_this.mouseActions[i].mouse == action.mouse && _this.mouseActions[i].key == action.key) {\n          _this.mouseActions.splice(i, 1, action);\n\n          return true;\n        }\n      }\n\n      _this.mouseActions.push(action);\n\n      return true;\n    });\n\n    _defineProperty(this, \"unsetMouseAction\", function (mouse) {\n      let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      for (let i = 0; i < _this.mouseActions.length; i++) {\n        if (_this.mouseActions[i].mouse == mouse && _this.mouseActions[i].key == key) {\n          _this.mouseActions.splice(i, 1);\n\n          return true;\n        }\n      }\n\n      return false;\n    });\n\n    _defineProperty(this, \"getOpFromAction\", (mouse, key) => {\n      let action;\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == key) {\n          return action.operation;\n        }\n      }\n\n      if (key != null) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n\n          if (action.mouse == mouse && action.key == null) {\n            return action.operation;\n          }\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"getOpStateFromAction\", (mouse, key) => {\n      let action;\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == key) {\n          return action.state;\n        }\n      }\n\n      if (key != null) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n\n          if (action.mouse == mouse && action.key == null) {\n            return action.state;\n          }\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"getAngle\", (p1, p2) => {\n      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n    });\n\n    _defineProperty(this, \"updateTouchEvent\", event => {\n      for (let i = 0; i < this._touchCurrent.length; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1, event);\n\n          break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"calculateAngularSpeed\", (p0, p1, t0, t1) => {\n      const s = p1 - p0;\n      const t = (t1 - t0) / 1000;\n\n      if (t == 0) {\n        return 0;\n      }\n\n      return s / t;\n    });\n\n    _defineProperty(this, \"calculatePointersDistance\", (p0, p1) => {\n      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n    });\n\n    _defineProperty(this, \"calculateRotationAxis\", (vec1, vec2) => {\n      this._rotationMatrix.extractRotation(this._cameraMatrixState);\n\n      this._quat.setFromRotationMatrix(this._rotationMatrix);\n\n      this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\n\n      return this._rotationAxis.normalize().clone();\n    });\n\n    _defineProperty(this, \"calculateTbRadius\", camera => {\n      const factor = 0.67;\n      const distance = camera.position.distanceTo(this._gizmos.position);\n\n      if (camera.type == 'PerspectiveCamera') {\n        const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\n        const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)); //horizontal fov/2 in radians\n\n        return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor;\n      } else if (camera.type == 'OrthographicCamera') {\n        return Math.min(camera.top, camera.right) * factor;\n      }\n    });\n\n    _defineProperty(this, \"focus\", function (point, size) {\n      let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      const focusPoint = point.clone(); //move center of camera (along with gizmos) towards point of interest\n\n      focusPoint.sub(_this._gizmos.position).multiplyScalar(amount);\n\n      _this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);\n\n      const gizmoStateTemp = _this._gizmoMatrixState.clone();\n\n      _this._gizmoMatrixState.premultiply(_this._translationMatrix);\n\n      _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n\n      const cameraStateTemp = _this._cameraMatrixState.clone();\n\n      _this._cameraMatrixState.premultiply(_this._translationMatrix);\n\n      _this._cameraMatrixState.decompose(_this.camera.position, _this.camera.quaternion, _this.camera.scale); //apply zoom\n\n\n      if (_this.enableZoom) {\n        _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position));\n      }\n\n      _this._gizmoMatrixState.copy(gizmoStateTemp);\n\n      _this._cameraMatrixState.copy(cameraStateTemp);\n    });\n\n    _defineProperty(this, \"drawGrid\", () => {\n      if (this.scene != null) {\n        const color = 0x888888;\n        const multiplier = 3;\n        let size, divisions, maxLength, tick;\n\n        if (this.camera.isOrthographicCamera) {\n          const width = this.camera.right - this.camera.left;\n          const height = this.camera.bottom - this.camera.top;\n          maxLength = Math.max(width, height);\n          tick = maxLength / 20;\n          size = maxLength / this.camera.zoom * multiplier;\n          divisions = size / tick * this.camera.zoom;\n        } else if (this.camera.isPerspectiveCamera) {\n          const distance = this.camera.position.distanceTo(this._gizmos.position);\n          const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n          const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));\n          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n          tick = maxLength / 20;\n          size = maxLength * multiplier;\n          divisions = size / tick;\n        }\n\n        if (this._grid == null) {\n          this._grid = new GridHelper(size, divisions, color, color);\n\n          this._grid.position.copy(this._gizmos.position);\n\n          this._gridPosition.copy(this._grid.position);\n\n          this._grid.quaternion.copy(this.camera.quaternion);\n\n          this._grid.rotateX(Math.PI * 0.5);\n\n          this.scene.add(this._grid);\n        }\n      }\n    });\n\n    _defineProperty(this, \"connect\", domElement => {\n      this.domElement = domElement;\n      this.domElement.style.touchAction = 'none';\n      this.domElement.addEventListener('contextmenu', this.onContextMenu);\n      this.domElement.addEventListener('wheel', this.onWheel);\n      this.domElement.addEventListener('pointerdown', this.onPointerDown);\n      this.domElement.addEventListener('pointercancel', this.onPointerCancel);\n      window.addEventListener('keydown', this.onKeyDown);\n      window.addEventListener('resize', this.onWindowResize);\n    });\n\n    _defineProperty(this, \"dispose\", () => {\n      if (this._animationId != -1) {\n        window.cancelAnimationFrame(this._animationId);\n      }\n\n      this.domElement.removeEventListener('pointerdown', this.onPointerDown);\n      this.domElement.removeEventListener('pointercancel', this.onPointerCancel);\n      this.domElement.removeEventListener('wheel', this.onWheel);\n      this.domElement.removeEventListener('contextmenu', this.onContextMenu);\n      window.removeEventListener('pointermove', this.onPointerMove);\n      window.removeEventListener('pointerup', this.onPointerUp);\n      window.removeEventListener('resize', this.onWindowResize);\n      window.removeEventListener('keydown', this.onKeyDown);\n      if (this.scene) this.scene.remove(this._gizmos);\n      this.disposeGrid();\n    });\n\n    _defineProperty(this, \"disposeGrid\", () => {\n      if (this._grid != null && this.scene != null) {\n        this.scene.remove(this._grid);\n        this._grid = null;\n      }\n    });\n\n    _defineProperty(this, \"easeOutCubic\", t => {\n      return 1 - Math.pow(1 - t, 3);\n    });\n\n    _defineProperty(this, \"activateGizmos\", isActive => {\n      const gizmoX = this._gizmos.children[0];\n      const gizmoY = this._gizmos.children[1];\n      const gizmoZ = this._gizmos.children[2];\n\n      if (isActive) {\n        gizmoX.material.setValues({\n          opacity: 1\n        });\n        gizmoY.material.setValues({\n          opacity: 1\n        });\n        gizmoZ.material.setValues({\n          opacity: 1\n        });\n      } else {\n        gizmoX.material.setValues({\n          opacity: 0.6\n        });\n        gizmoY.material.setValues({\n          opacity: 0.6\n        });\n        gizmoZ.material.setValues({\n          opacity: 0.6\n        });\n      }\n    });\n\n    _defineProperty(this, \"getCursorNDC\", (cursorX, cursorY, canvas) => {\n      const canvasRect = canvas.getBoundingClientRect();\n\n      this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n\n      this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n\n      return this._v2_1.clone();\n    });\n\n    _defineProperty(this, \"getCursorPosition\", (cursorX, cursorY, canvas) => {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n      this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;\n      this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;\n      return this._v2_1.clone();\n    });\n\n    _defineProperty(this, \"setCamera\", camera => {\n      camera.lookAt(this.target);\n      camera.updateMatrix(); //setting state\n\n      if (camera.type == 'PerspectiveCamera') {\n        this._fov0 = camera.fov;\n        this._fovState = camera.fov;\n      }\n\n      this._cameraMatrixState0.copy(camera.matrix);\n\n      this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n      this._cameraProjectionState.copy(camera.projectionMatrix);\n\n      this._zoom0 = camera.zoom;\n      this._zoomState = this._zoom0;\n      this._initialNear = camera.near;\n      this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\n      this._nearPos = this._initialNear;\n      this._initialFar = camera.far;\n      this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\n      this._farPos = this._initialFar;\n\n      this._up0.copy(camera.up);\n\n      this._upState.copy(camera.up);\n\n      this.camera = camera;\n      this.camera.updateProjectionMatrix(); //making gizmos\n\n      this._tbRadius = this.calculateTbRadius(camera);\n      this.makeGizmos(this.target, this._tbRadius);\n    });\n\n    _defineProperty(this, \"makeGizmos\", (tbCenter, tbRadius) => {\n      const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n      const points = curve.getPoints(this._curvePts); //geometry\n\n      const curveGeometry = new BufferGeometry().setFromPoints(points); //material\n\n      const curveMaterialX = new LineBasicMaterial({\n        color: 0xff8080,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialY = new LineBasicMaterial({\n        color: 0x80ff80,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialZ = new LineBasicMaterial({\n        color: 0x8080ff,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      }); //line\n\n      const gizmoX = new Line(curveGeometry, curveMaterialX);\n      const gizmoY = new Line(curveGeometry, curveMaterialY);\n      const gizmoZ = new Line(curveGeometry, curveMaterialZ);\n      const rotation = Math.PI * 0.5;\n      gizmoX.rotation.x = rotation;\n      gizmoY.rotation.y = rotation; //setting state\n\n      this._gizmoMatrixState0.identity().setPosition(tbCenter);\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n      if (this.camera.zoom != 1) {\n        //adapt gizmos size to camera zoom\n        const size = 1 / this.camera.zoom;\n\n        this._scaleMatrix.makeScale(size, size, size);\n\n        this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n\n        this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\n\n        this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\n      }\n\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.clear();\n\n      this._gizmos.add(gizmoX);\n\n      this._gizmos.add(gizmoY);\n\n      this._gizmos.add(gizmoZ);\n    });\n\n    _defineProperty(this, \"onFocusAnim\", (time, point, cameraMatrix, gizmoMatrix) => {\n      if (this._timeStart == -1) {\n        //animation start\n        this._timeStart = time;\n      }\n\n      if (this._state == STATE.ANIMATION_FOCUS) {\n        const deltaTime = time - this._timeStart;\n        const animTime = deltaTime / this.focusAnimationTime;\n\n        this._gizmoMatrixState.copy(gizmoMatrix);\n\n        if (animTime >= 1) {\n          //animation end\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n          this.focus(point, this.scaleFactor);\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        } else {\n          const amount = this.easeOutCubic(animTime);\n          const size = 1 - amount + this.scaleFactor * amount;\n\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n          this.focus(point, size, amount);\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n          });\n        }\n      } else {\n        //interrupt animation\n        this._animationId = -1;\n        this._timeStart = -1;\n      }\n    });\n\n    _defineProperty(this, \"onRotationAnim\", (time, rotationAxis, w0) => {\n      if (this._timeStart == -1) {\n        //animation start\n        this._anglePrev = 0;\n        this._angleCurrent = 0;\n        this._timeStart = time;\n      }\n\n      if (this._state == STATE.ANIMATION_ROTATE) {\n        //w = w0 + alpha * t\n        const deltaTime = (time - this._timeStart) / 1000;\n        const w = w0 + -this.dampingFactor * deltaTime;\n\n        if (w > 0) {\n          //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n          this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n          this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onRotationAnim(t, rotationAxis, w0);\n          });\n        } else {\n          this._animationId = -1;\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        //interrupt animation\n        this._animationId = -1;\n        this._timeStart = -1;\n\n        if (this._state != STATE.ROTATE) {\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n    });\n\n    _defineProperty(this, \"pan\", function (p0, p1) {\n      let adjust = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const movement = p0.clone().sub(p1);\n\n      if (_this.camera.isOrthographicCamera) {\n        //adjust movement amount\n        movement.multiplyScalar(1 / _this.camera.zoom);\n      } else if (_this.camera.isPerspectiveCamera && adjust) {\n        //adjust movement amount\n        _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState0); //camera's initial position\n\n\n        _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState0); //gizmo's initial position\n\n\n        const distanceFactor = _this._v3_1.distanceTo(_this._v3_2) / _this.camera.position.distanceTo(_this._gizmos.position);\n\n        movement.multiplyScalar(1 / distanceFactor);\n      }\n\n      _this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(_this.camera.quaternion);\n\n      _this._m4_1.makeTranslation(_this._v3_1.x, _this._v3_1.y, _this._v3_1.z);\n\n      _this.setTransformationMatrices(_this._m4_1, _this._m4_1);\n\n      return _transformation;\n    });\n\n    _defineProperty(this, \"reset\", () => {\n      this.camera.zoom = this._zoom0;\n\n      if (this.camera.isPerspectiveCamera) {\n        this.camera.fov = this._fov0;\n      }\n\n      this.camera.near = this._nearPos;\n      this.camera.far = this._farPos;\n\n      this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n      this.camera.up.copy(this._up0);\n      this.camera.updateMatrix();\n      this.camera.updateProjectionMatrix();\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n      this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.updateMatrix();\n\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      this.makeGizmos(this._gizmos.position, this._tbRadius);\n      this.camera.lookAt(this._gizmos.position);\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_changeEvent);\n    });\n\n    _defineProperty(this, \"rotate\", (axis, angle) => {\n      const point = this._gizmos.position; //rotation center\n\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n      this._rotationMatrix.makeRotationAxis(axis, -angle); //rotate camera\n\n\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n      this._m4_1.multiply(this._rotationMatrix);\n\n      this._m4_1.multiply(this._translationMatrix);\n\n      this.setTransformationMatrices(this._m4_1);\n      return _transformation;\n    });\n\n    _defineProperty(this, \"copyState\", () => {\n      let state;\n\n      if (this.camera.isOrthographicCamera) {\n        state = JSON.stringify({\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        });\n      } else if (this.camera.isPerspectiveCamera) {\n        state = JSON.stringify({\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraFov: this.camera.fov,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        });\n      }\n\n      navigator.clipboard.writeText(state);\n    });\n\n    _defineProperty(this, \"pasteState\", () => {\n      const self = this;\n      navigator.clipboard.readText().then(function resolved(value) {\n        self.setStateFromJSON(value);\n      });\n    });\n\n    _defineProperty(this, \"saveState\", () => {\n      this._cameraMatrixState0.copy(this.camera.matrix);\n\n      this._gizmoMatrixState0.copy(this._gizmos.matrix);\n\n      this._nearPos = this.camera.near;\n      this._farPos = this.camera.far;\n      this._zoom0 = this.camera.zoom;\n\n      this._up0.copy(this.camera.up);\n\n      if (this.camera.isPerspectiveCamera) {\n        this._fov0 = this.camera.fov;\n      }\n    });\n\n    _defineProperty(this, \"applyScale\", function (size, point) {\n      let scaleGizmos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      const scalePoint = point.clone();\n      let sizeInverse = 1 / size;\n\n      if (_this.camera.isOrthographicCamera) {\n        //camera zoom\n        _this.camera.zoom = _this._zoomState;\n        _this.camera.zoom *= size; //check min and max zoom\n\n        if (_this.camera.zoom > _this.maxZoom) {\n          _this.camera.zoom = _this.maxZoom;\n          sizeInverse = _this._zoomState / _this.maxZoom;\n        } else if (_this.camera.zoom < _this.minZoom) {\n          _this.camera.zoom = _this.minZoom;\n          sizeInverse = _this._zoomState / _this.minZoom;\n        }\n\n        _this.camera.updateProjectionMatrix();\n\n        _this._v3_1.setFromMatrixPosition(_this._gizmoMatrixState); //gizmos position\n        //scale gizmos so they appear in the same spot having the same dimension\n\n\n        _this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n        _this._translationMatrix.makeTranslation(-_this._v3_1.x, -_this._v3_1.y, -_this._v3_1.z);\n\n        _this._m4_2.makeTranslation(_this._v3_1.x, _this._v3_1.y, _this._v3_1.z).multiply(_this._scaleMatrix);\n\n        _this._m4_2.multiply(_this._translationMatrix); //move camera and gizmos to obtain pinch effect\n\n\n        scalePoint.sub(_this._v3_1);\n        const amount = scalePoint.clone().multiplyScalar(sizeInverse);\n        scalePoint.sub(amount);\n\n        _this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);\n\n        _this._m4_2.premultiply(_this._m4_1);\n\n        _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n\n        return _transformation;\n      } else if (_this.camera.isPerspectiveCamera) {\n        _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n\n        _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState); //move camera\n\n\n        let distance = _this._v3_1.distanceTo(scalePoint);\n\n        let amount = distance - distance * sizeInverse; //check min and max distance\n\n        const newDistance = distance - amount;\n\n        if (newDistance < _this.minDistance) {\n          sizeInverse = _this.minDistance / distance;\n          amount = distance - distance * sizeInverse;\n        } else if (newDistance > _this.maxDistance) {\n          sizeInverse = _this.maxDistance / distance;\n          amount = distance - distance * sizeInverse;\n        }\n\n        let direction = scalePoint.clone().sub(_this._v3_1).normalize().multiplyScalar(amount);\n\n        _this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n\n        if (scaleGizmos) {\n          //scale gizmos so they appear in the same spot having the same dimension\n          const pos = _this._v3_2;\n          distance = pos.distanceTo(scalePoint);\n          amount = distance - distance * sizeInverse;\n          direction = scalePoint.clone().sub(_this._v3_2).normalize().multiplyScalar(amount);\n\n          _this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n\n          _this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n          _this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(_this._translationMatrix);\n\n          _this._m4_2.multiply(_this._scaleMatrix);\n\n          _this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n\n          _this._m4_2.multiply(_this._translationMatrix);\n\n          _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n        } else {\n          _this.setTransformationMatrices(_this._m4_1);\n        }\n\n        return _transformation;\n      }\n    });\n\n    _defineProperty(this, \"setFov\", value => {\n      if (this.camera.isPerspectiveCamera) {\n        this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\n        this.camera.updateProjectionMatrix();\n      }\n    });\n\n    _defineProperty(this, \"zRotate\", (point, angle) => {\n      this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\n\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n      this._m4_1.multiply(this._rotationMatrix);\n\n      this._m4_1.multiply(this._translationMatrix);\n\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point); //vector from rotation center to gizmos position\n\n\n      this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle); //apply rotation\n\n\n      this._v3_2.sub(this._v3_1);\n\n      this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\n\n      this.setTransformationMatrices(this._m4_1, this._m4_2);\n      return _transformation;\n    });\n\n    _defineProperty(this, \"unprojectOnObj\", (cursor, camera) => {\n      const raycaster = new Raycaster();\n      raycaster.near = camera.near;\n      raycaster.far = camera.far;\n      raycaster.setFromCamera(cursor, camera);\n      const intersect = raycaster.intersectObjects(this.scene.children, true);\n\n      for (let i = 0; i < intersect.length; i++) {\n        if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face != null) {\n          return intersect[i].point.clone();\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"unprojectOnTbSurface\", (camera, cursorX, cursorY, canvas, tbRadius) => {\n      if (camera.type == 'OrthographicCamera') {\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n\n        const x2 = Math.pow(this._v2_1.x, 2);\n        const y2 = Math.pow(this._v2_1.y, 2);\n        const r2 = Math.pow(this._tbRadius, 2);\n\n        if (x2 + y2 <= r2 * 0.5) {\n          //intersection with sphere\n          this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n        } else {\n          //intersection with hyperboloid\n          this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n        }\n\n        return this._v3_1;\n      } else if (camera.type == 'PerspectiveCamera') {\n        //unproject cursor on the near plane\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n        const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\n        const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n        const radius2 = Math.pow(tbRadius, 2); //\t  camera\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\th\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t_ _ | _ _ _\\ _ _  near plane\n        //\t\t\tl\n\n        const h = this._v3_1.z;\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n\n        if (l == 0) {\n          //ray aligned with camera\n          rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\n          return rayDir;\n        }\n\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        /*\n         * calculate intersection point between unprojected ray and trackball surface\n         *|y = m * x + q\n         *|x^2 + y^2 = r^2\n         *\n         * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n         */\n\n        let a = Math.pow(m, 2) + 1;\n        let b = 2 * m * q;\n        let c = Math.pow(q, 2) - radius2;\n        let delta = Math.pow(b, 2) - 4 * a * c;\n\n        if (delta >= 0) {\n          //intersection with sphere\n          this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n          this._v2_1.setY(m * this._v2_1.x + q);\n\n          const angle = MathUtils.RAD2DEG * this._v2_1.angle();\n\n          if (angle >= 45) {\n            //if angle between intersection point and X' axis is >= 45, return that point\n            //otherwise, calculate intersection point with hyperboloid\n            const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n            rayDir.multiplyScalar(rayLength);\n            rayDir.z += cameraGizmoDistance;\n            return rayDir;\n          }\n        } //intersection with hyperboloid\n\n        /*\n         *|y = m * x + q\n         *|y = (1 / x) * (r^2 / 2)\n         *\n         * m * x^2 + q * x - r^2 / 2 = 0\n         */\n\n\n        a = m;\n        b = q;\n        c = -radius2 * 0.5;\n        delta = Math.pow(b, 2) - 4 * a * c;\n\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n        this._v2_1.setY(m * this._v2_1.x + q);\n\n        const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z += cameraGizmoDistance;\n        return rayDir;\n      }\n    });\n\n    _defineProperty(this, \"unprojectOnTbPlane\", function (camera, cursorX, cursorY, canvas) {\n      let initialDistance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      if (camera.type == 'OrthographicCamera') {\n        _this._v2_1.copy(_this.getCursorPosition(cursorX, cursorY, canvas));\n\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, 0);\n\n        return _this._v3_1.clone();\n      } else if (camera.type == 'PerspectiveCamera') {\n        _this._v2_1.copy(_this.getCursorNDC(cursorX, cursorY, canvas)); //unproject cursor on the near plane\n\n\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, -1);\n\n        _this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n        const rayDir = _this._v3_1.clone().normalize(); //unprojected ray direction\n        //\t  camera\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\th\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t_ _ | _ _ _\\ _ _  near plane\n        //\t\t\tl\n\n\n        const h = _this._v3_1.z;\n        const l = Math.sqrt(Math.pow(_this._v3_1.x, 2) + Math.pow(_this._v3_1.y, 2));\n        let cameraGizmoDistance;\n\n        if (initialDistance) {\n          cameraGizmoDistance = _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState0).distanceTo(_this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState0));\n        } else {\n          cameraGizmoDistance = camera.position.distanceTo(_this._gizmos.position);\n        }\n        /*\n         * calculate intersection point between unprojected ray and the plane\n         *|y = mx + q\n         *|y = 0\n         *\n         * x = -q/m\n         */\n\n\n        if (l == 0) {\n          //ray aligned with camera\n          rayDir.set(0, 0, 0);\n          return rayDir;\n        }\n\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        const x = -q / m;\n        const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z = 0;\n        return rayDir;\n      }\n    });\n\n    _defineProperty(this, \"updateMatrixState\", () => {\n      //update camera and gizmos state\n      this._cameraMatrixState.copy(this.camera.matrix);\n\n      this._gizmoMatrixState.copy(this._gizmos.matrix);\n\n      if (this.camera.isOrthographicCamera) {\n        this._cameraProjectionState.copy(this.camera.projectionMatrix);\n\n        this.camera.updateProjectionMatrix();\n        this._zoomState = this.camera.zoom;\n      } else if (this.camera.isPerspectiveCamera) {\n        this._fovState = this.camera.fov;\n      }\n    });\n\n    _defineProperty(this, \"updateTbState\", (newState, updateMatrices) => {\n      this._state = newState;\n\n      if (updateMatrices) {\n        this.updateMatrixState();\n      }\n    });\n\n    _defineProperty(this, \"update\", () => {\n      const EPS = 0.000001; // Update target and gizmos state\n\n      if (!this.target.equals(this._currentTarget)) {\n        this._gizmos.position.set(this.target.x, this.target.y, this.target.z); //for correct radius calculation\n\n\n        this._tbRadius = this.calculateTbRadius(this.camera);\n        this.makeGizmos(this.target, this._tbRadius);\n\n        this._currentTarget.copy(this.target);\n      } //check min/max parameters\n\n\n      if (this.camera.isOrthographicCamera) {\n        //check zoom\n        if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n          const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);\n          this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true));\n        }\n      } else if (this.camera.isPerspectiveCamera) {\n        //check distance\n        const distance = this.camera.position.distanceTo(this._gizmos.position);\n\n        if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n          const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\n          this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position));\n          this.updateMatrixState();\n        } //check fov\n\n\n        if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n          this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);\n          this.camera.updateProjectionMatrix();\n        }\n\n        const oldRadius = this._tbRadius;\n        this._tbRadius = this.calculateTbRadius(this.camera);\n\n        if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n          const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n          const newRadius = this._tbRadius / scale;\n          const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n          const points = curve.getPoints(this._curvePts);\n          const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n          for (const gizmo in this._gizmos.children) {\n            this._gizmos.children[gizmo].geometry = curveGeometry;\n          }\n        }\n      }\n\n      this.camera.lookAt(this._gizmos.position);\n    });\n\n    _defineProperty(this, \"setStateFromJSON\", json => {\n      const state = JSON.parse(json);\n\n      if (state.arcballState != undefined) {\n        this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n        this.camera.up.copy(state.arcballState.cameraUp);\n        this.camera.near = state.arcballState.cameraNear;\n        this.camera.far = state.arcballState.cameraFar;\n        this.camera.zoom = state.arcballState.cameraZoom;\n\n        if (this.camera.isPerspectiveCamera) {\n          this.camera.fov = state.arcballState.cameraFov;\n        }\n\n        this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n        this.camera.updateMatrix();\n        this.camera.updateProjectionMatrix();\n\n        this._gizmos.updateMatrix();\n\n        this._tbRadius = this.calculateTbRadius(this.camera);\n        const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\n\n        this._gizmoMatrixState0.copy(gizmoTmp);\n\n        this.camera.lookAt(this._gizmos.position);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    this.camera = null;\n    this.scene = scene;\n    this.mouseActions = [];\n    this._mouseOp = null; //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\n    this._v2_1 = new Vector2();\n    this._v3_1 = new Vector3();\n    this._v3_2 = new Vector3();\n    this._m4_1 = new Matrix4();\n    this._m4_2 = new Matrix4();\n    this._quat = new Quaternion(); //transformation matrices\n\n    this._translationMatrix = new Matrix4(); //matrix for translation operation\n\n    this._rotationMatrix = new Matrix4(); //matrix for rotation operation\n\n    this._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n    this._rotationAxis = new Vector3(); //axis for rotate operation\n    //camera state\n\n    this._cameraMatrixState = new Matrix4();\n    this._cameraProjectionState = new Matrix4();\n    this._fovState = 1;\n    this._upState = new Vector3();\n    this._zoomState = 1;\n    this._nearPos = 0;\n    this._farPos = 0;\n    this._gizmoMatrixState = new Matrix4(); //initial values\n\n    this._up0 = new Vector3();\n    this._zoom0 = 1;\n    this._fov0 = 0;\n    this._initialNear = 0;\n    this._nearPos0 = 0;\n    this._initialFar = 0;\n    this._farPos0 = 0;\n    this._cameraMatrixState0 = new Matrix4();\n    this._gizmoMatrixState0 = new Matrix4(); //pointers array\n\n    this._button = -1;\n    this._touchStart = [];\n    this._touchCurrent = [];\n    this._input = INPUT.NONE; //two fingers touch interaction\n\n    this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released\n\n    this._startFingerDistance = 0; //distance between two fingers\n\n    this._currentFingerDistance = 0;\n    this._startFingerRotation = 0; //amount of rotation performed with two fingers\n\n    this._currentFingerRotation = 0; //double tap\n\n    this._devPxRatio = 0;\n    this._downValid = true;\n    this._nclicks = 0;\n    this._downEvents = [];\n    this._downStart = 0; //pointerDown time\n\n    this._clickStart = 0; //first click time\n\n    this._maxDownTime = 250;\n    this._maxInterval = 300;\n    this._posThreshold = 24;\n    this._movementThreshold = 24; //cursor positions\n\n    this._currentCursorPosition = new Vector3();\n    this._startCursorPosition = new Vector3(); //grid\n\n    this._grid = null; //grid to be visualized during pan operation\n\n    this._gridPosition = new Vector3(); //gizmos\n\n    this._gizmos = new Group();\n    this._curvePts = 128; //animations\n\n    this._timeStart = -1; //initial time\n\n    this._animationId = -1; //focus animation\n\n    this.focusAnimationTime = 500; //duration of focus animation in ms\n    //rotate animation\n\n    this._timePrev = 0; //time at which previous rotate operation has been detected\n\n    this._timeCurrent = 0; //time at which current rotate operation has been detected\n\n    this._anglePrev = 0; //angle of previous rotation\n\n    this._angleCurrent = 0; //angle of current rotation\n\n    this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected\n\n    this._cursorPosCurr = new Vector3(); //cursor position when current rotate operation has been detected\n\n    this._wPrev = 0; //angular velocity of the previous rotate operation\n\n    this._wCurr = 0; //angular velocity of the current rotate operation\n    //parameters\n\n    this.adjustNearFar = false;\n    this.scaleFactor = 1.1; //zoom/distance multiplier\n\n    this.dampingFactor = 25;\n    this.wMax = 20; //maximum angular velocity allowed\n\n    this.enableAnimations = true; //if animations should be performed\n\n    this.enableGrid = false; //if grid should be showed during pan operation\n\n    this.cursorZoom = false; //if wheel zoom should be cursor centered\n\n    this.minFov = 5;\n    this.maxFov = 90;\n    this.enabled = true;\n    this.enablePan = true;\n    this.enableRotate = true;\n    this.enableZoom = true;\n    this.enableGizmos = true;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity; //trackball parameters\n\n    this.target = new Vector3(0, 0, 0);\n    this._currentTarget = new Vector3(0, 0, 0);\n    this._tbRadius = 1; //FSA\n\n    this._state = STATE.IDLE;\n    this.setCamera(_camera);\n\n    if (this.scene != null) {\n      this.scene.add(this._gizmos);\n    } // connect events\n\n\n    if (_domElement !== undefined) this.connect(_domElement);\n    this._devPxRatio = window.devicePixelRatio;\n    this.initializeMouseActions();\n  } //listeners\n\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n\n\n  applyTransformMatrix(transformation) {\n    if (transformation.camera != null) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n      this.camera.updateMatrix(); //update camera up vector\n\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n      }\n    }\n\n    if (transformation.gizmos != null) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.updateMatrix();\n    }\n\n    if (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) {\n      this._tbRadius = this.calculateTbRadius(this.camera);\n\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n        const bb = new Box3();\n        bb.setFromObject(this._gizmos);\n        const sphere = new Sphere();\n        bb.getBoundingSphere(sphere);\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n        const regularNearPosition = cameraDistance - this._initialNear;\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n        this.camera.near = cameraDistance - minNearPos;\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n        const regularFarPosition = cameraDistance - this._initialFar;\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n        this.camera.far = cameraDistance - minFarPos;\n        this.camera.updateProjectionMatrix();\n      } else {\n        let update = false;\n\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear;\n          update = true;\n        }\n\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar;\n          update = true;\n        }\n\n        if (update) {\n          this.camera.updateProjectionMatrix();\n        }\n      }\n    }\n  }\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n\n\n  setGizmosVisible(value) {\n    this._gizmos.visible = value;\n    this.dispatchEvent(_changeEvent);\n  }\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n\n\n  setTransformationMatrices() {\n    let camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let gizmos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (camera != null) {\n      if (_transformation.camera != null) {\n        _transformation.camera.copy(camera);\n      } else {\n        _transformation.camera = camera.clone();\n      }\n    } else {\n      _transformation.camera = null;\n    }\n\n    if (gizmos != null) {\n      if (_transformation.gizmos != null) {\n        _transformation.gizmos.copy(gizmos);\n      } else {\n        _transformation.gizmos = gizmos.clone();\n      }\n    } else {\n      _transformation.gizmos = null;\n    }\n  }\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n\n\n}\n\nexport { ArcballControls };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/controls/ArcballControls.js"],"names":["_defineProperty","Matrix4","EventDispatcher","EllipseCurve","BufferGeometry","MathUtils","Vector3","GridHelper","LineBasicMaterial","Line","Raycaster","Vector2","Quaternion","Group","Box3","Sphere","STATE","IDLE","Symbol","ROTATE","PAN","SCALE","FOV","FOCUS","ZROTATE","TOUCH_MULTI","ANIMATION_FOCUS","ANIMATION_ROTATE","INPUT","NONE","ONE_FINGER","ONE_FINGER_SWITCHED","TWO_FINGER","MULT_FINGER","CURSOR","_center","x","y","_transformation","camera","gizmos","_changeEvent","type","_startEvent","_endEvent","ArcballControls","constructor","_camera","_domElement","scene","scale","_gizmos","z","_tbRadius","calculateTbRadius","newRadius","curve","points","getPoints","_curvePts","curveGeometry","setFromPoints","gizmo","children","geometry","dispatchEvent","event","enabled","i","mouseActions","length","mouse","preventDefault","_touchStart","splice","_touchCurrent","_input","button","isPrimary","_downValid","_downEvents","push","_downStart","performance","now","pointerType","onSinglePanStart","window","addEventListener","onPointerMove","onPointerUp","onRotateStart","onPinchStart","onDoublePanStart","onTriplePanStart","modifier","ctrlKey","metaKey","shiftKey","_mouseOp","getOpFromAction","_button","updateTouchEvent","onSinglePanMove","movement","calculatePointersDistance","_devPxRatio","_switchSensibility","onRotateMove","onPinchMove","onDoublePanMove","onTriplePanMove","mouseOpState","getOpStateFromAction","_movementThreshold","nTouch","pointerId","removeEventListener","onSinglePanEnd","onDoublePanEnd","onPinchEnd","onRotateEnd","onTriplePanEnd","downTime","timeStamp","_maxDownTime","_nclicks","_clickStart","clickInterval","_maxInterval","_posThreshold","onDoubleTap","shift","enableZoom","mouseOp","notchDeltaY","sgn","deltaY","size","scaleFactor","updateTbState","Math","pow","cursorZoom","enablePan","scalePoint","isOrthographicCamera","unprojectOnTbPlane","clientX","clientY","domElement","applyQuaternion","quaternion","multiplyScalar","zoom","add","position","isPerspectiveCamera","applyTransformMatrix","applyScale","_grid","disposeGrid","drawGrid","deltaX","_v3_1","setFromMatrixPosition","_cameraMatrixState","distanceTo","xNew","clamp","minDistance","maxDistance","tan","DEG2RAD","fov","newFov","RAD2DEG","atan","maxFov","minFov","newDistance","setFov","key","copyState","pasteState","operation","setCenter","_animationId","cancelAnimationFrame","_timeStart","activateGizmos","_startCursorPosition","copy","enableGrid","enableRotate","unprojectOnTbSurface","enableAnimations","_timePrev","_timeCurrent","_angleCurrent","_anglePrev","_cursorPosPrev","_cursorPosCurr","_wCurr","_wPrev","setY","getCursorNDC","_currentCursorPosition","opState","restart","_state","pan","distance","angle","angleTo","amount","max","rotate","calculateRotationAxis","calculateAngularSpeed","screenNotches","_fovState","_v3_2","_gizmoMatrixState","direction","clone","sub","normalize","_m4_1","makeTranslation","deltaTime","w","abs","self","requestAnimationFrame","t","rotationAxis","onRotationAnim","min","wMax","hitP","unprojectOnObj","onFocusAnim","focus","_startFingerRotation","getAngle","_currentFingerRotation","getWorldDirection","_rotationAxis","rotationPoint","zRotate","_startFingerDistance","_currentFingerDistance","nFingers","setMouseAction","action1","action2","operationInput","mouseInput","keyInput","state","includes","action","p1","p2","atan2","PI","p0","t0","t1","s","sqrt","vec1","vec2","_rotationMatrix","extractRotation","_quat","setFromRotationMatrix","crossVectors","factor","halfFovV","halfFovH","aspect","top","right","point","focusPoint","_translationMatrix","gizmoStateTemp","premultiply","decompose","cameraStateTemp","color","multiplier","divisions","maxLength","tick","width","left","height","bottom","_gridPosition","rotateX","style","touchAction","onContextMenu","onWheel","onPointerDown","onPointerCancel","onKeyDown","onWindowResize","remove","isActive","gizmoX","gizmoY","gizmoZ","material","setValues","opacity","cursorX","cursorY","canvas","canvasRect","getBoundingClientRect","_v2_1","setX","lookAt","target","updateMatrix","_fov0","_cameraMatrixState0","matrix","_cameraProjectionState","projectionMatrix","_zoom0","_zoomState","_initialNear","near","_nearPos0","_nearPos","_initialFar","far","_farPos0","_farPos","_up0","up","_upState","updateProjectionMatrix","makeGizmos","tbCenter","tbRadius","curveMaterialX","fog","transparent","curveMaterialY","curveMaterialZ","rotation","_gizmoMatrixState0","identity","setPosition","_scaleMatrix","makeScale","clear","time","cameraMatrix","gizmoMatrix","animTime","focusAnimationTime","easeOutCubic","w0","dampingFactor","adjust","distanceFactor","set","setTransformationMatrices","axis","makeRotationAxis","multiply","JSON","stringify","arcballState","cameraFar","cameraNear","cameraUp","cameraZoom","cameraFov","navigator","clipboard","writeText","readText","then","resolved","value","setStateFromJSON","scaleGizmos","sizeInverse","maxZoom","minZoom","_m4_2","pos","applyAxisAngle","cursor","raycaster","setFromCamera","intersect","intersectObjects","object","uuid","face","getCursorPosition","x2","y2","r2","setZ","applyMatrix4","projectionMatrixInverse","rayDir","cameraGizmoDistance","radius2","h","l","m","q","a","b","c","delta","rayLength","initialDistance","newState","updateMatrices","updateMatrixState","EPS","equals","_currentTarget","newZoom","oldRadius","json","parse","undefined","fromArray","elements","gizmoTmp","adjustNearFar","enableGizmos","Infinity","setCamera","connect","devicePixelRatio","initializeMouseActions","transformation","cameraDistance","bb","setFromObject","sphere","getBoundingSphere","adjustedNearPosition","radius","center","regularNearPosition","minNearPos","adjustedFarPosition","regularFarPosition","minFarPos","update","setGizmosVisible","visible"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Matrix4, EventDispatcher, EllipseCurve, BufferGeometry, MathUtils, Vector3, GridHelper, LineBasicMaterial, Line, Raycaster, Vector2, Quaternion, Group, Box3, Sphere } from 'three';\n\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n}; //cursor center coordinates\n\nconst _center = {\n  x: 0,\n  y: 0\n}; //transformation matrices for gizmos and camera\n\nconst _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n}; //events\n\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\n/**\n *\n * @param {Camera} camera Virtual camera used in the scene\n * @param {HTMLElement} domElement Renderer's dom element\n * @param {Scene} scene The scene to be rendered\n */\n\nclass ArcballControls extends EventDispatcher {\n  constructor(_camera, _domElement, scene = null) {\n    super();\n\n    _defineProperty(this, \"onWindowResize\", () => {\n      const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      const newRadius = this._tbRadius / scale;\n      const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n      const points = curve.getPoints(this._curvePts);\n      const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n      for (const gizmo in this._gizmos.children) {\n        this._gizmos.children[gizmo].geometry = curveGeometry;\n      }\n\n      this.dispatchEvent(_changeEvent);\n    });\n\n    _defineProperty(this, \"onContextMenu\", event => {\n      if (!this.enabled) {\n        return;\n      }\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == 2) {\n          //prevent only if button 2 is actually used\n          event.preventDefault();\n          break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerCancel\", () => {\n      this._touchStart.splice(0, this._touchStart.length);\n\n      this._touchCurrent.splice(0, this._touchCurrent.length);\n\n      this._input = INPUT.NONE;\n    });\n\n    _defineProperty(this, \"onPointerDown\", event => {\n      if (event.button == 0 && event.isPrimary) {\n        this._downValid = true;\n\n        this._downEvents.push(event);\n\n        this._downStart = performance.now();\n      } else {\n        this._downValid = false;\n      }\n\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        this._touchStart.push(event);\n\n        this._touchCurrent.push(event);\n\n        switch (this._input) {\n          case INPUT.NONE:\n            //singleStart\n            this._input = INPUT.ONE_FINGER;\n            this.onSinglePanStart(event, 'ROTATE');\n            window.addEventListener('pointermove', this.onPointerMove);\n            window.addEventListener('pointerup', this.onPointerUp);\n            break;\n\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            //doubleStart\n            this._input = INPUT.TWO_FINGER;\n            this.onRotateStart();\n            this.onPinchStart();\n            this.onDoublePanStart();\n            break;\n\n          case INPUT.TWO_FINGER:\n            //multipleStart\n            this._input = INPUT.MULT_FINGER;\n            this.onTriplePanStart(event);\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        this._mouseOp = this.getOpFromAction(event.button, modifier);\n\n        if (this._mouseOp != null) {\n          window.addEventListener('pointermove', this.onPointerMove);\n          window.addEventListener('pointerup', this.onPointerUp); //singleStart\n\n          this._input = INPUT.CURSOR;\n          this._button = event.button;\n          this.onSinglePanStart(event, this._mouseOp);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerMove\", event => {\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n            //singleMove\n            this.updateTouchEvent(event);\n            this.onSinglePanMove(event, STATE.ROTATE);\n            break;\n\n          case INPUT.ONE_FINGER_SWITCHED:\n            const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\n\n            if (movement >= this._switchSensibility) {\n              //singleMove\n              this._input = INPUT.ONE_FINGER;\n              this.updateTouchEvent(event);\n              this.onSinglePanStart(event, 'ROTATE');\n              break;\n            }\n\n            break;\n\n          case INPUT.TWO_FINGER:\n            //rotate/pan/pinchMove\n            this.updateTouchEvent(event);\n            this.onRotateMove();\n            this.onPinchMove();\n            this.onDoublePanMove();\n            break;\n\n          case INPUT.MULT_FINGER:\n            //multMove\n            this.updateTouchEvent(event);\n            this.onTriplePanMove(event);\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        const mouseOpState = this.getOpStateFromAction(this._button, modifier);\n\n        if (mouseOpState != null) {\n          this.onSinglePanMove(event, mouseOpState);\n        }\n      } //checkDistance\n\n\n      if (this._downValid) {\n        const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\n\n        if (movement > this._movementThreshold) {\n          this._downValid = false;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerUp\", event => {\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        const nTouch = this._touchCurrent.length;\n\n        for (let i = 0; i < nTouch; i++) {\n          if (this._touchCurrent[i].pointerId == event.pointerId) {\n            this._touchCurrent.splice(i, 1);\n\n            this._touchStart.splice(i, 1);\n\n            break;\n          }\n        }\n\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            //singleEnd\n            window.removeEventListener('pointermove', this.onPointerMove);\n            window.removeEventListener('pointerup', this.onPointerUp);\n            this._input = INPUT.NONE;\n            this.onSinglePanEnd();\n            break;\n\n          case INPUT.TWO_FINGER:\n            //doubleEnd\n            this.onDoublePanEnd(event);\n            this.onPinchEnd(event);\n            this.onRotateEnd(event); //switching to singleStart\n\n            this._input = INPUT.ONE_FINGER_SWITCHED;\n            break;\n\n          case INPUT.MULT_FINGER:\n            if (this._touchCurrent.length == 0) {\n              window.removeEventListener('pointermove', this.onPointerMove);\n              window.removeEventListener('pointerup', this.onPointerUp); //multCancel\n\n              this._input = INPUT.NONE;\n              this.onTriplePanEnd();\n            }\n\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n        window.removeEventListener('pointermove', this.onPointerMove);\n        window.removeEventListener('pointerup', this.onPointerUp);\n        this._input = INPUT.NONE;\n        this.onSinglePanEnd();\n        this._button = -1;\n      }\n\n      if (event.isPrimary) {\n        if (this._downValid) {\n          const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\n\n          if (downTime <= this._maxDownTime) {\n            if (this._nclicks == 0) {\n              //first valid click detected\n              this._nclicks = 1;\n              this._clickStart = performance.now();\n            } else {\n              const clickInterval = event.timeStamp - this._clickStart;\n\n              const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\n\n              if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n                //second valid click detected\n                //fire double tap and reset values\n                this._nclicks = 0;\n\n                this._downEvents.splice(0, this._downEvents.length);\n\n                this.onDoubleTap(event);\n              } else {\n                //new 'first click'\n                this._nclicks = 1;\n\n                this._downEvents.shift();\n\n                this._clickStart = performance.now();\n              }\n            }\n          } else {\n            this._downValid = false;\n            this._nclicks = 0;\n\n            this._downEvents.splice(0, this._downEvents.length);\n          }\n        } else {\n          this._nclicks = 0;\n\n          this._downEvents.splice(0, this._downEvents.length);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onWheel\", event => {\n      if (this.enabled && this.enableZoom) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        const mouseOp = this.getOpFromAction('WHEEL', modifier);\n\n        if (mouseOp != null) {\n          event.preventDefault();\n          this.dispatchEvent(_startEvent);\n          const notchDeltaY = 125; //distance of one notch of mouse wheel\n\n          let sgn = event.deltaY / notchDeltaY;\n          let size = 1;\n\n          if (sgn > 0) {\n            size = 1 / this.scaleFactor;\n          } else if (sgn < 0) {\n            size = this.scaleFactor;\n          }\n\n          switch (mouseOp) {\n            case 'ZOOM':\n              this.updateTbState(STATE.SCALE, true);\n\n              if (sgn > 0) {\n                size = 1 / Math.pow(this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(this.scaleFactor, -sgn);\n              }\n\n              if (this.cursorZoom && this.enablePan) {\n                let scalePoint;\n\n                if (this.camera.isOrthographicCamera) {\n                  scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n                } else if (this.camera.isPerspectiveCamera) {\n                  scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n                }\n\n                this.applyTransformMatrix(this.applyScale(size, scalePoint));\n              } else {\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n\n              if (this._grid != null) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n\n            case 'FOV':\n              if (this.camera.isPerspectiveCamera) {\n                this.updateTbState(STATE.FOV, true); //Vertigo effect\n                //\t  fov / 2\n                //\t\t|\\\n                //\t\t| \\\n                //\t\t|  \\\n                //\tx\t|\t\\\n                //\t\t| \t \\\n                //\t\t| \t  \\\n                //\t\t| _ _ _\\\n                //\t\t\ty\n                //check for iOs shift shortcut\n\n                if (event.deltaX != 0) {\n                  sgn = event.deltaX / notchDeltaY;\n                  size = 1;\n\n                  if (sgn > 0) {\n                    size = 1 / Math.pow(this.scaleFactor, sgn);\n                  } else if (sgn < 0) {\n                    size = Math.pow(this.scaleFactor, -sgn);\n                  }\n                }\n\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n                //check min and max distance\n\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5); //calculate new fov\n\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n                if (newFov > this.maxFov) {\n                  newFov = this.maxFov;\n                } else if (newFov < this.minFov) {\n                  newFov = this.minFov;\n                }\n\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false));\n              }\n\n              if (this._grid != null) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n          }\n        }\n      }\n    });\n\n    _defineProperty(this, \"onKeyDown\", event => {\n      if (event.key == 'c') {\n        if (event.ctrlKey || event.metaKey) {\n          this.copyState();\n        }\n      } else if (event.key == 'v') {\n        if (event.ctrlKey || event.metaKey) {\n          this.pasteState();\n        }\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanStart\", (event, operation) => {\n      if (this.enabled) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n\n        switch (operation) {\n          case 'PAN':\n            if (!this.enablePan) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            this.updateTbState(STATE.PAN, true);\n\n            this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n            if (this.enableGrid) {\n              this.drawGrid();\n              this.dispatchEvent(_changeEvent);\n            }\n\n            break;\n\n          case 'ROTATE':\n            if (!this.enableRotate) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n            }\n\n            this.updateTbState(STATE.ROTATE, true);\n\n            this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n            this.activateGizmos(true);\n\n            if (this.enableAnimations) {\n              this._timePrev = this._timeCurrent = performance.now();\n              this._angleCurrent = this._anglePrev = 0;\n\n              this._cursorPosPrev.copy(this._startCursorPosition);\n\n              this._cursorPosCurr.copy(this._cursorPosPrev);\n\n              this._wCurr = 0;\n              this._wPrev = this._wCurr;\n            }\n\n            this.dispatchEvent(_changeEvent);\n            break;\n\n          case 'FOV':\n            if (!this.camera.isPerspectiveCamera || !this.enableZoom) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            this.updateTbState(STATE.FOV, true);\n\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n            this._currentCursorPosition.copy(this._startCursorPosition);\n\n            break;\n\n          case 'ZOOM':\n            if (!this.enableZoom) {\n              return;\n            }\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            this.updateTbState(STATE.SCALE, true);\n\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n            this._currentCursorPosition.copy(this._startCursorPosition);\n\n            break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanMove\", (event, opState) => {\n      if (this.enabled) {\n        const restart = opState != this._state;\n        this.setCenter(event.clientX, event.clientY);\n\n        switch (opState) {\n          case STATE.PAN:\n            if (this.enablePan) {\n              if (restart) {\n                //switch to pan operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n                if (this.enableGrid) {\n                  this.drawGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with pan operation\n                this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement));\n\n                this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\n              }\n            }\n\n            break;\n\n          case STATE.ROTATE:\n            if (this.enableRotate) {\n              if (restart) {\n                //switch to rotate operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(true);\n              } else {\n                //continue with rotate operation\n                this._currentCursorPosition.copy(this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius));\n\n                const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\n\n                const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\n\n                const amount = Math.max(distance / this._tbRadius, angle); //effective rotation angle\n\n                this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\n\n                if (this.enableAnimations) {\n                  this._timePrev = this._timeCurrent;\n                  this._timeCurrent = performance.now();\n                  this._anglePrev = this._angleCurrent;\n                  this._angleCurrent = amount;\n\n                  this._cursorPosPrev.copy(this._cursorPosCurr);\n\n                  this._cursorPosCurr.copy(this._currentCursorPosition);\n\n                  this._wPrev = this._wCurr;\n                  this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\n                }\n              }\n            }\n\n            break;\n\n          case STATE.SCALE:\n            if (this.enableZoom) {\n              if (restart) {\n                //switch to zoom operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                this._currentCursorPosition.copy(this._startCursorPosition);\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with zoom operation\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n            }\n\n            break;\n\n          case STATE.FOV:\n            if (this.enableZoom && this.camera.isPerspectiveCamera) {\n              if (restart) {\n                //switch to fov operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                this._currentCursorPosition.copy(this._startCursorPosition);\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with fov operation\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n                //check min and max distance\n\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n                newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n\n                this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\n\n                const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n                this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n              }\n            }\n\n            break;\n        }\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanEnd\", () => {\n      if (this._state == STATE.ROTATE) {\n        if (!this.enableRotate) {\n          return;\n        }\n\n        if (this.enableAnimations) {\n          //perform rotation animation\n          const deltaTime = performance.now() - this._timeCurrent;\n\n          if (deltaTime < 120) {\n            const w = Math.abs((this._wPrev + this._wCurr) / 2);\n            const self = this;\n            this._animationId = window.requestAnimationFrame(function (t) {\n              self.updateTbState(STATE.ANIMATION_ROTATE, true);\n              const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n              self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n            });\n          } else {\n            //cursor has been standing still for over 120 ms since last movement\n            this.updateTbState(STATE.IDLE, false);\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n        } else {\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n        this.updateTbState(STATE.IDLE, false);\n\n        if (this.enableGrid) {\n          this.disposeGrid();\n        }\n\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onDoubleTap\", event => {\n      if (this.enabled && this.enablePan && this.scene != null) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n        const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);\n\n        if (hitP != null && this.enableAnimations) {\n          const self = this;\n\n          if (this._animationId != -1) {\n            window.cancelAnimationFrame(this._animationId);\n          }\n\n          this._timeStart = -1;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_FOCUS, true);\n            self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n          });\n        } else if (hitP != null && !this.enableAnimations) {\n          this.updateTbState(STATE.FOCUS, true);\n          this.focus(hitP, this.scaleFactor);\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onDoublePanStart\", () => {\n      if (this.enabled && this.enablePan) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.PAN, true);\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n\n        this._startCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n\n        this._currentCursorPosition.copy(this._startCursorPosition);\n\n        this.activateGizmos(false);\n      }\n    });\n\n    _defineProperty(this, \"onDoublePanMove\", () => {\n      if (this.enabled && this.enablePan) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n\n        if (this._state != STATE.PAN) {\n          this.updateTbState(STATE.PAN, true);\n\n          this._startCursorPosition.copy(this._currentCursorPosition);\n        }\n\n        this._currentCursorPosition.copy(this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true));\n\n        this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onDoublePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onRotateStart\", () => {\n      if (this.enabled && this.enableRotate) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.ZROTATE, true); //this._startFingerRotation = event.rotation;\n\n        this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n        this._currentFingerRotation = this._startFingerRotation;\n        this.camera.getWorldDirection(this._rotationAxis); //rotation axis\n\n        if (!this.enablePan && !this.enableZoom) {\n          this.activateGizmos(true);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onRotateMove\", () => {\n      if (this.enabled && this.enableRotate) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        let rotationPoint;\n\n        if (this._state != STATE.ZROTATE) {\n          this.updateTbState(STATE.ZROTATE, true);\n          this._startFingerRotation = this._currentFingerRotation;\n        } //this._currentFingerRotation = event.rotation;\n\n\n        this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n\n        if (!this.enablePan) {\n          rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\n        } else {\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n          rotationPoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);\n        }\n\n        const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\n        this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onRotateEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.activateGizmos(false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onPinchStart\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true);\n        this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\n        this._currentFingerDistance = this._startFingerDistance;\n        this.activateGizmos(false);\n      }\n    });\n\n    _defineProperty(this, \"onPinchMove\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        const minDistance = 12; //minimum distance between fingers (in css pixels)\n\n        if (this._state != STATE.SCALE) {\n          this._startFingerDistance = this._currentFingerDistance;\n          this.updateTbState(STATE.SCALE, true);\n        }\n\n        this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\n        const amount = this._currentFingerDistance / this._startFingerDistance;\n        let scalePoint;\n\n        if (!this.enablePan) {\n          scalePoint = this._gizmos.position;\n        } else {\n          if (this.camera.isOrthographicCamera) {\n            scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n          } else if (this.camera.isPerspectiveCamera) {\n            scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement).applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n          }\n        }\n\n        this.applyTransformMatrix(this.applyScale(amount, scalePoint));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onPinchEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onTriplePanStart\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true); //const center = event.center;\n\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n\n        this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n        this._currentCursorPosition.copy(this._startCursorPosition);\n      }\n    });\n\n    _defineProperty(this, \"onTriplePanMove\", () => {\n      if (this.enabled && this.enableZoom) {\n        //\t  fov / 2\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\tx\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t\t| _ _ _\\\n        //\t\t\ty\n        //const center = event.center;\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n        const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n        this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n        const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n        let size = 1;\n\n        if (movement < 0) {\n          size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n        } else if (movement > 0) {\n          size = Math.pow(this.scaleFactor, movement * screenNotches);\n        }\n\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n        const x = this._v3_1.distanceTo(this._gizmos.position);\n\n        let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n        //check min and max distance\n\n        xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n        const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n        let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n        newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n        const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n        size = x / newDistance;\n\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n        this.setFov(newFov);\n        this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\n\n        const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onTriplePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent); //this.dispatchEvent( _changeEvent );\n    });\n\n    _defineProperty(this, \"setCenter\", (clientX, clientY) => {\n      _center.x = clientX;\n      _center.y = clientY;\n    });\n\n    _defineProperty(this, \"initializeMouseActions\", () => {\n      this.setMouseAction('PAN', 0, 'CTRL');\n      this.setMouseAction('PAN', 2);\n      this.setMouseAction('ROTATE', 0);\n      this.setMouseAction('ZOOM', 'WHEEL');\n      this.setMouseAction('ZOOM', 1);\n      this.setMouseAction('FOV', 'WHEEL', 'SHIFT');\n      this.setMouseAction('FOV', 1, 'SHIFT');\n    });\n\n    _defineProperty(this, \"compareMouseAction\", (action1, action2) => {\n      if (action1.operation == action2.operation) {\n        if (action1.mouse == action2.mouse && action1.key == action2.key) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    });\n\n    _defineProperty(this, \"setMouseAction\", (operation, mouse, key = null) => {\n      const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV'];\n      const mouseInput = [0, 1, 2, 'WHEEL'];\n      const keyInput = ['CTRL', 'SHIFT', null];\n      let state;\n\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n        //invalid parameters\n        return false;\n      }\n\n      if (mouse == 'WHEEL') {\n        if (operation != 'ZOOM' && operation != 'FOV') {\n          //cannot associate 2D operation to 1D input\n          return false;\n        }\n      }\n\n      switch (operation) {\n        case 'PAN':\n          state = STATE.PAN;\n          break;\n\n        case 'ROTATE':\n          state = STATE.ROTATE;\n          break;\n\n        case 'ZOOM':\n          state = STATE.SCALE;\n          break;\n\n        case 'FOV':\n          state = STATE.FOV;\n          break;\n      }\n\n      const action = {\n        operation: operation,\n        mouse: mouse,\n        key: key,\n        state: state\n      };\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n          this.mouseActions.splice(i, 1, action);\n          return true;\n        }\n      }\n\n      this.mouseActions.push(action);\n      return true;\n    });\n\n    _defineProperty(this, \"unsetMouseAction\", (mouse, key = null) => {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == mouse && this.mouseActions[i].key == key) {\n          this.mouseActions.splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    });\n\n    _defineProperty(this, \"getOpFromAction\", (mouse, key) => {\n      let action;\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == key) {\n          return action.operation;\n        }\n      }\n\n      if (key != null) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n\n          if (action.mouse == mouse && action.key == null) {\n            return action.operation;\n          }\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"getOpStateFromAction\", (mouse, key) => {\n      let action;\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == key) {\n          return action.state;\n        }\n      }\n\n      if (key != null) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n\n          if (action.mouse == mouse && action.key == null) {\n            return action.state;\n          }\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"getAngle\", (p1, p2) => {\n      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n    });\n\n    _defineProperty(this, \"updateTouchEvent\", event => {\n      for (let i = 0; i < this._touchCurrent.length; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1, event);\n\n          break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"calculateAngularSpeed\", (p0, p1, t0, t1) => {\n      const s = p1 - p0;\n      const t = (t1 - t0) / 1000;\n\n      if (t == 0) {\n        return 0;\n      }\n\n      return s / t;\n    });\n\n    _defineProperty(this, \"calculatePointersDistance\", (p0, p1) => {\n      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n    });\n\n    _defineProperty(this, \"calculateRotationAxis\", (vec1, vec2) => {\n      this._rotationMatrix.extractRotation(this._cameraMatrixState);\n\n      this._quat.setFromRotationMatrix(this._rotationMatrix);\n\n      this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\n\n      return this._rotationAxis.normalize().clone();\n    });\n\n    _defineProperty(this, \"calculateTbRadius\", camera => {\n      const factor = 0.67;\n      const distance = camera.position.distanceTo(this._gizmos.position);\n\n      if (camera.type == 'PerspectiveCamera') {\n        const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\n        const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)); //horizontal fov/2 in radians\n\n        return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor;\n      } else if (camera.type == 'OrthographicCamera') {\n        return Math.min(camera.top, camera.right) * factor;\n      }\n    });\n\n    _defineProperty(this, \"focus\", (point, size, amount = 1) => {\n      const focusPoint = point.clone(); //move center of camera (along with gizmos) towards point of interest\n\n      focusPoint.sub(this._gizmos.position).multiplyScalar(amount);\n\n      this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);\n\n      const gizmoStateTemp = this._gizmoMatrixState.clone();\n\n      this._gizmoMatrixState.premultiply(this._translationMatrix);\n\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      const cameraStateTemp = this._cameraMatrixState.clone();\n\n      this._cameraMatrixState.premultiply(this._translationMatrix);\n\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale); //apply zoom\n\n\n      if (this.enableZoom) {\n        this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n      }\n\n      this._gizmoMatrixState.copy(gizmoStateTemp);\n\n      this._cameraMatrixState.copy(cameraStateTemp);\n    });\n\n    _defineProperty(this, \"drawGrid\", () => {\n      if (this.scene != null) {\n        const color = 0x888888;\n        const multiplier = 3;\n        let size, divisions, maxLength, tick;\n\n        if (this.camera.isOrthographicCamera) {\n          const width = this.camera.right - this.camera.left;\n          const height = this.camera.bottom - this.camera.top;\n          maxLength = Math.max(width, height);\n          tick = maxLength / 20;\n          size = maxLength / this.camera.zoom * multiplier;\n          divisions = size / tick * this.camera.zoom;\n        } else if (this.camera.isPerspectiveCamera) {\n          const distance = this.camera.position.distanceTo(this._gizmos.position);\n          const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n          const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));\n          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n          tick = maxLength / 20;\n          size = maxLength * multiplier;\n          divisions = size / tick;\n        }\n\n        if (this._grid == null) {\n          this._grid = new GridHelper(size, divisions, color, color);\n\n          this._grid.position.copy(this._gizmos.position);\n\n          this._gridPosition.copy(this._grid.position);\n\n          this._grid.quaternion.copy(this.camera.quaternion);\n\n          this._grid.rotateX(Math.PI * 0.5);\n\n          this.scene.add(this._grid);\n        }\n      }\n    });\n\n    _defineProperty(this, \"connect\", domElement => {\n      this.domElement = domElement;\n      this.domElement.style.touchAction = 'none';\n      this.domElement.addEventListener('contextmenu', this.onContextMenu);\n      this.domElement.addEventListener('wheel', this.onWheel);\n      this.domElement.addEventListener('pointerdown', this.onPointerDown);\n      this.domElement.addEventListener('pointercancel', this.onPointerCancel);\n      window.addEventListener('keydown', this.onKeyDown);\n      window.addEventListener('resize', this.onWindowResize);\n    });\n\n    _defineProperty(this, \"dispose\", () => {\n      if (this._animationId != -1) {\n        window.cancelAnimationFrame(this._animationId);\n      }\n\n      this.domElement.removeEventListener('pointerdown', this.onPointerDown);\n      this.domElement.removeEventListener('pointercancel', this.onPointerCancel);\n      this.domElement.removeEventListener('wheel', this.onWheel);\n      this.domElement.removeEventListener('contextmenu', this.onContextMenu);\n      window.removeEventListener('pointermove', this.onPointerMove);\n      window.removeEventListener('pointerup', this.onPointerUp);\n      window.removeEventListener('resize', this.onWindowResize);\n      window.removeEventListener('keydown', this.onKeyDown);\n      if (this.scene) this.scene.remove(this._gizmos);\n      this.disposeGrid();\n    });\n\n    _defineProperty(this, \"disposeGrid\", () => {\n      if (this._grid != null && this.scene != null) {\n        this.scene.remove(this._grid);\n        this._grid = null;\n      }\n    });\n\n    _defineProperty(this, \"easeOutCubic\", t => {\n      return 1 - Math.pow(1 - t, 3);\n    });\n\n    _defineProperty(this, \"activateGizmos\", isActive => {\n      const gizmoX = this._gizmos.children[0];\n      const gizmoY = this._gizmos.children[1];\n      const gizmoZ = this._gizmos.children[2];\n\n      if (isActive) {\n        gizmoX.material.setValues({\n          opacity: 1\n        });\n        gizmoY.material.setValues({\n          opacity: 1\n        });\n        gizmoZ.material.setValues({\n          opacity: 1\n        });\n      } else {\n        gizmoX.material.setValues({\n          opacity: 0.6\n        });\n        gizmoY.material.setValues({\n          opacity: 0.6\n        });\n        gizmoZ.material.setValues({\n          opacity: 0.6\n        });\n      }\n    });\n\n    _defineProperty(this, \"getCursorNDC\", (cursorX, cursorY, canvas) => {\n      const canvasRect = canvas.getBoundingClientRect();\n\n      this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n\n      this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n\n      return this._v2_1.clone();\n    });\n\n    _defineProperty(this, \"getCursorPosition\", (cursorX, cursorY, canvas) => {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n      this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;\n      this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;\n      return this._v2_1.clone();\n    });\n\n    _defineProperty(this, \"setCamera\", camera => {\n      camera.lookAt(this.target);\n      camera.updateMatrix(); //setting state\n\n      if (camera.type == 'PerspectiveCamera') {\n        this._fov0 = camera.fov;\n        this._fovState = camera.fov;\n      }\n\n      this._cameraMatrixState0.copy(camera.matrix);\n\n      this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n      this._cameraProjectionState.copy(camera.projectionMatrix);\n\n      this._zoom0 = camera.zoom;\n      this._zoomState = this._zoom0;\n      this._initialNear = camera.near;\n      this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\n      this._nearPos = this._initialNear;\n      this._initialFar = camera.far;\n      this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\n      this._farPos = this._initialFar;\n\n      this._up0.copy(camera.up);\n\n      this._upState.copy(camera.up);\n\n      this.camera = camera;\n      this.camera.updateProjectionMatrix(); //making gizmos\n\n      this._tbRadius = this.calculateTbRadius(camera);\n      this.makeGizmos(this.target, this._tbRadius);\n    });\n\n    _defineProperty(this, \"makeGizmos\", (tbCenter, tbRadius) => {\n      const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n      const points = curve.getPoints(this._curvePts); //geometry\n\n      const curveGeometry = new BufferGeometry().setFromPoints(points); //material\n\n      const curveMaterialX = new LineBasicMaterial({\n        color: 0xff8080,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialY = new LineBasicMaterial({\n        color: 0x80ff80,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialZ = new LineBasicMaterial({\n        color: 0x8080ff,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      }); //line\n\n      const gizmoX = new Line(curveGeometry, curveMaterialX);\n      const gizmoY = new Line(curveGeometry, curveMaterialY);\n      const gizmoZ = new Line(curveGeometry, curveMaterialZ);\n      const rotation = Math.PI * 0.5;\n      gizmoX.rotation.x = rotation;\n      gizmoY.rotation.y = rotation; //setting state\n\n      this._gizmoMatrixState0.identity().setPosition(tbCenter);\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n      if (this.camera.zoom != 1) {\n        //adapt gizmos size to camera zoom\n        const size = 1 / this.camera.zoom;\n\n        this._scaleMatrix.makeScale(size, size, size);\n\n        this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n\n        this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\n\n        this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\n      }\n\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.clear();\n\n      this._gizmos.add(gizmoX);\n\n      this._gizmos.add(gizmoY);\n\n      this._gizmos.add(gizmoZ);\n    });\n\n    _defineProperty(this, \"onFocusAnim\", (time, point, cameraMatrix, gizmoMatrix) => {\n      if (this._timeStart == -1) {\n        //animation start\n        this._timeStart = time;\n      }\n\n      if (this._state == STATE.ANIMATION_FOCUS) {\n        const deltaTime = time - this._timeStart;\n        const animTime = deltaTime / this.focusAnimationTime;\n\n        this._gizmoMatrixState.copy(gizmoMatrix);\n\n        if (animTime >= 1) {\n          //animation end\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n          this.focus(point, this.scaleFactor);\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        } else {\n          const amount = this.easeOutCubic(animTime);\n          const size = 1 - amount + this.scaleFactor * amount;\n\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n          this.focus(point, size, amount);\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n          });\n        }\n      } else {\n        //interrupt animation\n        this._animationId = -1;\n        this._timeStart = -1;\n      }\n    });\n\n    _defineProperty(this, \"onRotationAnim\", (time, rotationAxis, w0) => {\n      if (this._timeStart == -1) {\n        //animation start\n        this._anglePrev = 0;\n        this._angleCurrent = 0;\n        this._timeStart = time;\n      }\n\n      if (this._state == STATE.ANIMATION_ROTATE) {\n        //w = w0 + alpha * t\n        const deltaTime = (time - this._timeStart) / 1000;\n        const w = w0 + -this.dampingFactor * deltaTime;\n\n        if (w > 0) {\n          //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n          this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n          this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onRotationAnim(t, rotationAxis, w0);\n          });\n        } else {\n          this._animationId = -1;\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        //interrupt animation\n        this._animationId = -1;\n        this._timeStart = -1;\n\n        if (this._state != STATE.ROTATE) {\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n    });\n\n    _defineProperty(this, \"pan\", (p0, p1, adjust = false) => {\n      const movement = p0.clone().sub(p1);\n\n      if (this.camera.isOrthographicCamera) {\n        //adjust movement amount\n        movement.multiplyScalar(1 / this.camera.zoom);\n      } else if (this.camera.isPerspectiveCamera && adjust) {\n        //adjust movement amount\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState0); //camera's initial position\n\n\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0); //gizmo's initial position\n\n\n        const distanceFactor = this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position);\n        movement.multiplyScalar(1 / distanceFactor);\n      }\n\n      this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion);\n\n      this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z);\n\n      this.setTransformationMatrices(this._m4_1, this._m4_1);\n      return _transformation;\n    });\n\n    _defineProperty(this, \"reset\", () => {\n      this.camera.zoom = this._zoom0;\n\n      if (this.camera.isPerspectiveCamera) {\n        this.camera.fov = this._fov0;\n      }\n\n      this.camera.near = this._nearPos;\n      this.camera.far = this._farPos;\n\n      this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n      this.camera.up.copy(this._up0);\n      this.camera.updateMatrix();\n      this.camera.updateProjectionMatrix();\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n      this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.updateMatrix();\n\n      this._tbRadius = this.calculateTbRadius(this.camera);\n      this.makeGizmos(this._gizmos.position, this._tbRadius);\n      this.camera.lookAt(this._gizmos.position);\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_changeEvent);\n    });\n\n    _defineProperty(this, \"rotate\", (axis, angle) => {\n      const point = this._gizmos.position; //rotation center\n\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n      this._rotationMatrix.makeRotationAxis(axis, -angle); //rotate camera\n\n\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n      this._m4_1.multiply(this._rotationMatrix);\n\n      this._m4_1.multiply(this._translationMatrix);\n\n      this.setTransformationMatrices(this._m4_1);\n      return _transformation;\n    });\n\n    _defineProperty(this, \"copyState\", () => {\n      let state;\n\n      if (this.camera.isOrthographicCamera) {\n        state = JSON.stringify({\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        });\n      } else if (this.camera.isPerspectiveCamera) {\n        state = JSON.stringify({\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraFov: this.camera.fov,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        });\n      }\n\n      navigator.clipboard.writeText(state);\n    });\n\n    _defineProperty(this, \"pasteState\", () => {\n      const self = this;\n      navigator.clipboard.readText().then(function resolved(value) {\n        self.setStateFromJSON(value);\n      });\n    });\n\n    _defineProperty(this, \"saveState\", () => {\n      this._cameraMatrixState0.copy(this.camera.matrix);\n\n      this._gizmoMatrixState0.copy(this._gizmos.matrix);\n\n      this._nearPos = this.camera.near;\n      this._farPos = this.camera.far;\n      this._zoom0 = this.camera.zoom;\n\n      this._up0.copy(this.camera.up);\n\n      if (this.camera.isPerspectiveCamera) {\n        this._fov0 = this.camera.fov;\n      }\n    });\n\n    _defineProperty(this, \"applyScale\", (size, point, scaleGizmos = true) => {\n      const scalePoint = point.clone();\n      let sizeInverse = 1 / size;\n\n      if (this.camera.isOrthographicCamera) {\n        //camera zoom\n        this.camera.zoom = this._zoomState;\n        this.camera.zoom *= size; //check min and max zoom\n\n        if (this.camera.zoom > this.maxZoom) {\n          this.camera.zoom = this.maxZoom;\n          sizeInverse = this._zoomState / this.maxZoom;\n        } else if (this.camera.zoom < this.minZoom) {\n          this.camera.zoom = this.minZoom;\n          sizeInverse = this._zoomState / this.minZoom;\n        }\n\n        this.camera.updateProjectionMatrix();\n\n        this._v3_1.setFromMatrixPosition(this._gizmoMatrixState); //gizmos position\n        //scale gizmos so they appear in the same spot having the same dimension\n\n\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n        this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z);\n\n        this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix);\n\n        this._m4_2.multiply(this._translationMatrix); //move camera and gizmos to obtain pinch effect\n\n\n        scalePoint.sub(this._v3_1);\n        const amount = scalePoint.clone().multiplyScalar(sizeInverse);\n        scalePoint.sub(amount);\n\n        this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);\n\n        this._m4_2.premultiply(this._m4_1);\n\n        this.setTransformationMatrices(this._m4_1, this._m4_2);\n        return _transformation;\n      } else if (this.camera.isPerspectiveCamera) {\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState); //move camera\n\n\n        let distance = this._v3_1.distanceTo(scalePoint);\n\n        let amount = distance - distance * sizeInverse; //check min and max distance\n\n        const newDistance = distance - amount;\n\n        if (newDistance < this.minDistance) {\n          sizeInverse = this.minDistance / distance;\n          amount = distance - distance * sizeInverse;\n        } else if (newDistance > this.maxDistance) {\n          sizeInverse = this.maxDistance / distance;\n          amount = distance - distance * sizeInverse;\n        }\n\n        let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount);\n\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n\n        if (scaleGizmos) {\n          //scale gizmos so they appear in the same spot having the same dimension\n          const pos = this._v3_2;\n          distance = pos.distanceTo(scalePoint);\n          amount = distance - distance * sizeInverse;\n          direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount);\n\n          this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n\n          this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n          this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix);\n\n          this._m4_2.multiply(this._scaleMatrix);\n\n          this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n\n          this._m4_2.multiply(this._translationMatrix);\n\n          this.setTransformationMatrices(this._m4_1, this._m4_2);\n        } else {\n          this.setTransformationMatrices(this._m4_1);\n        }\n\n        return _transformation;\n      }\n    });\n\n    _defineProperty(this, \"setFov\", value => {\n      if (this.camera.isPerspectiveCamera) {\n        this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\n        this.camera.updateProjectionMatrix();\n      }\n    });\n\n    _defineProperty(this, \"zRotate\", (point, angle) => {\n      this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\n\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n      this._m4_1.multiply(this._rotationMatrix);\n\n      this._m4_1.multiply(this._translationMatrix);\n\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point); //vector from rotation center to gizmos position\n\n\n      this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle); //apply rotation\n\n\n      this._v3_2.sub(this._v3_1);\n\n      this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\n\n      this.setTransformationMatrices(this._m4_1, this._m4_2);\n      return _transformation;\n    });\n\n    _defineProperty(this, \"unprojectOnObj\", (cursor, camera) => {\n      const raycaster = new Raycaster();\n      raycaster.near = camera.near;\n      raycaster.far = camera.far;\n      raycaster.setFromCamera(cursor, camera);\n      const intersect = raycaster.intersectObjects(this.scene.children, true);\n\n      for (let i = 0; i < intersect.length; i++) {\n        if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face != null) {\n          return intersect[i].point.clone();\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"unprojectOnTbSurface\", (camera, cursorX, cursorY, canvas, tbRadius) => {\n      if (camera.type == 'OrthographicCamera') {\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n\n        const x2 = Math.pow(this._v2_1.x, 2);\n        const y2 = Math.pow(this._v2_1.y, 2);\n        const r2 = Math.pow(this._tbRadius, 2);\n\n        if (x2 + y2 <= r2 * 0.5) {\n          //intersection with sphere\n          this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n        } else {\n          //intersection with hyperboloid\n          this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n        }\n\n        return this._v3_1;\n      } else if (camera.type == 'PerspectiveCamera') {\n        //unproject cursor on the near plane\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n        const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\n        const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n        const radius2 = Math.pow(tbRadius, 2); //\t  camera\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\th\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t_ _ | _ _ _\\ _ _  near plane\n        //\t\t\tl\n\n        const h = this._v3_1.z;\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n\n        if (l == 0) {\n          //ray aligned with camera\n          rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\n          return rayDir;\n        }\n\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        /*\n         * calculate intersection point between unprojected ray and trackball surface\n         *|y = m * x + q\n         *|x^2 + y^2 = r^2\n         *\n         * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n         */\n\n        let a = Math.pow(m, 2) + 1;\n        let b = 2 * m * q;\n        let c = Math.pow(q, 2) - radius2;\n        let delta = Math.pow(b, 2) - 4 * a * c;\n\n        if (delta >= 0) {\n          //intersection with sphere\n          this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n          this._v2_1.setY(m * this._v2_1.x + q);\n\n          const angle = MathUtils.RAD2DEG * this._v2_1.angle();\n\n          if (angle >= 45) {\n            //if angle between intersection point and X' axis is >= 45, return that point\n            //otherwise, calculate intersection point with hyperboloid\n            const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n            rayDir.multiplyScalar(rayLength);\n            rayDir.z += cameraGizmoDistance;\n            return rayDir;\n          }\n        } //intersection with hyperboloid\n\n        /*\n         *|y = m * x + q\n         *|y = (1 / x) * (r^2 / 2)\n         *\n         * m * x^2 + q * x - r^2 / 2 = 0\n         */\n\n\n        a = m;\n        b = q;\n        c = -radius2 * 0.5;\n        delta = Math.pow(b, 2) - 4 * a * c;\n\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n        this._v2_1.setY(m * this._v2_1.x + q);\n\n        const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z += cameraGizmoDistance;\n        return rayDir;\n      }\n    });\n\n    _defineProperty(this, \"unprojectOnTbPlane\", (camera, cursorX, cursorY, canvas, initialDistance = false) => {\n      if (camera.type == 'OrthographicCamera') {\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n\n        return this._v3_1.clone();\n      } else if (camera.type == 'PerspectiveCamera') {\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas)); //unproject cursor on the near plane\n\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n        const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n        //\t  camera\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\th\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t_ _ | _ _ _\\ _ _  near plane\n        //\t\t\tl\n\n\n        const h = this._v3_1.z;\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n        let cameraGizmoDistance;\n\n        if (initialDistance) {\n          cameraGizmoDistance = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0));\n        } else {\n          cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n        }\n        /*\n         * calculate intersection point between unprojected ray and the plane\n         *|y = mx + q\n         *|y = 0\n         *\n         * x = -q/m\n         */\n\n\n        if (l == 0) {\n          //ray aligned with camera\n          rayDir.set(0, 0, 0);\n          return rayDir;\n        }\n\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        const x = -q / m;\n        const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z = 0;\n        return rayDir;\n      }\n    });\n\n    _defineProperty(this, \"updateMatrixState\", () => {\n      //update camera and gizmos state\n      this._cameraMatrixState.copy(this.camera.matrix);\n\n      this._gizmoMatrixState.copy(this._gizmos.matrix);\n\n      if (this.camera.isOrthographicCamera) {\n        this._cameraProjectionState.copy(this.camera.projectionMatrix);\n\n        this.camera.updateProjectionMatrix();\n        this._zoomState = this.camera.zoom;\n      } else if (this.camera.isPerspectiveCamera) {\n        this._fovState = this.camera.fov;\n      }\n    });\n\n    _defineProperty(this, \"updateTbState\", (newState, updateMatrices) => {\n      this._state = newState;\n\n      if (updateMatrices) {\n        this.updateMatrixState();\n      }\n    });\n\n    _defineProperty(this, \"update\", () => {\n      const EPS = 0.000001; // Update target and gizmos state\n\n      if (!this.target.equals(this._currentTarget)) {\n        this._gizmos.position.set(this.target.x, this.target.y, this.target.z); //for correct radius calculation\n\n\n        this._tbRadius = this.calculateTbRadius(this.camera);\n        this.makeGizmos(this.target, this._tbRadius);\n\n        this._currentTarget.copy(this.target);\n      } //check min/max parameters\n\n\n      if (this.camera.isOrthographicCamera) {\n        //check zoom\n        if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n          const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);\n          this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true));\n        }\n      } else if (this.camera.isPerspectiveCamera) {\n        //check distance\n        const distance = this.camera.position.distanceTo(this._gizmos.position);\n\n        if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n          const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\n          this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position));\n          this.updateMatrixState();\n        } //check fov\n\n\n        if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n          this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);\n          this.camera.updateProjectionMatrix();\n        }\n\n        const oldRadius = this._tbRadius;\n        this._tbRadius = this.calculateTbRadius(this.camera);\n\n        if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n          const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n          const newRadius = this._tbRadius / scale;\n          const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n          const points = curve.getPoints(this._curvePts);\n          const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n          for (const gizmo in this._gizmos.children) {\n            this._gizmos.children[gizmo].geometry = curveGeometry;\n          }\n        }\n      }\n\n      this.camera.lookAt(this._gizmos.position);\n    });\n\n    _defineProperty(this, \"setStateFromJSON\", json => {\n      const state = JSON.parse(json);\n\n      if (state.arcballState != undefined) {\n        this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n        this.camera.up.copy(state.arcballState.cameraUp);\n        this.camera.near = state.arcballState.cameraNear;\n        this.camera.far = state.arcballState.cameraFar;\n        this.camera.zoom = state.arcballState.cameraZoom;\n\n        if (this.camera.isPerspectiveCamera) {\n          this.camera.fov = state.arcballState.cameraFov;\n        }\n\n        this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n        this.camera.updateMatrix();\n        this.camera.updateProjectionMatrix();\n\n        this._gizmos.updateMatrix();\n\n        this._tbRadius = this.calculateTbRadius(this.camera);\n        const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\n\n        this._gizmoMatrixState0.copy(gizmoTmp);\n\n        this.camera.lookAt(this._gizmos.position);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    this.camera = null;\n    this.scene = scene;\n    this.mouseActions = [];\n    this._mouseOp = null; //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\n    this._v2_1 = new Vector2();\n    this._v3_1 = new Vector3();\n    this._v3_2 = new Vector3();\n    this._m4_1 = new Matrix4();\n    this._m4_2 = new Matrix4();\n    this._quat = new Quaternion(); //transformation matrices\n\n    this._translationMatrix = new Matrix4(); //matrix for translation operation\n\n    this._rotationMatrix = new Matrix4(); //matrix for rotation operation\n\n    this._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n    this._rotationAxis = new Vector3(); //axis for rotate operation\n    //camera state\n\n    this._cameraMatrixState = new Matrix4();\n    this._cameraProjectionState = new Matrix4();\n    this._fovState = 1;\n    this._upState = new Vector3();\n    this._zoomState = 1;\n    this._nearPos = 0;\n    this._farPos = 0;\n    this._gizmoMatrixState = new Matrix4(); //initial values\n\n    this._up0 = new Vector3();\n    this._zoom0 = 1;\n    this._fov0 = 0;\n    this._initialNear = 0;\n    this._nearPos0 = 0;\n    this._initialFar = 0;\n    this._farPos0 = 0;\n    this._cameraMatrixState0 = new Matrix4();\n    this._gizmoMatrixState0 = new Matrix4(); //pointers array\n\n    this._button = -1;\n    this._touchStart = [];\n    this._touchCurrent = [];\n    this._input = INPUT.NONE; //two fingers touch interaction\n\n    this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released\n\n    this._startFingerDistance = 0; //distance between two fingers\n\n    this._currentFingerDistance = 0;\n    this._startFingerRotation = 0; //amount of rotation performed with two fingers\n\n    this._currentFingerRotation = 0; //double tap\n\n    this._devPxRatio = 0;\n    this._downValid = true;\n    this._nclicks = 0;\n    this._downEvents = [];\n    this._downStart = 0; //pointerDown time\n\n    this._clickStart = 0; //first click time\n\n    this._maxDownTime = 250;\n    this._maxInterval = 300;\n    this._posThreshold = 24;\n    this._movementThreshold = 24; //cursor positions\n\n    this._currentCursorPosition = new Vector3();\n    this._startCursorPosition = new Vector3(); //grid\n\n    this._grid = null; //grid to be visualized during pan operation\n\n    this._gridPosition = new Vector3(); //gizmos\n\n    this._gizmos = new Group();\n    this._curvePts = 128; //animations\n\n    this._timeStart = -1; //initial time\n\n    this._animationId = -1; //focus animation\n\n    this.focusAnimationTime = 500; //duration of focus animation in ms\n    //rotate animation\n\n    this._timePrev = 0; //time at which previous rotate operation has been detected\n\n    this._timeCurrent = 0; //time at which current rotate operation has been detected\n\n    this._anglePrev = 0; //angle of previous rotation\n\n    this._angleCurrent = 0; //angle of current rotation\n\n    this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected\n\n    this._cursorPosCurr = new Vector3(); //cursor position when current rotate operation has been detected\n\n    this._wPrev = 0; //angular velocity of the previous rotate operation\n\n    this._wCurr = 0; //angular velocity of the current rotate operation\n    //parameters\n\n    this.adjustNearFar = false;\n    this.scaleFactor = 1.1; //zoom/distance multiplier\n\n    this.dampingFactor = 25;\n    this.wMax = 20; //maximum angular velocity allowed\n\n    this.enableAnimations = true; //if animations should be performed\n\n    this.enableGrid = false; //if grid should be showed during pan operation\n\n    this.cursorZoom = false; //if wheel zoom should be cursor centered\n\n    this.minFov = 5;\n    this.maxFov = 90;\n    this.enabled = true;\n    this.enablePan = true;\n    this.enableRotate = true;\n    this.enableZoom = true;\n    this.enableGizmos = true;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity; //trackball parameters\n\n    this.target = new Vector3(0, 0, 0);\n    this._currentTarget = new Vector3(0, 0, 0);\n    this._tbRadius = 1; //FSA\n\n    this._state = STATE.IDLE;\n    this.setCamera(_camera);\n\n    if (this.scene != null) {\n      this.scene.add(this._gizmos);\n    } // connect events\n\n\n    if (_domElement !== undefined) this.connect(_domElement);\n    this._devPxRatio = window.devicePixelRatio;\n    this.initializeMouseActions();\n  } //listeners\n\n\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  applyTransformMatrix(transformation) {\n    if (transformation.camera != null) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n      this.camera.updateMatrix(); //update camera up vector\n\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n      }\n    }\n\n    if (transformation.gizmos != null) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.updateMatrix();\n    }\n\n    if (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) {\n      this._tbRadius = this.calculateTbRadius(this.camera);\n\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n        const bb = new Box3();\n        bb.setFromObject(this._gizmos);\n        const sphere = new Sphere();\n        bb.getBoundingSphere(sphere);\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n        const regularNearPosition = cameraDistance - this._initialNear;\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n        this.camera.near = cameraDistance - minNearPos;\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n        const regularFarPosition = cameraDistance - this._initialFar;\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n        this.camera.far = cameraDistance - minFarPos;\n        this.camera.updateProjectionMatrix();\n      } else {\n        let update = false;\n\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear;\n          update = true;\n        }\n\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar;\n          update = true;\n        }\n\n        if (update) {\n          this.camera.updateProjectionMatrix();\n        }\n      }\n    }\n  }\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n\n\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n  setGizmosVisible(value) {\n    this._gizmos.visible = value;\n    this.dispatchEvent(_changeEvent);\n  }\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n\n\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n  setTransformationMatrices(camera = null, gizmos = null) {\n    if (camera != null) {\n      if (_transformation.camera != null) {\n        _transformation.camera.copy(camera);\n      } else {\n        _transformation.camera = camera.clone();\n      }\n    } else {\n      _transformation.camera = null;\n    }\n\n    if (gizmos != null) {\n      if (_transformation.gizmos != null) {\n        _transformation.gizmos.copy(gizmos);\n      } else {\n        _transformation.gizmos = gizmos.clone();\n      }\n    } else {\n      _transformation.gizmos = null;\n    }\n  }\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n\n\n}\n\nexport { ArcballControls };\n"]},"metadata":{},"sourceType":"module"}