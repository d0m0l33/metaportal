{"ast":null,"code":"import _regeneratorRuntime from\"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useState}from'react';import{getValidBadges,parseResponseForItems}from'./BadgeHelper';import{ChainId,useEthers}from'@usedapp/core';import{getTransactionsFor}from'./TransactionsAPI';import{BADGE_LIST,DEFAULT_BADGELIST}from'./Badges';export function useBadgeList(signerAddress,overrideChainId,tags){var _useEthers=useEthers(),account=_useEthers.account,chainId=_useEthers.chainId;var adjustedChainId=chainId===31337?ChainId.Mainnet:chainId;console.log('chainId : ',chainId);var _useState=useState(),_useState2=_slicedToArray(_useState,2),badges=_useState2[0],setBadges=_useState2[1];useEffect(function(){getTransactionsFor(signerAddress,adjustedChainId).then(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(response){var transactionItems,_badges,errorMessage;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!response){_context.next=6;break;}transactionItems=parseResponseForItems(response);console.log(transactionItems);if(transactionItems){_badges=getValidBadges(BADGE_LIST,transactionItems);_badges.push(DEFAULT_BADGELIST[0]);_badges.push(DEFAULT_BADGELIST[1]);setBadges(_badges);}else{// should do something with this case\n// in theory there should always be the defalt badge\n// if an account is connected\nsetBadges(undefined);}_context.next=8;break;case 6:errorMessage='Couldnt fetch transaction data';return _context.abrupt(\"return\",Promise.reject(new Error(errorMessage)));case 8:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}()).catch(function(err){console.log(err);setBadges(undefined);});},[account,chainId]);return badges;}","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/src/portalHooks/useBadgeList.ts"],"names":["useEffect","useState","getValidBadges","parseResponseForItems","ChainId","useEthers","getTransactionsFor","BADGE_LIST","DEFAULT_BADGELIST","useBadgeList","signerAddress","overrideChainId","tags","account","chainId","adjustedChainId","Mainnet","console","log","badges","setBadges","then","response","transactionItems","push","undefined","errorMessage","Promise","reject","Error","catch","err"],"mappings":"yeACA,OAASA,SAAT,CAAoBC,QAApB,KAAoC,OAApC,CACA,OAASC,cAAT,CAAyBC,qBAAzB,KAAsD,eAAtD,CACA,OAASC,OAAT,CAAkBC,SAAlB,KAAmC,eAAnC,CACA,OAASC,kBAAT,KAAmC,mBAAnC,CAEA,OAASC,UAAT,CAAqBC,iBAArB,KAA8C,UAA9C,CAIA,MAAO,SAASC,CAAAA,YAAT,CAAsBC,aAAtB,CAA4DC,eAA5D,CAAuFC,IAAvF,CAAwG,CAC7G,eAA6BP,SAAS,EAAtC,CAAQQ,OAAR,YAAQA,OAAR,CAAiBC,OAAjB,YAAiBA,OAAjB,CACA,GAAMC,CAAAA,eAAe,CAAGD,OAAO,GAAK,KAAZ,CAAoBV,OAAO,CAACY,OAA5B,CAAsCF,OAA9D,CAEAG,OAAO,CAACC,GAAR,CAAY,YAAZ,CAAyBJ,OAAzB,EACA,cAA4Bb,QAAQ,EAApC,wCAAOkB,MAAP,eAAeC,SAAf,eACApB,SAAS,CAAC,UAAM,CACdM,kBAAkB,CAACI,aAAD,CAAgBK,eAAhB,CAAlB,CACGM,IADH,0FACQ,iBAAOC,QAAP,gKACAA,QADA,yBAEMC,gBAFN,CAEyBpB,qBAAqB,CAACmB,QAAD,CAF9C,CAGAL,OAAO,CAACC,GAAR,CAAYK,gBAAZ,EACA,GAAGA,gBAAH,CAAqB,CACXJ,OADW,CACFjB,cAAc,CAACK,UAAD,CAAYgB,gBAAZ,CADZ,CAEjBJ,OAAM,CAACK,IAAP,CAAYhB,iBAAiB,CAAC,CAAD,CAA7B,EACAW,OAAM,CAACK,IAAP,CAAYhB,iBAAiB,CAAC,CAAD,CAA7B,EAEAY,SAAS,CAACD,OAAD,CAAT,CACH,CAND,IAMO,CACH;AACA;AACA;AACAC,SAAS,CAACK,SAAD,CAAT,CACH,CAfD,6BAiBIC,YAjBJ,CAiBmB,gCAjBnB,iCAkBKC,OAAO,CAACC,MAAR,CAAe,GAAIC,CAAAA,KAAJ,CAAUH,YAAV,CAAf,CAlBL,wDADR,gEAsBGI,KAtBH,CAsBS,SAACC,GAAD,CAAS,CACdd,OAAO,CAACC,GAAR,CAAYa,GAAZ,EACAX,SAAS,CAACK,SAAD,CAAT,CACD,CAzBH,EA0BD,CA3BQ,CA2BN,CAACZ,OAAD,CAASC,OAAT,CA3BM,CAAT,CA4BA,MAAOK,CAAAA,MAAP,CACD","sourcesContent":["import axios, { AxiosResponse } from 'axios'\nimport { useEffect, useState } from 'react'\nimport { getValidBadges, parseResponseForItems } from './BadgeHelper'\nimport { ChainId, useEthers } from '@usedapp/core'\nimport { getTransactionsFor } from './TransactionsAPI'\nimport { MetaBadge } from './BadgeHelperTypes'\nimport { BADGE_LIST, DEFAULT_BADGELIST } from './Badges'\n\n\n\nexport function useBadgeList(signerAddress: string|null|undefined, overrideChainId?: ChainId, tags?: string[]) {\n  const { account, chainId } = useEthers();\n  const adjustedChainId = chainId === 31337 ? ChainId.Mainnet : chainId;\n\n  console.log('chainId : ',chainId)\n  const [badges, setBadges] = useState<MetaBadge[]>()\n  useEffect(() => {\n    getTransactionsFor(signerAddress, adjustedChainId)\n      .then(async (response) => {\n        if (response) {\n            const transactionItems = parseResponseForItems(response);\n            console.log(transactionItems)\n            if(transactionItems) {\n                const badges = getValidBadges(BADGE_LIST,transactionItems);\n                badges.push(DEFAULT_BADGELIST[0]);\n                badges.push(DEFAULT_BADGELIST[1]);\n\n                setBadges(badges);\n            } else {\n                // should do something with this case\n                // in theory there should always be the defalt badge\n                // if an account is connected\n                setBadges(undefined);\n            }\n        } else {\n          const errorMessage = 'Couldnt fetch transaction data';\n          return Promise.reject(new Error(errorMessage))\n        }\n      })\n      .catch((err) => {\n        console.log(err)\n        setBadges(undefined)\n      })\n  }, [account,chainId])\n  return badges\n}\n"]},"metadata":{},"sourceType":"module"}