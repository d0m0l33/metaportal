{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, RGBFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\n\nclass GLTFExporter {\n  constructor() {\n    _defineProperty(this, \"pluginCallbacks\", void 0);\n\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(input, onDone, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options);\n  }\n  /**\n   * Static utility functions\n   */\n\n\n} //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\n_defineProperty(GLTFExporter, \"Utils\", {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n\n    const valueSize = track.getValueSize(); // @ts-expect-error\n\n    const times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\n\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    /**\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\n     */\n    // @ts-expect-error\n\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if ( // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        // @ts-expect-error\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n\n      let mergedTrack; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\n\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      } // @ts-expect-error\n\n\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n});\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546c67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n/**\n * Writer\n */\n\nclass GLTFWriter {\n  constructor() {\n    _defineProperty(this, \"plugins\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"pending\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"byteOffset\", void 0);\n\n    _defineProperty(this, \"nodeMap\", void 0);\n\n    _defineProperty(this, \"skins\", void 0);\n\n    _defineProperty(this, \"extensionsUsed\", void 0);\n\n    _defineProperty(this, \"uids\", void 0);\n\n    _defineProperty(this, \"uid\", void 0);\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"cache\", void 0);\n\n    _defineProperty(this, \"cachedCanvas\", void 0);\n\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.cachedCanvas = null;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n\n\n  write(input, onDone, options) {\n    this.options = Object.assign({}, {\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      truncateDrawRange: true,\n      embedImages: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n\n    if (this.options.animations !== undefined && this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n\n    this.processInput(input);\n    const writer = this;\n    Promise.all(this.pending).then(() => {\n      const buffers = writer.buffers;\n      const json = writer.json;\n      const options = writer.options;\n      const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n      const blob = new Blob(buffers, {\n        type: 'application/octet-stream'\n      }); // Declare extensions.\n\n      const extensionsUsedList = Object.keys(extensionsUsed);\n      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n      if (options.binary) {\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = () => {\n          if (reader.result !== null && typeof reader.result !== 'string') {\n            // Binary chunk.\n            const binaryChunk = this.getPaddedArrayBuffer(reader.result);\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\n            const headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            const glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n\n            glbReader.onloadend = function () {\n              if (glbReader.result !== null && typeof glbReader.result !== 'string') {\n                onDone(glbReader.result);\n              }\n            };\n          }\n        };\n      } else {\n        if (json.buffers && json.buffers.length > 0) {\n          const reader = new window.FileReader();\n          reader.readAsDataURL(blob);\n\n          reader.onloadend = function () {\n            const base64data = reader.result;\n\n            if (json.buffers !== undefined && base64data !== null) {\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            }\n          };\n        } else {\n          onDone(json);\n        }\n      }\n    });\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n\n\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n\n        delete json.gltfExtensions;\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      if (error instanceof Error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n  }\n  /**\n   * Assign and return a temporal unique id for an object\n   * especially which doesn't have .uuid\n   * @param  {Object} object\n   * @return {Integer}\n   */\n\n\n  getUID(object) {\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n    return this.uids.get(object);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n\n\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n\n\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n\n\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n\n\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }]; // All buffers are merged before export.\n\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n\n\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n\n    const byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n        }\n\n        offset += componentSize;\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n\n\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(resolve => {\n      const reader = new window.FileReader();\n      reader.readAsArrayBuffer(blob);\n\n      reader.onloadend = () => {\n        if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\n          const buffer = this.getPaddedArrayBuffer(reader.result);\n          const bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        }\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n\n\n  processAccessor(attribute, geometry, start, count) {\n    const options = this.options;\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4'\n    };\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n    }\n\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n      const end = start + count;\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n      start = Math.max(start, geometry.drawRange.start);\n      count = Math.min(end, end2) - start;\n      if (count < 0) count = 0;\n    } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n    if (count === 0) return null;\n    const minMax = this.getMinMax(attribute, start, count);\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n\n    if (bufferViewTarget !== undefined) {\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      const accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n   * @param  {Boolean} flipY before writing out the image\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n\n\n  processImage(image, format, flipY) {\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n    if (!cache.images.has(image)) cache.images.set(image, {});\n    const cachedImages = cache.images.get(image);\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n    const key = mimeType + ':flipY/' + flipY.toString();\n    if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\n    if (!json.images) json.images = [];\n    const imageDef = {\n      mimeType: mimeType\n    };\n\n    if (options.embedImages && options.maxTextureSize !== undefined) {\n      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d');\n\n      if (flipY) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\n        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\n      }\n\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      } else {\n        if (format !== RGBAFormat && format !== RGBFormat) {\n          console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n\n        if (image instanceof ImageData) {\n          if (format === RGBAFormat) {\n            for (let i = 0; i < data.length; i += 4) {\n              data[i + 0] = image.data[i + 0];\n              data[i + 1] = image.data[i + 1];\n              data[i + 2] = image.data[i + 2];\n              data[i + 3] = image.data[i + 3];\n            }\n          } else {\n            for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\n              data[i + 0] = image.data[j + 0];\n              data[i + 1] = image.data[j + 1];\n              data[i + 2] = image.data[j + 2];\n              data[i + 3] = 255;\n            }\n          }\n        }\n\n        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      }\n\n      if (options.binary) {\n        pending.push(new Promise(function (resolve) {\n          canvas.toBlob(function (blob) {\n            if (blob !== null) {\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                imageDef.bufferView = bufferViewIndex; // @ts-expect-error\n\n                resolve();\n              });\n            }\n          }, mimeType);\n        }));\n      } else {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      }\n    } else if (image instanceof Image) {\n      imageDef.uri = image.src;\n    }\n\n    const index = json.images.push(imageDef) - 1;\n    if (cachedImages !== undefined) cachedImages[key] = index;\n    return index;\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n\n\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n\n\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY)\n    };\n    if (map.name) textureDef.name = map.name;\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n\n\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n\n    if (material instanceof ShaderMaterial && material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n\n    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    }\n\n    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\n      // pbrMetallicRoughness.baseColorFactor\n      const color = material.color.toArray().concat([material.opacity]);\n\n      if (!this.equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n    }\n\n    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\n      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\n        const metalRoughMapDef = {\n          index: this.processTexture(material.metalnessMap)\n        };\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      } else {\n        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n      }\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map)\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n      }\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      } // emissiveTexture\n\n\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap)\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    } // normalTexture\n\n\n    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap)\n      };\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    } // occlusionTexture\n\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1\n      };\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    } // alphaMode\n\n\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    } // doubleSided\n\n\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n\n\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode; // Use the correct mode\n\n    if (mesh instanceof LineSegments && mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh instanceof Line && mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh instanceof Points && mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n    }\n\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n\n    if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    } // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n\n\n    let modifiedAttribute = null;\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.substr(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n      modifiedAttribute = null;\n      const array = attribute.array;\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n\n      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\n\n      if (accessor) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n\n            continue;\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n\n          if (cache.attributes.has(this.getUID(attribute))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n            continue;\n          } // Clones attribute not to override\n\n\n          const relativeAttribute = attribute.clone();\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n            }\n          }\n\n          const accessor = this.processAccessor(relativeAttribute, geometry);\n\n          if (accessor != undefined) {\n            target[gltfAttributeName] = accessor;\n          }\n\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n        }\n\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n\n      meshDef.weights = weights;\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n\n      if (geometry instanceof Object3D || geometry instanceof Material) {\n        this.serializeUserData(geometry, primitive);\n      }\n\n      if (targets.length > 0) primitive.targets = targets;\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          // @ts-expect-error\n          cacheKey += `:${groups[i].start}:${groups[i].count}`;\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n\n        if (primitive.indices === null) delete primitive.indices;\n      }\n\n      const materialIndex = groups[i].materialIndex;\n\n      if (materialIndex !== undefined && Array.isArray(materials)) {\n        const targetMaterials = materials[materialIndex];\n\n        if (!Array.isArray(targetMaterials)) {\n          const material = this.processMaterial(targetMaterials);\n          if (material !== null) primitive.material = material;\n          primitives.push(primitive);\n        }\n      }\n    }\n\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n\n\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n\n    if (camera instanceof OrthographicCamera && isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else if (camera instanceof PerspectiveCamera) {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } // Question: Is saving \"type\" as name intentional?\n\n\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n\n\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      // @ts-expect-error\n\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n\n\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n\n    if (json.nodes !== undefined && object instanceof SkinnedMesh) {\n      const node = json.nodes[nodeMap.get(object)];\n      const skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      const rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      const joints = [];\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      const temporaryBoneInverse = new Matrix4();\n\n      for (let i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      const skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n\n\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n\n      if (!this.equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n\n      if (!this.equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n\n      if (!this.equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n\n      if (!this.isIdentityMatrix(object.matrix)) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n\n    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object instanceof Camera && object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n\n    if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\n\n    if (object.children.length > 0) {\n      const children = [];\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n\n        if (child.visible || !options.onlyVisible) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children;\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n\n\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n\n      if (child.visible || !options.onlyVisible) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n\n\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n\n    const objectsWithoutScene = [];\n\n    for (let i = 0; i < input.length; i++) {\n      const inputScene = input[i];\n\n      if (inputScene instanceof Scene) {\n        this.processScene(inputScene);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n\n    for (let i = 0; options.animations !== undefined && i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  } //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\n\n  equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every(function (element, index) {\n      return element === array2[index];\n    });\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\n\n  stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n\n    const array = new Uint8Array(new ArrayBuffer(text.length));\n\n    for (let i = 0, il = text.length; i < il; i++) {\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n\n    return array.buffer;\n  }\n\n  isIdentityMatrix(matrix) {\n    return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n\n  getMinMax(attribute, start, count) {\n    const output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          output.min[a] = Math.min(output.min[a], value);\n          output.max[a] = Math.max(output.max[a], value);\n        }\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   */\n\n\n  getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\n\n  getPaddedArrayBuffer(arrayBuffer) {\n    let paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\n\n    if (paddedLength !== arrayBuffer.byteLength) {\n      const array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n\n      if (paddingByte !== 0) {\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n\n      return array.buffer;\n    }\n\n    return arrayBuffer;\n  }\n\n}\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\n\nclass GLTFLightExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n\n    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error\n    !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n\n    if (light instanceof DirectionalLight && light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light instanceof PointLight && // @ts-expect-error\n    light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light instanceof SpotLight && light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n\n    if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n\n    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n\n    if (json.extensions !== undefined) {\n      const lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  writeMaterial(material, materialDef) {\n    // @ts-expect-error\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n\n    if (material instanceof MeshPhongMaterial) {\n      const specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = // @ts-expect-error\n      material.glossiness;\n    }\n\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap)\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || material.transmission === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap)\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || // @ts-expect-error\n    material.thickness === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thickness = // @ts-expect-error\n    material.thickness; // @ts-expect-error\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture( // @ts-expect-error\n        material.thicknessMap)\n      };\n      writer.applyTextureTransform(thicknessMapDef, // @ts-expect-error\n      material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n\n    extensionDef.attenuationDistance = //@ts-expect-error\n    material.attenuationDistance;\n    extensionDef.attenuationColor = //@ts-expect-error\n    material.attenuationTint.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n\nexport { GLTFExporter };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/exporters/GLTFExporter.js"],"names":["_defineProperty","PropertyBinding","InterpolateLinear","Vector3","RGBAFormat","RGBFormat","ShaderMaterial","MeshStandardMaterial","MeshBasicMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshToonMaterial","MeshLambertMaterial","DoubleSide","LineSegments","LineLoop","Line","Points","MeshDepthMaterial","InterleavedBufferAttribute","BufferAttribute","Object3D","Material","OrthographicCamera","PerspectiveCamera","MathUtils","InterpolateDiscrete","SkinnedMesh","Matrix4","Mesh","Camera","Scene","DirectionalLight","PointLight","SpotLight","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","GLTFExporter","constructor","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","callback","indexOf","push","unregister","splice","parse","input","onDone","options","GLTFWriter","plugins","i","il","length","setPlugins","write","insertKeyframe","track","time","tolerance","valueSize","getValueSize","times","TimeBufferType","values","ValueBufferType","interpolant","createInterpolant","index","Math","abs","set","evaluate","slice","mergeMorphTargetTracks","clip","root","tracks","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","parseTrackName","name","sourceTrackNode","findNode","nodeName","propertyName","propertyIndex","undefined","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","isInterpolantFactoryMethodGLTFCubicSpline","Error","console","warn","clone","setInterpolation","targetCount","morphTargetInfluences","targetIndex","morphTargetDictionary","mergedTrack","uuid","j","sourceInterpolant","keyframeIndex","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","cachedCanvas","Object","assign","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","Promise","all","then","blob","Blob","type","extensionsUsedList","keys","byteLength","size","reader","window","FileReader","readAsArrayBuffer","onloadend","result","binaryChunk","getPaddedArrayBuffer","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","stringToArrayBuffer","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","message","getUID","has","get","isNormalizedNormalAttribute","normal","v","count","fromBufferAttribute","createNormalizedNormalAttribute","attribute","x","y","z","setX","normalize","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","processBuffer","buffer","processBufferView","componentType","start","target","bufferViews","componentSize","getPaddedBufferSize","itemSize","dataView","a","value","array","getX","getY","getZ","getW","setFloat32","setUint16","setUint8","bufferViewDef","byteStride","output","id","processBufferViewImage","resolve","processAccessor","geometry","types","Float32Array","Uint32Array","Uint16Array","Uint8Array","end","end2","drawRange","max","min","minMax","getMinMax","bufferViewTarget","bufferView","accessorDef","normalized","accessors","processImage","image","format","flipY","cachedImages","mimeType","key","toString","imageDef","canvas","document","createElement","width","height","ctx","getContext","translate","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","drawImage","data","Uint8ClampedArray","ImageData","putImageData","toBlob","bufferViewIndex","toDataURL","Image","src","processSampler","map","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTexture","textureDef","sampler","source","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","equalArray","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","metalnessMap","roughnessMap","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","Array","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","substr","toUpperCase","validVertexAttributes","test","accessor","weights","targetNames","reverseDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","targetMaterials","writeMesh","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","Utils","channels","trackBinding","trackNode","trackProperty","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","interpolation","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","isIdentityMatrix","matrix","elements","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex","writeNode","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","inputScene","afterParse","func","array1","array2","every","element","text","TextEncoder","encode","charCodeAt","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","bufferSize","ceil","arrayBuffer","paddingByte","paddedLength","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","isMeshPhysicalMaterial","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","attenuationTint"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, RGBFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\n\nclass GLTFExporter {\n  constructor() {\n    _defineProperty(this, \"pluginCallbacks\", void 0);\n\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(input, onDone, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options);\n  }\n  /**\n   * Static utility functions\n   */\n\n\n} //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\n_defineProperty(GLTFExporter, \"Utils\", {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n\n    const valueSize = track.getValueSize(); // @ts-expect-error\n\n    const times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\n\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    /**\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\n     */\n    // @ts-expect-error\n\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if ( // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        // @ts-expect-error\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n\n      let mergedTrack; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\n\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      } // @ts-expect-error\n\n\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n});\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546c67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n/**\n * Writer\n */\n\nclass GLTFWriter {\n  constructor() {\n    _defineProperty(this, \"plugins\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"pending\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"byteOffset\", void 0);\n\n    _defineProperty(this, \"nodeMap\", void 0);\n\n    _defineProperty(this, \"skins\", void 0);\n\n    _defineProperty(this, \"extensionsUsed\", void 0);\n\n    _defineProperty(this, \"uids\", void 0);\n\n    _defineProperty(this, \"uid\", void 0);\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"cache\", void 0);\n\n    _defineProperty(this, \"cachedCanvas\", void 0);\n\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.cachedCanvas = null;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n\n\n  write(input, onDone, options) {\n    this.options = Object.assign({}, {\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      truncateDrawRange: true,\n      embedImages: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n\n    if (this.options.animations !== undefined && this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n\n    this.processInput(input);\n    const writer = this;\n    Promise.all(this.pending).then(() => {\n      const buffers = writer.buffers;\n      const json = writer.json;\n      const options = writer.options;\n      const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n      const blob = new Blob(buffers, {\n        type: 'application/octet-stream'\n      }); // Declare extensions.\n\n      const extensionsUsedList = Object.keys(extensionsUsed);\n      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n      if (options.binary) {\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = () => {\n          if (reader.result !== null && typeof reader.result !== 'string') {\n            // Binary chunk.\n            const binaryChunk = this.getPaddedArrayBuffer(reader.result);\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\n            const headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            const glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n\n            glbReader.onloadend = function () {\n              if (glbReader.result !== null && typeof glbReader.result !== 'string') {\n                onDone(glbReader.result);\n              }\n            };\n          }\n        };\n      } else {\n        if (json.buffers && json.buffers.length > 0) {\n          const reader = new window.FileReader();\n          reader.readAsDataURL(blob);\n\n          reader.onloadend = function () {\n            const base64data = reader.result;\n\n            if (json.buffers !== undefined && base64data !== null) {\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            }\n          };\n        } else {\n          onDone(json);\n        }\n      }\n    });\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n\n\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n\n        delete json.gltfExtensions;\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      if (error instanceof Error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n  }\n  /**\n   * Assign and return a temporal unique id for an object\n   * especially which doesn't have .uuid\n   * @param  {Object} object\n   * @return {Integer}\n   */\n\n\n  getUID(object) {\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n    return this.uids.get(object);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n\n\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n\n\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n\n\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n\n\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }]; // All buffers are merged before export.\n\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n\n\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n\n    const byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n        }\n\n        offset += componentSize;\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n\n\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(resolve => {\n      const reader = new window.FileReader();\n      reader.readAsArrayBuffer(blob);\n\n      reader.onloadend = () => {\n        if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\n          const buffer = this.getPaddedArrayBuffer(reader.result);\n          const bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        }\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n\n\n  processAccessor(attribute, geometry, start, count) {\n    const options = this.options;\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4'\n    };\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n    }\n\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n      const end = start + count;\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n      start = Math.max(start, geometry.drawRange.start);\n      count = Math.min(end, end2) - start;\n      if (count < 0) count = 0;\n    } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n    if (count === 0) return null;\n    const minMax = this.getMinMax(attribute, start, count);\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n\n    if (bufferViewTarget !== undefined) {\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      const accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n   * @param  {Boolean} flipY before writing out the image\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n\n\n  processImage(image, format, flipY) {\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n    if (!cache.images.has(image)) cache.images.set(image, {});\n    const cachedImages = cache.images.get(image);\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n    const key = mimeType + ':flipY/' + flipY.toString();\n    if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\n    if (!json.images) json.images = [];\n    const imageDef = {\n      mimeType: mimeType\n    };\n\n    if (options.embedImages && options.maxTextureSize !== undefined) {\n      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d');\n\n      if (flipY) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\n        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\n      }\n\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      } else {\n        if (format !== RGBAFormat && format !== RGBFormat) {\n          console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n\n        if (image instanceof ImageData) {\n          if (format === RGBAFormat) {\n            for (let i = 0; i < data.length; i += 4) {\n              data[i + 0] = image.data[i + 0];\n              data[i + 1] = image.data[i + 1];\n              data[i + 2] = image.data[i + 2];\n              data[i + 3] = image.data[i + 3];\n            }\n          } else {\n            for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\n              data[i + 0] = image.data[j + 0];\n              data[i + 1] = image.data[j + 1];\n              data[i + 2] = image.data[j + 2];\n              data[i + 3] = 255;\n            }\n          }\n        }\n\n        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      }\n\n      if (options.binary) {\n        pending.push(new Promise(function (resolve) {\n          canvas.toBlob(function (blob) {\n            if (blob !== null) {\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                imageDef.bufferView = bufferViewIndex; // @ts-expect-error\n\n                resolve();\n              });\n            }\n          }, mimeType);\n        }));\n      } else {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      }\n    } else if (image instanceof Image) {\n      imageDef.uri = image.src;\n    }\n\n    const index = json.images.push(imageDef) - 1;\n    if (cachedImages !== undefined) cachedImages[key] = index;\n    return index;\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n\n\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n\n\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY)\n    };\n    if (map.name) textureDef.name = map.name;\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n\n\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n\n    if (material instanceof ShaderMaterial && material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n\n    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    }\n\n    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\n      // pbrMetallicRoughness.baseColorFactor\n      const color = material.color.toArray().concat([material.opacity]);\n\n      if (!this.equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n    }\n\n    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\n      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\n        const metalRoughMapDef = {\n          index: this.processTexture(material.metalnessMap)\n        };\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      } else {\n        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n      }\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map)\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n      }\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      } // emissiveTexture\n\n\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap)\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    } // normalTexture\n\n\n    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap)\n      };\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    } // occlusionTexture\n\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1\n      };\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    } // alphaMode\n\n\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    } // doubleSided\n\n\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n\n\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode; // Use the correct mode\n\n    if (mesh instanceof LineSegments && mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh instanceof Line && mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh instanceof Points && mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n    }\n\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n\n    if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    } // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n\n\n    let modifiedAttribute = null;\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.substr(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n      modifiedAttribute = null;\n      const array = attribute.array;\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n\n      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\n\n      if (accessor) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n\n            continue;\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n\n          if (cache.attributes.has(this.getUID(attribute))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n            continue;\n          } // Clones attribute not to override\n\n\n          const relativeAttribute = attribute.clone();\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n            }\n          }\n\n          const accessor = this.processAccessor(relativeAttribute, geometry);\n\n          if (accessor != undefined) {\n            target[gltfAttributeName] = accessor;\n          }\n\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n        }\n\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n\n      meshDef.weights = weights;\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n\n      if (geometry instanceof Object3D || geometry instanceof Material) {\n        this.serializeUserData(geometry, primitive);\n      }\n\n      if (targets.length > 0) primitive.targets = targets;\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          // @ts-expect-error\n          cacheKey += `:${groups[i].start}:${groups[i].count}`;\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n\n        if (primitive.indices === null) delete primitive.indices;\n      }\n\n      const materialIndex = groups[i].materialIndex;\n\n      if (materialIndex !== undefined && Array.isArray(materials)) {\n        const targetMaterials = materials[materialIndex];\n\n        if (!Array.isArray(targetMaterials)) {\n          const material = this.processMaterial(targetMaterials);\n          if (material !== null) primitive.material = material;\n          primitives.push(primitive);\n        }\n      }\n    }\n\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n\n\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n\n    if (camera instanceof OrthographicCamera && isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else if (camera instanceof PerspectiveCamera) {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } // Question: Is saving \"type\" as name intentional?\n\n\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n\n\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      // @ts-expect-error\n\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n\n\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n\n    if (json.nodes !== undefined && object instanceof SkinnedMesh) {\n      const node = json.nodes[nodeMap.get(object)];\n      const skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      const rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      const joints = [];\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      const temporaryBoneInverse = new Matrix4();\n\n      for (let i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      const skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n\n\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n\n      if (!this.equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n\n      if (!this.equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n\n      if (!this.equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n\n      if (!this.isIdentityMatrix(object.matrix)) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n\n    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object instanceof Camera && object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n\n    if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\n\n    if (object.children.length > 0) {\n      const children = [];\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n\n        if (child.visible || !options.onlyVisible) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children;\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n\n\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n\n      if (child.visible || !options.onlyVisible) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n\n\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n\n    const objectsWithoutScene = [];\n\n    for (let i = 0; i < input.length; i++) {\n      const inputScene = input[i];\n\n      if (inputScene instanceof Scene) {\n        this.processScene(inputScene);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n\n    for (let i = 0; options.animations !== undefined && i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  } //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\n\n  equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every(function (element, index) {\n      return element === array2[index];\n    });\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\n\n  stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n\n    const array = new Uint8Array(new ArrayBuffer(text.length));\n\n    for (let i = 0, il = text.length; i < il; i++) {\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n\n    return array.buffer;\n  }\n\n  isIdentityMatrix(matrix) {\n    return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n\n  getMinMax(attribute, start, count) {\n    const output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          output.min[a] = Math.min(output.min[a], value);\n          output.max[a] = Math.max(output.max[a], value);\n        }\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   */\n\n\n  getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\n\n  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\n\n    if (paddedLength !== arrayBuffer.byteLength) {\n      const array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n\n      if (paddingByte !== 0) {\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n\n      return array.buffer;\n    }\n\n    return arrayBuffer;\n  }\n\n}\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\n\nclass GLTFLightExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n\n    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error\n    !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n\n    if (light instanceof DirectionalLight && light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light instanceof PointLight && // @ts-expect-error\n    light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light instanceof SpotLight && light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n\n    if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n\n    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n\n    if (json.extensions !== undefined) {\n      const lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  writeMaterial(material, materialDef) {\n    // @ts-expect-error\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n\n    if (material instanceof MeshPhongMaterial) {\n      const specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = // @ts-expect-error\n      material.glossiness;\n    }\n\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap)\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || material.transmission === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap)\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || // @ts-expect-error\n    material.thickness === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thickness = // @ts-expect-error\n    material.thickness; // @ts-expect-error\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture( // @ts-expect-error\n        material.thicknessMap)\n      };\n      writer.applyTextureTransform(thicknessMapDef, // @ts-expect-error\n      material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n\n    extensionDef.attenuationDistance = //@ts-expect-error\n    material.attenuationDistance;\n    extensionDef.attenuationColor = //@ts-expect-error\n    material.attenuationTint.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n\nexport { GLTFExporter };\n"]},"metadata":{},"sourceType":"module"}