{"ast":null,"code":"import { TransactionLevel, CriteriaComparions } from \"./BadgeHelperTypes\";\nexport const parseResponseForItems = response => {\n  if (!response || !response.data || !response.data.data) {\n    return null;\n  }\n\n  return response.data.data.items;\n};\nexport const RANDOM_VISOR_COLORS = ['black', 'white', 'grey', '#3f9468', //light green\n'#5093aa', //light blue\n'#9550aa', //light purple\n'#e74f71', //light pink\n'silver', '#271f1f', //brown\n'gold'];\nexport const calculateFrequencyForKeyValueMatches = (transactions, key, value, valueMatching) => {\n  if (valueMatching) {\n    // matches if 'key' found && key maps to 'value'\n    return getKeyValueMatchCount(transactions, key, value);\n  } else {\n    // matches if 'key' found\n    return getKeyMatchCount(transactions, key);\n  }\n};\nexport const getKeyValueMatchCount = (items, key, value) => {\n  let count = 0;\n  items.forEach(item => {\n    if (item[key] && item[key] === value) {\n      count++;\n    }\n  });\n  return count;\n};\nexport const getKeyMatchCount = (items, key) => {\n  let count = 0;\n  items.forEach(item => {\n    if (item[key]) {\n      count++;\n    }\n  });\n  return count;\n};\nexport const getValidBadges = (badges, transactions) => {\n  let validBadges = [];\n  badges.forEach(badge => {\n    if (validateBadgeAgainstTransactions(badge, transactions)) {\n      validBadges.push(badge);\n    }\n  });\n  return validBadges;\n};\nexport const validateBadgeAgainstTransactions = (badge, transactions) => {\n  let isValid = false;\n\n  switch (badge.parseRules.level) {\n    case TransactionLevel.Root:\n      // compare rules with trnsaction list\n      isValid = executeRootLevelChecksForBadge(badge.parseRules, transactions);\n      return isValid;\n\n    default:\n      return false;\n  }\n};\nexport const executeRootLevelChecksForBadge = (rules, transactions) => {\n  // defaulting to Key Match frequency comparisons\n  return executeFrequencyRuleForBadge(rules.keyValueObject.name, rules.keyValueObject.value, rules.criteria.comparison, rules.criteria.value, rules.useKeyValueMatching, transactions);\n};\nexport const executeFrequencyRuleForBadge = (key, value, criteriaRule, criteriaValue, isValueMathing, transactions) => {\n  // defaulting to Key Match frequency comparisons\n  let isValid = false;\n  const frequency = calculateFrequencyForKeyValueMatches(transactions, key, value, isValueMathing);\n\n  switch (criteriaRule) {\n    case CriteriaComparions.GT:\n      return frequency > criteriaValue;\n\n    case CriteriaComparions.LT:\n      return frequency < criteriaValue;\n\n    default:\n      return false;\n  }\n};","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/src/portalHooks/BadgeHelper.ts"],"names":["TransactionLevel","CriteriaComparions","parseResponseForItems","response","data","items","RANDOM_VISOR_COLORS","calculateFrequencyForKeyValueMatches","transactions","key","value","valueMatching","getKeyValueMatchCount","getKeyMatchCount","count","forEach","item","getValidBadges","badges","validBadges","badge","validateBadgeAgainstTransactions","push","isValid","parseRules","level","Root","executeRootLevelChecksForBadge","rules","executeFrequencyRuleForBadge","keyValueObject","name","criteria","comparison","useKeyValueMatching","criteriaRule","criteriaValue","isValueMathing","frequency","GT","LT"],"mappings":"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","sourcesContent":["import { AxiosResponse } from \"axios\";\nimport { TransactionLevel, ParseParams, CriteriaComparions, MetaBadge } from \"./BadgeHelperTypes\";\n\n\nexport const parseResponseForItems =(response: AxiosResponse): (any[]|null) => {\n    if(!response || !response.data || !response.data.data) {\n      return null;\n    }\n    return response.data.data.items;\n}\n  \n  export const RANDOM_VISOR_COLORS = [\n    'black',\n    'white',\n    'grey',\n    '#3f9468',//light green\n    '#5093aa',//light blue\n    '#9550aa',//light purple\n    '#e74f71',//light pink\n    'silver',\n    '#271f1f',//brown\n    'gold'\n  ]\n  \n  export const calculateFrequencyForKeyValueMatches =(\n    transactions: any[], \n    key: string, \n    value: number, \n    valueMatching: boolean\n    ) : number => {\n      if(valueMatching) {\n        // matches if 'key' found && key maps to 'value'\n        return getKeyValueMatchCount(transactions, key, value);\n      } else {\n          // matches if 'key' found\n          return getKeyMatchCount(transactions, key);\n      }\n  }\n\n  export const getKeyValueMatchCount = (items: any[], key: string, value: any) =>  {\n      let count = 0;\n      items.forEach((item) => {\n        if(item[key] && item[key] === value) {\n          count++;\n        }\n      });\n      return count;\n  }\n\n  export const getKeyMatchCount = (items: any[], key: string) =>  {\n    let count = 0;\n    items.forEach((item) => {\n      if(item[key]) {\n        count++;\n      }\n    });\n    return count;\n}\n\n\nexport const getValidBadges = (badges: MetaBadge[], transactions: any[]) : MetaBadge[] =>  {\n  let validBadges: MetaBadge[] = [];\n  badges.forEach((badge: MetaBadge) => {\n    if(validateBadgeAgainstTransactions(badge,transactions)){\n      validBadges.push(badge);\n    }\n  });\n  return validBadges;\n}\n\n\nexport const validateBadgeAgainstTransactions = (badge: MetaBadge, transactions: any[]): boolean =>  {\n  let isValid = false;\n  switch(badge.parseRules.level) {\n    case TransactionLevel.Root :\n        // compare rules with trnsaction list\n        isValid = executeRootLevelChecksForBadge(badge.parseRules,transactions);\n      return isValid;\n    default:\n      return false;\n  }\n}\n\n\nexport const executeRootLevelChecksForBadge = (rules: ParseParams, transactions: any[]): boolean =>  {\n  // defaulting to Key Match frequency comparisons\n  return executeFrequencyRuleForBadge(\n    rules.keyValueObject.name, \n    rules.keyValueObject.value,\n    rules.criteria.comparison,\n    rules.criteria.value,\n    rules.useKeyValueMatching,\n    transactions\n    );\n}\n\n\nexport const executeFrequencyRuleForBadge = (\n  key: string, \n  value: any, \n  criteriaRule: CriteriaComparions,\n  criteriaValue: number,\n  isValueMathing: boolean,\n  transactions: any[], ): boolean =>  {\n  // defaulting to Key Match frequency comparisons\n  let isValid = false;\n  const frequency = calculateFrequencyForKeyValueMatches(transactions, key, value, isValueMathing);\n\n  switch(criteriaRule) {\n    case CriteriaComparions.GT : \n      return frequency > criteriaValue;\n\n    case CriteriaComparions.LT : \n      return frequency < criteriaValue;\n\n    default:\n      return false;\n  }\n}"]},"metadata":{},"sourceType":"module"}