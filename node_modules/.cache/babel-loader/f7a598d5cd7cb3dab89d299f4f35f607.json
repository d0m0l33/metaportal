{"ast":null,"code":"import _classCallCheck from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Plane, LinearFilter, RGBFormat } from 'three';\n\nvar ReflectorForSSRPass = /*#__PURE__*/function (_Mesh) {\n  _inherits(ReflectorForSSRPass, _Mesh);\n\n  var _super = _createSuper(ReflectorForSSRPass);\n\n  function ReflectorForSSRPass(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ReflectorForSSRPass);\n\n    _this = _super.call(this, geometry);\n    _this.type = 'ReflectorForSSRPass';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    var useDepthTexture = options.useDepthTexture === true;\n    var yAxis = new Vector3(0, 1, 0);\n    var vecTemp0 = new Vector3();\n    var vecTemp1 = new Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get: function get() {\n        return scope._distanceAttenuation;\n      },\n      set: function set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get: function get() {\n        return scope._fresnel;\n      },\n      set: function set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    var normal = new Vector3();\n    var reflectorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var view = new Vector3();\n    var target = new Vector3();\n    var textureMatrix = new Matrix4();\n    var virtualCamera = new PerspectiveCamera();\n    var depthTexture;\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n\n    var parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBFormat,\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    var material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture: useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n\n    _this.material = material;\n    var globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    var globalPlanes = [globalPlane];\n\n    _this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      var currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      var viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    return _this;\n  }\n\n  return ReflectorForSSRPass;\n}(Mesh);\n\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform sampler2D tDepth;\\n\\t\\tuniform float maxDistance;\\n\\t\\tuniform float opacity;\\n\\t\\tuniform float fresnelCoe;\\n\\t\\tuniform float virtualCameraNear;\\n\\t\\tuniform float virtualCameraFar;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrix;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrixInverse;\\n\\t\\tuniform mat4 virtualCameraMatrixWorld;\\n\\t\\tuniform vec2 resolution;\\n\\t\\tvarying vec4 vUv;\\n\\t\\t#include <packing>\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\t\\t}\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\t\\t}\\n\\t\\tfloat getDepth( const in vec2 uv ) {\\n\\t\\t\\treturn texture2D( tDepth, uv ).x;\\n\\t\\t}\\n\\t\\tfloat getViewZ( const in float depth ) {\\n\\t\\t\\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\\n\\t\\t}\\n\\t\\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\\n\\t\\t\\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\\n\\t\\t\\tclipPosition *= clipW; //clip\\n\\t\\t\\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\\n\\t\\t}\\n\\t\\tvoid main() {\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\t#ifdef useDepthTexture\\n\\t\\t\\t\\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\\n\\t\\t\\t\\tuv.x=1.-uv.x;\\n\\t\\t\\t\\tfloat depth = texture2DProj( tDepth, vUv ).r;\\n\\t\\t\\t\\tfloat viewZ = getViewZ( depth );\\n\\t\\t\\t\\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\\n\\t\\t\\t\\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\\n\\t\\t\\t\\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\\n\\t\\t\\t\\tif(worldPosition.y>maxDistance) discard;\\n\\t\\t\\t\\tfloat op=opacity;\\n\\t\\t\\t\\t#ifdef DISTANCE_ATTENUATION\\n\\t\\t\\t\\t\\tfloat ratio=1.-(worldPosition.y/maxDistance);\\n\\t\\t\\t\\t\\tfloat attenuation=ratio*ratio;\\n\\t\\t\\t\\t\\top=opacity*attenuation;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef FRESNEL\\n\\t\\t\\t\\t\\top*=fresnelCoe;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\"\n};\nexport { ReflectorForSSRPass };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"names":["Mesh","Color","Vector3","Vector2","Matrix4","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","WebGLRenderTarget","MathUtils","ShaderMaterial","UniformsUtils","Plane","LinearFilter","RGBFormat","ReflectorForSSRPass","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","resolution","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","Object","defineProperty","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","view","target","textureMatrix","virtualCamera","depthTexture","minFilter","magFilter","parameters","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","transparent","assign","clone","fragmentShader","vertexShader","globalPlane","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","encoding","outputEncoding","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","isReflectorForSSRPass","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"mappings":"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","sourcesContent":["import { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, MathUtils, ShaderMaterial, UniformsUtils, Plane, LinearFilter, RGBFormat } from 'three';\n\nclass ReflectorForSSRPass extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'ReflectorForSSRPass';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation;\n      },\n\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel;\n      },\n\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n\n    const parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBFormat,\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n\n}\n\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\nexport { ReflectorForSSRPass };\n"]},"metadata":{},"sourceType":"module"}