{"ast":null,"code":"import _classCallCheck from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, DoubleSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nvar ColladaLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(ColladaLoader, _Loader);\n\n  var _super = _createSuper(ColladaLoader);\n\n  function ColladaLoader(manager) {\n    _classCallCheck(this, ColladaLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(ColladaLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path) {\n      function getElementsByTagName(xml, name) {\n        // Non recursive xml.getElementsByTagName() ...\n        var array = [];\n        var childNodes = xml.childNodes;\n\n        for (var i = 0, l = childNodes.length; i < l; i++) {\n          var child = childNodes[i];\n\n          if (child.nodeName === name) {\n            array.push(child);\n          }\n        }\n\n        return array;\n      }\n\n      function parseStrings(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parts[i];\n        }\n\n        return array;\n      }\n\n      function parseFloats(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseFloat(parts[i]);\n        }\n\n        return array;\n      }\n\n      function parseInts(text) {\n        if (text.length === 0) return [];\n        var parts = text.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseInt(parts[i]);\n        }\n\n        return array;\n      }\n\n      function parseId(text) {\n        return text.substring(1);\n      }\n\n      function generateId() {\n        return 'three_default_' + count++;\n      }\n\n      function isEmpty(object) {\n        return Object.keys(object).length === 0;\n      } // asset\n\n\n      function parseAsset(xml) {\n        return {\n          unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n          upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n        };\n      }\n\n      function parseAssetUnit(xml) {\n        if (xml !== undefined && xml.hasAttribute('meter') === true) {\n          return parseFloat(xml.getAttribute('meter'));\n        } else {\n          return 1; // default 1 meter\n        }\n      }\n\n      function parseAssetUpAxis(xml) {\n        return xml !== undefined ? xml.textContent : 'Y_UP';\n      } // library\n\n\n      function parseLibrary(xml, libraryName, nodeName, parser) {\n        var library = getElementsByTagName(xml, libraryName)[0];\n\n        if (library !== undefined) {\n          var elements = getElementsByTagName(library, nodeName);\n\n          for (var i = 0; i < elements.length; i++) {\n            parser(elements[i]);\n          }\n        }\n      }\n\n      function buildLibrary(data, builder) {\n        for (var name in data) {\n          var object = data[name];\n          object.build = builder(data[name]);\n        }\n      } // get\n\n\n      function getBuild(data, builder) {\n        if (data.build !== undefined) return data.build;\n        data.build = builder(data);\n        return data.build;\n      } // animation\n\n\n      function parseAnimation(xml) {\n        var data = {\n          sources: {},\n          samplers: {},\n          channels: {}\n        };\n        var hasChildren = false;\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = void 0;\n\n          switch (child.nodeName) {\n            case 'source':\n              id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n\n            case 'sampler':\n              id = child.getAttribute('id');\n              data.samplers[id] = parseAnimationSampler(child);\n              break;\n\n            case 'channel':\n              id = child.getAttribute('target');\n              data.channels[id] = parseAnimationChannel(child);\n              break;\n\n            case 'animation':\n              // hierarchy of related animations\n              parseAnimation(child);\n              hasChildren = true;\n              break;\n\n            default:\n              console.log(child);\n          }\n        }\n\n        if (hasChildren === false) {\n          // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n          library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n        }\n      }\n\n      function parseAnimationSampler(xml) {\n        var data = {\n          inputs: {}\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'input':\n              var id = parseId(child.getAttribute('source'));\n              var semantic = child.getAttribute('semantic');\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseAnimationChannel(xml) {\n        var data = {};\n        var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n        var parts = target.split('/');\n        var id = parts.shift();\n        var sid = parts.shift(); // check selection syntax\n\n        var arraySyntax = sid.indexOf('(') !== -1;\n        var memberSyntax = sid.indexOf('.') !== -1;\n\n        if (memberSyntax) {\n          //  member selection access\n          parts = sid.split('.');\n          sid = parts.shift();\n          data.member = parts.shift();\n        } else if (arraySyntax) {\n          // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n          var indices = sid.split('(');\n          sid = indices.shift();\n\n          for (var i = 0; i < indices.length; i++) {\n            indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n          }\n\n          data.indices = indices;\n        }\n\n        data.id = id;\n        data.sid = sid;\n        data.arraySyntax = arraySyntax;\n        data.memberSyntax = memberSyntax;\n        data.sampler = parseId(xml.getAttribute('source'));\n        return data;\n      }\n\n      function buildAnimation(data) {\n        var tracks = [];\n        var channels = data.channels;\n        var samplers = data.samplers;\n        var sources = data.sources;\n\n        for (var target in channels) {\n          if (channels.hasOwnProperty(target)) {\n            var channel = channels[target];\n            var sampler = samplers[channel.sampler];\n            var inputId = sampler.inputs.INPUT;\n            var outputId = sampler.inputs.OUTPUT;\n            var inputSource = sources[inputId];\n            var outputSource = sources[outputId];\n            var animation = buildAnimationChannel(channel, inputSource, outputSource);\n            createKeyframeTracks(animation, tracks);\n          }\n        }\n\n        return tracks;\n      }\n\n      function getAnimation(id) {\n        return getBuild(library.animations[id], buildAnimation);\n      }\n\n      function buildAnimationChannel(channel, inputSource, outputSource) {\n        var node = library.nodes[channel.id];\n        var object3D = getNode(node.id);\n        var transform = node.transforms[channel.sid];\n        var defaultMatrix = node.matrix.clone().transpose();\n        var time, stride;\n        var i, il, j, jl;\n        var data = {}; // the collada spec allows the animation of data in various ways.\n        // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n        switch (transform) {\n          case 'matrix':\n            for (i = 0, il = inputSource.array.length; i < il; i++) {\n              time = inputSource.array[i];\n              stride = i * outputSource.stride;\n              if (data[time] === undefined) data[time] = {};\n\n              if (channel.arraySyntax === true) {\n                var value = outputSource.array[stride];\n                var index = channel.indices[0] + 4 * channel.indices[1];\n                data[time][index] = value;\n              } else {\n                for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                  data[time][j] = outputSource.array[stride + j];\n                }\n              }\n            }\n\n            break;\n\n          case 'translate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n\n          case 'rotate':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n\n          case 'scale':\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n        }\n\n        var keyframes = prepareAnimationData(data, defaultMatrix);\n        var animation = {\n          name: object3D.uuid,\n          keyframes: keyframes\n        };\n        return animation;\n      }\n\n      function prepareAnimationData(data, defaultMatrix) {\n        var keyframes = []; // transfer data into a sortable array\n\n        for (var time in data) {\n          keyframes.push({\n            time: parseFloat(time),\n            value: data[time]\n          });\n        } // ensure keyframes are sorted by time\n\n\n        keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n        for (var i = 0; i < 16; i++) {\n          transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n        }\n\n        return keyframes; // array sort function\n\n        function ascending(a, b) {\n          return a.time - b.time;\n        }\n      }\n\n      var position = new Vector3();\n      var scale = new Vector3();\n      var quaternion = new Quaternion();\n\n      function createKeyframeTracks(animation, tracks) {\n        var keyframes = animation.keyframes;\n        var name = animation.name;\n        var times = [];\n        var positionData = [];\n        var quaternionData = [];\n        var scaleData = [];\n\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          var time = keyframe.time;\n          var value = keyframe.value;\n          matrix.fromArray(value).transpose();\n          matrix.decompose(position, quaternion, scale);\n          times.push(time);\n          positionData.push(position.x, position.y, position.z);\n          quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n          scaleData.push(scale.x, scale.y, scale.z);\n        }\n\n        if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n\n        if (quaternionData.length > 0) {\n          tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n        }\n\n        if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n        return tracks;\n      }\n\n      function transformAnimationData(keyframes, property, defaultValue) {\n        var keyframe;\n        var empty = true;\n        var i, l; // check, if values of a property are missing in our keyframes\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n\n          if (keyframe.value[property] === undefined) {\n            keyframe.value[property] = null; // mark as missing\n          } else {\n            empty = false;\n          }\n        }\n\n        if (empty === true) {\n          // no values at all, so we set a default value\n          for (i = 0, l = keyframes.length; i < l; i++) {\n            keyframe = keyframes[i];\n            keyframe.value[property] = defaultValue;\n          }\n        } else {\n          // filling gaps\n          createMissingKeyframes(keyframes, property);\n        }\n      }\n\n      function createMissingKeyframes(keyframes, property) {\n        var prev, next;\n\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n\n          if (keyframe.value[property] === null) {\n            prev = getPrev(keyframes, i, property);\n            next = getNext(keyframes, i, property);\n\n            if (prev === null) {\n              keyframe.value[property] = next.value[property];\n              continue;\n            }\n\n            if (next === null) {\n              keyframe.value[property] = prev.value[property];\n              continue;\n            }\n\n            interpolate(keyframe, prev, next, property);\n          }\n        }\n      }\n\n      function getPrev(keyframes, i, property) {\n        while (i >= 0) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i--;\n        }\n\n        return null;\n      }\n\n      function getNext(keyframes, i, property) {\n        while (i < keyframes.length) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i++;\n        }\n\n        return null;\n      }\n\n      function interpolate(key, prev, next, property) {\n        if (next.time - prev.time === 0) {\n          key.value[property] = prev.value[property];\n          return;\n        }\n\n        key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n      } // animation clips\n\n\n      function parseAnimationClip(xml) {\n        var data = {\n          name: xml.getAttribute('id') || 'default',\n          start: parseFloat(xml.getAttribute('start') || 0),\n          end: parseFloat(xml.getAttribute('end') || 0),\n          animations: []\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'instance_animation':\n              data.animations.push(parseId(child.getAttribute('url')));\n              break;\n          }\n        }\n\n        library.clips[xml.getAttribute('id')] = data;\n      }\n\n      function buildAnimationClip(data) {\n        var tracks = [];\n        var name = data.name;\n        var duration = data.end - data.start || -1;\n        var animations = data.animations;\n\n        for (var i = 0, il = animations.length; i < il; i++) {\n          var animationTracks = getAnimation(animations[i]);\n\n          for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n            tracks.push(animationTracks[j]);\n          }\n        }\n\n        return new AnimationClip(name, duration, tracks);\n      }\n\n      function getAnimationClip(id) {\n        return getBuild(library.clips[id], buildAnimationClip);\n      } // controller\n\n\n      function parseController(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'skin':\n              // there is exactly one skin per controller\n              data.id = parseId(child.getAttribute('source'));\n              data.skin = parseSkin(child);\n              break;\n\n            case 'morph':\n              data.id = parseId(child.getAttribute('source'));\n              console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n              break;\n          }\n        }\n\n        library.controllers[xml.getAttribute('id')] = data;\n      }\n\n      function parseSkin(xml) {\n        var data = {\n          sources: {}\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'bind_shape_matrix':\n              data.bindShapeMatrix = parseFloats(child.textContent);\n              break;\n\n            case 'source':\n              var id = child.getAttribute('id');\n              data.sources[id] = parseSource(child);\n              break;\n\n            case 'joints':\n              data.joints = parseJoints(child);\n              break;\n\n            case 'vertex_weights':\n              data.vertexWeights = parseVertexWeights(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseJoints(xml) {\n        var data = {\n          inputs: {}\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'input':\n              var semantic = child.getAttribute('semantic');\n              var id = parseId(child.getAttribute('source'));\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseVertexWeights(xml) {\n        var data = {\n          inputs: {}\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'input':\n              var semantic = child.getAttribute('semantic');\n              var id = parseId(child.getAttribute('source'));\n              var offset = parseInt(child.getAttribute('offset'));\n              data.inputs[semantic] = {\n                id: id,\n                offset: offset\n              };\n              break;\n\n            case 'vcount':\n              data.vcount = parseInts(child.textContent);\n              break;\n\n            case 'v':\n              data.v = parseInts(child.textContent);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildController(data) {\n        var build = {\n          id: data.id\n        };\n        var geometry = library.geometries[build.id];\n\n        if (data.skin !== undefined) {\n          build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n          geometry.sources.skinIndices = build.skin.indices;\n          geometry.sources.skinWeights = build.skin.weights;\n        }\n\n        return build;\n      }\n\n      function buildSkin(data) {\n        var BONE_LIMIT = 4;\n        var build = {\n          joints: [],\n          // this must be an array to preserve the joint order\n          indices: {\n            array: [],\n            stride: BONE_LIMIT\n          },\n          weights: {\n            array: [],\n            stride: BONE_LIMIT\n          }\n        };\n        var sources = data.sources;\n        var vertexWeights = data.vertexWeights;\n        var vcount = vertexWeights.vcount;\n        var v = vertexWeights.v;\n        var jointOffset = vertexWeights.inputs.JOINT.offset;\n        var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n        var jointSource = data.sources[data.joints.inputs.JOINT];\n        var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n        var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n        var stride = 0;\n        var i, j, l; // procces skin data for each vertex\n\n        for (i = 0, l = vcount.length; i < l; i++) {\n          var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n          var vertexSkinData = [];\n\n          for (j = 0; j < jointCount; j++) {\n            var skinIndex = v[stride + jointOffset];\n            var weightId = v[stride + weightOffset];\n            var skinWeight = weights[weightId];\n            vertexSkinData.push({\n              index: skinIndex,\n              weight: skinWeight\n            });\n            stride += 2;\n          } // we sort the joints in descending order based on the weights.\n          // this ensures, we only procced the most important joints of the vertex\n\n\n          vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n          // the order of the skin data matches the order of vertices\n\n          for (j = 0; j < BONE_LIMIT; j++) {\n            var d = vertexSkinData[j];\n\n            if (d !== undefined) {\n              build.indices.array.push(d.index);\n              build.weights.array.push(d.weight);\n            } else {\n              build.indices.array.push(0);\n              build.weights.array.push(0);\n            }\n          }\n        } // setup bind matrix\n\n\n        if (data.bindShapeMatrix) {\n          build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n        } else {\n          build.bindMatrix = new Matrix4().identity();\n        } // process bones and inverse bind matrix data\n\n\n        for (i = 0, l = jointSource.array.length; i < l; i++) {\n          var name = jointSource.array[i];\n          var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n          build.joints.push({\n            name: name,\n            boneInverse: boneInverse\n          });\n        }\n\n        return build; // array sort function\n\n        function descending(a, b) {\n          return b.weight - a.weight;\n        }\n      }\n\n      function getController(id) {\n        return getBuild(library.controllers[id], buildController);\n      } // image\n\n\n      function parseImage(xml) {\n        var data = {\n          init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n        };\n        library.images[xml.getAttribute('id')] = data;\n      }\n\n      function buildImage(data) {\n        if (data.build !== undefined) return data.build;\n        return data.init_from;\n      }\n\n      function getImage(id) {\n        var data = library.images[id];\n\n        if (data !== undefined) {\n          return getBuild(data, buildImage);\n        }\n\n        console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n        return null;\n      } // effect\n\n\n      function parseEffect(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'profile_COMMON':\n              data.profile = parseEffectProfileCOMMON(child);\n              break;\n          }\n        }\n\n        library.effects[xml.getAttribute('id')] = data;\n      }\n\n      function parseEffectProfileCOMMON(xml) {\n        var data = {\n          surfaces: {},\n          samplers: {}\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'newparam':\n              parseEffectNewparam(child, data);\n              break;\n\n            case 'technique':\n              data.technique = parseEffectTechnique(child);\n              break;\n\n            case 'extra':\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectNewparam(xml, data) {\n        var sid = xml.getAttribute('sid');\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'surface':\n              data.surfaces[sid] = parseEffectSurface(child);\n              break;\n\n            case 'sampler2D':\n              data.samplers[sid] = parseEffectSampler(child);\n              break;\n          }\n        }\n      }\n\n      function parseEffectSurface(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'init_from':\n              data.init_from = child.textContent;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectSampler(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'source':\n              data.source = child.textContent;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectTechnique(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'constant':\n            case 'lambert':\n            case 'blinn':\n            case 'phong':\n              data.type = child.nodeName;\n              data.parameters = parseEffectParameters(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameters(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'emission':\n            case 'diffuse':\n            case 'specular':\n            case 'bump':\n            case 'ambient':\n            case 'shininess':\n            case 'transparency':\n              data[child.nodeName] = parseEffectParameter(child);\n              break;\n\n            case 'transparent':\n              data[child.nodeName] = {\n                opaque: child.getAttribute('opaque'),\n                data: parseEffectParameter(child)\n              };\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameter(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'color':\n              data[child.nodeName] = parseFloats(child.textContent);\n              break;\n\n            case 'float':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n\n            case 'texture':\n              data[child.nodeName] = {\n                id: child.getAttribute('texture'),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameterTexture(xml) {\n        var data = {\n          technique: {}\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'extra':\n              parseEffectParameterTextureExtra(child, data);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectParameterTextureExtra(xml, data) {\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'technique':\n              parseEffectParameterTextureExtraTechnique(child, data);\n              break;\n          }\n        }\n      }\n\n      function parseEffectParameterTextureExtraTechnique(xml, data) {\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'repeatU':\n            case 'repeatV':\n            case 'offsetU':\n            case 'offsetV':\n              data.technique[child.nodeName] = parseFloat(child.textContent);\n              break;\n\n            case 'wrapU':\n            case 'wrapV':\n              // some files have values for wrapU/wrapV which become NaN via parseInt\n              if (child.textContent.toUpperCase() === 'TRUE') {\n                data.technique[child.nodeName] = 1;\n              } else if (child.textContent.toUpperCase() === 'FALSE') {\n                data.technique[child.nodeName] = 0;\n              } else {\n                data.technique[child.nodeName] = parseInt(child.textContent);\n              }\n\n              break;\n          }\n        }\n      }\n\n      function parseEffectExtra(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'technique':\n              data.technique = parseEffectExtraTechnique(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseEffectExtraTechnique(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'double_sided':\n              data[child.nodeName] = parseInt(child.textContent);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildEffect(data) {\n        return data;\n      }\n\n      function getEffect(id) {\n        return getBuild(library.effects[id], buildEffect);\n      } // material\n\n\n      function parseMaterial(xml) {\n        var data = {\n          name: xml.getAttribute('name')\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'instance_effect':\n              data.url = parseId(child.getAttribute('url'));\n              break;\n          }\n        }\n\n        library.materials[xml.getAttribute('id')] = data;\n      }\n\n      function getTextureLoader(image) {\n        var loader;\n        var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n        extension = extension.toLowerCase();\n\n        switch (extension) {\n          case 'tga':\n            loader = tgaLoader;\n            break;\n\n          default:\n            loader = textureLoader;\n        }\n\n        return loader;\n      }\n\n      function buildMaterial(data) {\n        var effect = getEffect(data.url);\n        var technique = effect.profile.technique;\n        var extra = effect.profile.extra;\n        var material;\n\n        switch (technique.type) {\n          case 'phong':\n          case 'blinn':\n            material = new MeshPhongMaterial();\n            break;\n\n          case 'lambert':\n            material = new MeshLambertMaterial();\n            break;\n\n          default:\n            material = new MeshBasicMaterial();\n            break;\n        }\n\n        material.name = data.name || '';\n\n        function getTexture(textureObject) {\n          var sampler = effect.profile.samplers[textureObject.id];\n          var image = null; // get image\n\n          if (sampler !== undefined) {\n            var surface = effect.profile.surfaces[sampler.source];\n            image = getImage(surface.init_from);\n          } else {\n            console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n            image = getImage(textureObject.id);\n          } // create texture if image is avaiable\n\n\n          if (image !== null) {\n            var loader = getTextureLoader(image);\n\n            if (loader !== undefined) {\n              var texture = loader.load(image);\n              var _extra = textureObject.extra;\n\n              if (_extra !== undefined && _extra.technique !== undefined && isEmpty(_extra.technique) === false) {\n                var _technique = _extra.technique;\n                texture.wrapS = _technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.wrapT = _technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.offset.set(_technique.offsetU || 0, _technique.offsetV || 0);\n                texture.repeat.set(_technique.repeatU || 1, _technique.repeatV || 1);\n              } else {\n                texture.wrapS = RepeatWrapping;\n                texture.wrapT = RepeatWrapping;\n              }\n\n              return texture;\n            } else {\n              console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n              return null;\n            }\n          } else {\n            console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n            return null;\n          }\n        }\n\n        var parameters = technique.parameters;\n\n        for (var key in parameters) {\n          var parameter = parameters[key];\n\n          switch (key) {\n            case 'diffuse':\n              if (parameter.color) material.color.fromArray(parameter.color);\n              if (parameter.texture) material.map = getTexture(parameter.texture);\n              break;\n\n            case 'specular':\n              if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n              if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n              break;\n\n            case 'bump':\n              if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n              break;\n\n            case 'ambient':\n              if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n              break;\n\n            case 'shininess':\n              if (parameter.float && material.shininess) material.shininess = parameter.float;\n              break;\n\n            case 'emission':\n              if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n              if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n              break;\n          }\n        } //\n\n\n        var transparent = parameters['transparent'];\n        var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n        if (transparency === undefined && transparent) {\n          transparency = {\n            float: 1\n          };\n        } // <transparent> does not exist but <transparency>\n\n\n        if (transparent === undefined && transparency) {\n          transparent = {\n            opaque: 'A_ONE',\n            data: {\n              color: [1, 1, 1, 1]\n            }\n          };\n        }\n\n        if (transparent && transparency) {\n          // handle case if a texture exists but no color\n          if (transparent.data.texture) {\n            // we do not set an alpha map (see #13792)\n            material.transparent = true;\n          } else {\n            var color = transparent.data.color;\n\n            switch (transparent.opaque) {\n              case 'A_ONE':\n                material.opacity = color[3] * transparency.float;\n                break;\n\n              case 'RGB_ZERO':\n                material.opacity = 1 - color[0] * transparency.float;\n                break;\n\n              case 'A_ZERO':\n                material.opacity = 1 - color[3] * transparency.float;\n                break;\n\n              case 'RGB_ONE':\n                material.opacity = color[0] * transparency.float;\n                break;\n\n              default:\n                console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n            }\n\n            if (material.opacity < 1) material.transparent = true;\n          }\n        } //\n\n\n        if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n          material.side = DoubleSide;\n        }\n\n        return material;\n      }\n\n      function getMaterial(id) {\n        return getBuild(library.materials[id], buildMaterial);\n      } // camera\n\n\n      function parseCamera(xml) {\n        var data = {\n          name: xml.getAttribute('name')\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'optics':\n              data.optics = parseCameraOptics(child);\n              break;\n          }\n        }\n\n        library.cameras[xml.getAttribute('id')] = data;\n      }\n\n      function parseCameraOptics(xml) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n\n          switch (child.nodeName) {\n            case 'technique_common':\n              return parseCameraTechnique(child);\n          }\n        }\n\n        return {};\n      }\n\n      function parseCameraTechnique(xml) {\n        var data = {};\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n\n          switch (child.nodeName) {\n            case 'perspective':\n            case 'orthographic':\n              data.technique = child.nodeName;\n              data.parameters = parseCameraParameters(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseCameraParameters(xml) {\n        var data = {};\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n\n          switch (child.nodeName) {\n            case 'xfov':\n            case 'yfov':\n            case 'xmag':\n            case 'ymag':\n            case 'znear':\n            case 'zfar':\n            case 'aspect_ratio':\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildCamera(data) {\n        var camera;\n\n        switch (data.optics.technique) {\n          case 'perspective':\n            camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n\n          case 'orthographic':\n            var ymag = data.optics.parameters.ymag;\n            var xmag = data.optics.parameters.xmag;\n            var aspectRatio = data.optics.parameters.aspect_ratio;\n            xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n            ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n            xmag *= 0.5;\n            ymag *= 0.5;\n            camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n            data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n\n          default:\n            camera = new PerspectiveCamera();\n            break;\n        }\n\n        camera.name = data.name || '';\n        return camera;\n      }\n\n      function getCamera(id) {\n        var data = library.cameras[id];\n\n        if (data !== undefined) {\n          return getBuild(data, buildCamera);\n        }\n\n        console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n        return null;\n      } // light\n\n\n      function parseLight(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'technique_common':\n              data = parseLightTechnique(child);\n              break;\n          }\n        }\n\n        library.lights[xml.getAttribute('id')] = data;\n      }\n\n      function parseLightTechnique(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'directional':\n            case 'point':\n            case 'spot':\n            case 'ambient':\n              data.technique = child.nodeName;\n              data.parameters = parseLightParameters(child);\n          }\n        }\n\n        return data;\n      }\n\n      function parseLightParameters(xml) {\n        var data = {};\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'color':\n              var array = parseFloats(child.textContent);\n              data.color = new Color().fromArray(array);\n              break;\n\n            case 'falloff_angle':\n              data.falloffAngle = parseFloat(child.textContent);\n              break;\n\n            case 'quadratic_attenuation':\n              var f = parseFloat(child.textContent);\n              data.distance = f ? Math.sqrt(1 / f) : 0;\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildLight(data) {\n        var light;\n\n        switch (data.technique) {\n          case 'directional':\n            light = new DirectionalLight();\n            break;\n\n          case 'point':\n            light = new PointLight();\n            break;\n\n          case 'spot':\n            light = new SpotLight();\n            break;\n\n          case 'ambient':\n            light = new AmbientLight();\n            break;\n        }\n\n        if (data.parameters.color) light.color.copy(data.parameters.color);\n        if (data.parameters.distance) light.distance = data.parameters.distance;\n        return light;\n      }\n\n      function getLight(id) {\n        var data = library.lights[id];\n\n        if (data !== undefined) {\n          return getBuild(data, buildLight);\n        }\n\n        console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n        return null;\n      } // geometry\n\n\n      function parseGeometry(xml) {\n        var data = {\n          name: xml.getAttribute('name'),\n          sources: {},\n          vertices: {},\n          primitives: []\n        };\n        var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n        if (mesh === undefined) return;\n\n        for (var i = 0; i < mesh.childNodes.length; i++) {\n          var child = mesh.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = child.getAttribute('id');\n\n          switch (child.nodeName) {\n            case 'source':\n              data.sources[id] = parseSource(child);\n              break;\n\n            case 'vertices':\n              // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n              data.vertices = parseGeometryVertices(child);\n              break;\n\n            case 'polygons':\n              console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n              break;\n\n            case 'lines':\n            case 'linestrips':\n            case 'polylist':\n            case 'triangles':\n              data.primitives.push(parseGeometryPrimitive(child));\n              break;\n\n            default:\n              console.log(child);\n          }\n        }\n\n        library.geometries[xml.getAttribute('id')] = data;\n      }\n\n      function parseSource(xml) {\n        var data = {\n          array: [],\n          stride: 3\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'float_array':\n              data.array = parseFloats(child.textContent);\n              break;\n\n            case 'Name_array':\n              data.array = parseStrings(child.textContent);\n              break;\n\n            case 'technique_common':\n              var accessor = getElementsByTagName(child, 'accessor')[0];\n\n              if (accessor !== undefined) {\n                data.stride = parseInt(accessor.getAttribute('stride'));\n              }\n\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseGeometryVertices(xml) {\n        var data = {};\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n        }\n\n        return data;\n      }\n\n      function parseGeometryPrimitive(xml) {\n        var primitive = {\n          type: xml.nodeName,\n          material: xml.getAttribute('material'),\n          count: parseInt(xml.getAttribute('count')),\n          inputs: {},\n          stride: 0,\n          hasUV: false\n        };\n\n        for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'input':\n              var id = parseId(child.getAttribute('source'));\n              var semantic = child.getAttribute('semantic');\n              var offset = parseInt(child.getAttribute('offset'));\n              var set = parseInt(child.getAttribute('set'));\n              var inputname = set > 0 ? semantic + set : semantic;\n              primitive.inputs[inputname] = {\n                id: id,\n                offset: offset\n              };\n              primitive.stride = Math.max(primitive.stride, offset + 1);\n              if (semantic === 'TEXCOORD') primitive.hasUV = true;\n              break;\n\n            case 'vcount':\n              primitive.vcount = parseInts(child.textContent);\n              break;\n\n            case 'p':\n              primitive.p = parseInts(child.textContent);\n              break;\n          }\n        }\n\n        return primitive;\n      }\n\n      function groupPrimitives(primitives) {\n        var build = {};\n\n        for (var i = 0; i < primitives.length; i++) {\n          var primitive = primitives[i];\n          if (build[primitive.type] === undefined) build[primitive.type] = [];\n          build[primitive.type].push(primitive);\n        }\n\n        return build;\n      }\n\n      function checkUVCoordinates(primitives) {\n        var count = 0;\n\n        for (var i = 0, l = primitives.length; i < l; i++) {\n          var primitive = primitives[i];\n\n          if (primitive.hasUV === true) {\n            count++;\n          }\n        }\n\n        if (count > 0 && count < primitives.length) {\n          primitives.uvsNeedsFix = true;\n        }\n      }\n\n      function buildGeometry(data) {\n        var build = {};\n        var sources = data.sources;\n        var vertices = data.vertices;\n        var primitives = data.primitives;\n        if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n        // first, we group all primitives by their type\n\n        var groupedPrimitives = groupPrimitives(primitives);\n\n        for (var type in groupedPrimitives) {\n          var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n          checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n          build[type] = buildGeometryType(primitiveType, sources, vertices);\n        }\n\n        return build;\n      }\n\n      function buildGeometryType(primitives, sources, vertices) {\n        var build = {};\n        var position = {\n          array: [],\n          stride: 0\n        };\n        var normal = {\n          array: [],\n          stride: 0\n        };\n        var uv = {\n          array: [],\n          stride: 0\n        };\n        var uv2 = {\n          array: [],\n          stride: 0\n        };\n        var color = {\n          array: [],\n          stride: 0\n        };\n        var skinIndex = {\n          array: [],\n          stride: 4\n        };\n        var skinWeight = {\n          array: [],\n          stride: 4\n        };\n        var geometry = new BufferGeometry();\n        var materialKeys = [];\n        var start = 0;\n\n        for (var p = 0; p < primitives.length; p++) {\n          var primitive = primitives[p];\n          var inputs = primitive.inputs; // groups\n\n          var _count = 0;\n\n          switch (primitive.type) {\n            case 'lines':\n            case 'linestrips':\n              _count = primitive.count * 2;\n              break;\n\n            case 'triangles':\n              _count = primitive.count * 3;\n              break;\n\n            case 'polylist':\n              for (var g = 0; g < primitive.count; g++) {\n                var vc = primitive.vcount[g];\n\n                switch (vc) {\n                  case 3:\n                    _count += 3; // single triangle\n\n                    break;\n\n                  case 4:\n                    _count += 6; // quad, subdivided into two triangles\n\n                    break;\n\n                  default:\n                    _count += (vc - 2) * 3; // polylist with more than four vertices\n\n                    break;\n                }\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n          }\n\n          geometry.addGroup(start, _count, p);\n          start += _count; // material\n\n          if (primitive.material) {\n            materialKeys.push(primitive.material);\n          } // geometry data\n\n\n          for (var name in inputs) {\n            var input = inputs[name];\n\n            switch (name) {\n              case 'VERTEX':\n                for (var key in vertices) {\n                  var id = vertices[key];\n\n                  switch (key) {\n                    case 'POSITION':\n                      var prevLength = position.array.length;\n                      buildGeometryData(primitive, sources[id], input.offset, position.array);\n                      position.stride = sources[id].stride;\n\n                      if (sources.skinWeights && sources.skinIndices) {\n                        buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                        buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                      } // see #3803\n\n\n                      if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                        var _count2 = (position.array.length - prevLength) / position.stride;\n\n                        for (var i = 0; i < _count2; i++) {\n                          // fill missing uv coordinates\n                          uv.array.push(0, 0);\n                        }\n                      }\n\n                      break;\n\n                    case 'NORMAL':\n                      buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                      normal.stride = sources[id].stride;\n                      break;\n\n                    case 'COLOR':\n                      buildGeometryData(primitive, sources[id], input.offset, color.array);\n                      color.stride = sources[id].stride;\n                      break;\n\n                    case 'TEXCOORD':\n                      buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                      uv.stride = sources[id].stride;\n                      break;\n\n                    case 'TEXCOORD1':\n                      buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                      uv.stride = sources[id].stride;\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                  }\n                }\n\n                break;\n\n              case 'NORMAL':\n                buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                normal.stride = sources[input.id].stride;\n                break;\n\n              case 'COLOR':\n                buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n                color.stride = sources[input.id].stride;\n                break;\n\n              case 'TEXCOORD':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                uv.stride = sources[input.id].stride;\n                break;\n\n              case 'TEXCOORD1':\n                buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n                uv2.stride = sources[input.id].stride;\n                break;\n            }\n          }\n        } // build geometry\n\n\n        if (position.array.length > 0) {\n          geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n        }\n\n        if (normal.array.length > 0) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n        }\n\n        if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n        if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n        if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n\n        if (skinIndex.array.length > 0) {\n          geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n        }\n\n        if (skinWeight.array.length > 0) {\n          geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n        }\n\n        build.data = geometry;\n        build.type = primitives[0].type;\n        build.materialKeys = materialKeys;\n        return build;\n      }\n\n      function buildGeometryData(primitive, source, offset, array) {\n        var indices = primitive.p;\n        var stride = primitive.stride;\n        var vcount = primitive.vcount;\n\n        function pushVector(i) {\n          var index = indices[i + offset] * sourceStride;\n          var length = index + sourceStride;\n\n          for (; index < length; index++) {\n            array.push(sourceArray[index]);\n          }\n        }\n\n        var sourceArray = source.array;\n        var sourceStride = source.stride;\n\n        if (primitive.vcount !== undefined) {\n          var index = 0;\n\n          for (var i = 0, l = vcount.length; i < l; i++) {\n            var _count3 = vcount[i];\n\n            if (_count3 === 4) {\n              var a = index + stride * 0;\n              var b = index + stride * 1;\n              var c = index + stride * 2;\n              var d = index + stride * 3;\n              pushVector(a);\n              pushVector(b);\n              pushVector(d);\n              pushVector(b);\n              pushVector(c);\n              pushVector(d);\n            } else if (_count3 === 3) {\n              var _a = index + stride * 0;\n\n              var _b = index + stride * 1;\n\n              var _c = index + stride * 2;\n\n              pushVector(_a);\n              pushVector(_b);\n              pushVector(_c);\n            } else if (_count3 > 4) {\n              for (var k = 1, kl = _count3 - 2; k <= kl; k++) {\n                var _a2 = index + stride * 0;\n\n                var _b2 = index + stride * k;\n\n                var _c2 = index + stride * (k + 1);\n\n                pushVector(_a2);\n                pushVector(_b2);\n                pushVector(_c2);\n              }\n            }\n\n            index += stride * _count3;\n          }\n        } else {\n          for (var _i = 0, _l = indices.length; _i < _l; _i += stride) {\n            pushVector(_i);\n          }\n        }\n      }\n\n      function getGeometry(id) {\n        return getBuild(library.geometries[id], buildGeometry);\n      } // kinematics\n\n\n      function parseKinematicsModel(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          joints: {},\n          links: []\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'technique_common':\n              parseKinematicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n\n        library.kinematicsModels[xml.getAttribute('id')] = data;\n      }\n\n      function buildKinematicsModel(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n\n      function getKinematicsModel(id) {\n        return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n      }\n\n      function parseKinematicsTechniqueCommon(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'joint':\n              data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n              break;\n\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n          }\n        }\n      }\n\n      function parseKinematicsJoint(xml) {\n        var data;\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'prismatic':\n            case 'revolute':\n              data = parseKinematicsJointParameter(child);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseKinematicsJointParameter(xml) {\n        var data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          axis: new Vector3(),\n          limits: {\n            min: 0,\n            max: 0\n          },\n          type: xml.nodeName,\n          static: false,\n          zeroPosition: 0,\n          middlePosition: 0\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'axis':\n              var array = parseFloats(child.textContent);\n              data.axis.fromArray(array);\n              break;\n\n            case 'limits':\n              var max = child.getElementsByTagName('max')[0];\n              var min = child.getElementsByTagName('min')[0];\n              data.limits.max = parseFloat(max.textContent);\n              data.limits.min = parseFloat(min.textContent);\n              break;\n          }\n        } // if min is equal to or greater than max, consider the joint static\n\n\n        if (data.limits.min >= data.limits.max) {\n          data.static = true;\n        } // calculate middle position\n\n\n        data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n        return data;\n      }\n\n      function parseKinematicsLink(xml) {\n        var data = {\n          sid: xml.getAttribute('sid'),\n          name: xml.getAttribute('name') || '',\n          attachments: [],\n          transforms: []\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'attachment_full':\n              data.attachments.push(parseKinematicsAttachment(child));\n              break;\n\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseKinematicsAttachment(xml) {\n        var data = {\n          joint: xml.getAttribute('joint').split('/').pop(),\n          transforms: [],\n          links: []\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'link':\n              data.links.push(parseKinematicsLink(child));\n              break;\n\n            case 'matrix':\n            case 'translate':\n            case 'rotate':\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function parseKinematicsTransform(xml) {\n        var data = {\n          type: xml.nodeName\n        };\n        var array = parseFloats(xml.textContent);\n\n        switch (data.type) {\n          case 'matrix':\n            data.obj = new Matrix4();\n            data.obj.fromArray(array).transpose();\n            break;\n\n          case 'translate':\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            break;\n\n          case 'rotate':\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            data.angle = MathUtils.degToRad(array[3]);\n            break;\n        }\n\n        return data;\n      } // physics\n\n\n      function parsePhysicsModel(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          rigidBodies: {}\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'rigid_body':\n              data.rigidBodies[child.getAttribute('name')] = {};\n              parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n              break;\n          }\n        }\n\n        library.physicsModels[xml.getAttribute('id')] = data;\n      }\n\n      function parsePhysicsRigidBody(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'technique_common':\n              parsePhysicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n      }\n\n      function parsePhysicsTechniqueCommon(xml, data) {\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'inertia':\n              data.inertia = parseFloats(child.textContent);\n              break;\n\n            case 'mass':\n              data.mass = parseFloats(child.textContent)[0];\n              break;\n          }\n        }\n      } // scene\n\n\n      function parseKinematicsScene(xml) {\n        var data = {\n          bindJointAxis: []\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'bind_joint_axis':\n              data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n              break;\n          }\n        }\n\n        library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n      }\n\n      function parseKinematicsBindJointAxis(xml) {\n        var data = {\n          target: xml.getAttribute('target').split('/').pop()\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          switch (child.nodeName) {\n            case 'axis':\n              var param = child.getElementsByTagName('param')[0];\n              data.axis = param.textContent;\n              var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n              data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildKinematicsScene(data) {\n        if (data.build !== undefined) return data.build;\n        return data;\n      }\n\n      function getKinematicsScene(id) {\n        return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n      }\n\n      function setupKinematics() {\n        var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n        var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n        var visualSceneId = Object.keys(library.visualScenes)[0];\n        if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n        var kinematicsModel = getKinematicsModel(kinematicsModelId);\n        var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n        var visualScene = getVisualScene(visualSceneId);\n        var bindJointAxis = kinematicsScene.bindJointAxis;\n        var jointMap = {};\n\n        for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n          var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n          var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n          if (targetElement) {\n            // get the parent of the transform element\n            var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n            connect(axis.jointIndex, parentVisualElement);\n          }\n        }\n\n        function connect(jointIndex, visualElement) {\n          var visualElementName = visualElement.getAttribute('name');\n          var joint = kinematicsModel.joints[jointIndex];\n          visualScene.traverse(function (object) {\n            if (object.name === visualElementName) {\n              jointMap[jointIndex] = {\n                object: object,\n                transforms: buildTransformList(visualElement),\n                joint: joint,\n                position: joint.zeroPosition\n              };\n            }\n          });\n        }\n\n        var m0 = new Matrix4();\n        kinematics = {\n          joints: kinematicsModel && kinematicsModel.joints,\n          getJointValue: function getJointValue(jointIndex) {\n            var jointData = jointMap[jointIndex];\n\n            if (jointData) {\n              return jointData.position;\n            } else {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n            }\n          },\n          setJointValue: function setJointValue(jointIndex, value) {\n            var jointData = jointMap[jointIndex];\n\n            if (jointData) {\n              var joint = jointData.joint;\n\n              if (value > joint.limits.max || value < joint.limits.min) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n              } else if (joint.static) {\n                console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n              } else {\n                var object = jointData.object;\n                var _axis = joint.axis;\n                var transforms = jointData.transforms;\n                matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n                for (var _i2 = 0; _i2 < transforms.length; _i2++) {\n                  var transform = transforms[_i2]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                  if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                    switch (joint.type) {\n                      case 'revolute':\n                        matrix.multiply(m0.makeRotationAxis(_axis, MathUtils.degToRad(value)));\n                        break;\n\n                      case 'prismatic':\n                        matrix.multiply(m0.makeTranslation(_axis.x * value, _axis.y * value, _axis.z * value));\n                        break;\n\n                      default:\n                        console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                        break;\n                    }\n                  } else {\n                    switch (transform.type) {\n                      case 'matrix':\n                        matrix.multiply(transform.obj);\n                        break;\n\n                      case 'translate':\n                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                        break;\n\n                      case 'scale':\n                        matrix.scale(transform.obj);\n                        break;\n\n                      case 'rotate':\n                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                        break;\n                    }\n                  }\n                }\n\n                object.matrix.copy(matrix);\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\n                jointMap[jointIndex].position = value;\n              }\n            } else {\n              console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n            }\n          }\n        };\n      }\n\n      function buildTransformList(node) {\n        var transforms = [];\n        var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n\n          var array = void 0,\n              _vector = void 0;\n\n          switch (child.nodeName) {\n            case 'matrix':\n              array = parseFloats(child.textContent);\n\n              var _matrix = new Matrix4().fromArray(array).transpose();\n\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _matrix\n              });\n              break;\n\n            case 'translate':\n            case 'scale':\n              array = parseFloats(child.textContent);\n              _vector = new Vector3().fromArray(array);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _vector\n              });\n              break;\n\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              _vector = new Vector3().fromArray(array);\n              var angle = MathUtils.degToRad(array[3]);\n              transforms.push({\n                sid: child.getAttribute('sid'),\n                type: child.nodeName,\n                obj: _vector,\n                angle: angle\n              });\n              break;\n          }\n        }\n\n        return transforms;\n      } // nodes\n\n\n      function prepareNodes(xml) {\n        var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i];\n\n          if (element.hasAttribute('id') === false) {\n            element.setAttribute('id', generateId());\n          }\n        }\n      }\n\n      var matrix = new Matrix4();\n      var vector = new Vector3();\n\n      function parseNode(xml) {\n        var data = {\n          name: xml.getAttribute('name') || '',\n          type: xml.getAttribute('type'),\n          id: xml.getAttribute('id'),\n          sid: xml.getAttribute('sid'),\n          matrix: new Matrix4(),\n          nodes: [],\n          instanceCameras: [],\n          instanceControllers: [],\n          instanceLights: [],\n          instanceGeometries: [],\n          instanceNodes: [],\n          transforms: {}\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0;\n\n          switch (child.nodeName) {\n            case 'node':\n              data.nodes.push(child.getAttribute('id'));\n              parseNode(child);\n              break;\n\n            case 'instance_camera':\n              data.instanceCameras.push(parseId(child.getAttribute('url')));\n              break;\n\n            case 'instance_controller':\n              data.instanceControllers.push(parseNodeInstance(child));\n              break;\n\n            case 'instance_light':\n              data.instanceLights.push(parseId(child.getAttribute('url')));\n              break;\n\n            case 'instance_geometry':\n              data.instanceGeometries.push(parseNodeInstance(child));\n              break;\n\n            case 'instance_node':\n              data.instanceNodes.push(parseId(child.getAttribute('url')));\n              break;\n\n            case 'matrix':\n              array = parseFloats(child.textContent);\n              data.matrix.multiply(matrix.fromArray(array).transpose());\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n\n            case 'translate':\n              array = parseFloats(child.textContent);\n              vector.fromArray(array);\n              data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n\n            case 'rotate':\n              array = parseFloats(child.textContent);\n              var angle = MathUtils.degToRad(array[3]);\n              data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n\n            case 'scale':\n              array = parseFloats(child.textContent);\n              data.matrix.scale(vector.fromArray(array));\n              data.transforms[child.getAttribute('sid')] = child.nodeName;\n              break;\n\n            case 'extra':\n              break;\n\n            default:\n              console.log(child);\n          }\n        }\n\n        if (hasNode(data.id)) {\n          console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n        } else {\n          library.nodes[data.id] = data;\n        }\n\n        return data;\n      }\n\n      function parseNodeInstance(xml) {\n        var data = {\n          id: parseId(xml.getAttribute('url')),\n          materials: {},\n          skeletons: []\n        };\n\n        for (var i = 0; i < xml.childNodes.length; i++) {\n          var child = xml.childNodes[i];\n\n          switch (child.nodeName) {\n            case 'bind_material':\n              var instances = child.getElementsByTagName('instance_material');\n\n              for (var j = 0; j < instances.length; j++) {\n                var instance = instances[j];\n                var symbol = instance.getAttribute('symbol');\n                var target = instance.getAttribute('target');\n                data.materials[symbol] = parseId(target);\n              }\n\n              break;\n\n            case 'skeleton':\n              data.skeletons.push(parseId(child.textContent));\n              break;\n          }\n        }\n\n        return data;\n      }\n\n      function buildSkeleton(skeletons, joints) {\n        var boneData = [];\n        var sortedBoneData = [];\n        var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n        // situtation with multiple \"skeleton\" tags per controller instance\n\n        for (i = 0; i < skeletons.length; i++) {\n          var skeleton = skeletons[i];\n          var root = void 0;\n\n          if (hasNode(skeleton)) {\n            root = getNode(skeleton);\n            buildBoneHierarchy(root, joints, boneData);\n          } else if (hasVisualScene(skeleton)) {\n            // handle case where the skeleton refers to the visual scene (#13335)\n            var visualScene = library.visualScenes[skeleton];\n            var children = visualScene.children;\n\n            for (var _j = 0; _j < children.length; _j++) {\n              var child = children[_j];\n\n              if (child.type === 'JOINT') {\n                var _root = getNode(child.id);\n\n                buildBoneHierarchy(_root, joints, boneData);\n              }\n            }\n          } else {\n            console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n          }\n        } // sort bone data (the order is defined in the corresponding controller)\n\n\n        for (i = 0; i < joints.length; i++) {\n          for (j = 0; j < boneData.length; j++) {\n            data = boneData[j];\n\n            if (data.bone.name === joints[i].name) {\n              sortedBoneData[i] = data;\n              data.processed = true;\n              break;\n            }\n          }\n        } // add unprocessed bone data at the end of the list\n\n\n        for (i = 0; i < boneData.length; i++) {\n          data = boneData[i];\n\n          if (data.processed === false) {\n            sortedBoneData.push(data);\n            data.processed = true;\n          }\n        } // setup arrays for skeleton creation\n\n\n        var bones = [];\n        var boneInverses = [];\n\n        for (i = 0; i < sortedBoneData.length; i++) {\n          data = sortedBoneData[i];\n          bones.push(data.bone);\n          boneInverses.push(data.boneInverse);\n        }\n\n        return new Skeleton(bones, boneInverses);\n      }\n\n      function buildBoneHierarchy(root, joints, boneData) {\n        // setup bone data from visual scene\n        root.traverse(function (object) {\n          if (object.isBone === true) {\n            var boneInverse; // retrieve the boneInverse from the controller data\n\n            for (var i = 0; i < joints.length; i++) {\n              var joint = joints[i];\n\n              if (joint.name === object.name) {\n                boneInverse = joint.boneInverse;\n                break;\n              }\n            }\n\n            if (boneInverse === undefined) {\n              // Unfortunately, there can be joints in the visual scene that are not part of the\n              // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n              // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n              // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n              // ensure a correct animation of the model.\n              boneInverse = new Matrix4();\n            }\n\n            boneData.push({\n              bone: object,\n              boneInverse: boneInverse,\n              processed: false\n            });\n          }\n        });\n      }\n\n      function buildNode(data) {\n        var objects = [];\n        var matrix = data.matrix;\n        var nodes = data.nodes;\n        var type = data.type;\n        var instanceCameras = data.instanceCameras;\n        var instanceControllers = data.instanceControllers;\n        var instanceLights = data.instanceLights;\n        var instanceGeometries = data.instanceGeometries;\n        var instanceNodes = data.instanceNodes; // nodes\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          objects.push(getNode(nodes[i]));\n        } // instance cameras\n\n\n        for (var _i3 = 0, _l2 = instanceCameras.length; _i3 < _l2; _i3++) {\n          var instanceCamera = getCamera(instanceCameras[_i3]);\n\n          if (instanceCamera !== null) {\n            objects.push(instanceCamera.clone());\n          }\n        } // instance controllers\n\n\n        for (var _i4 = 0, _l3 = instanceControllers.length; _i4 < _l3; _i4++) {\n          var instance = instanceControllers[_i4];\n          var controller = getController(instance.id);\n          var geometries = getGeometry(controller.id);\n          var newObjects = buildObjects(geometries, instance.materials);\n          var skeletons = instance.skeletons;\n          var joints = controller.skin.joints;\n          var skeleton = buildSkeleton(skeletons, joints);\n\n          for (var j = 0, jl = newObjects.length; j < jl; j++) {\n            var _object = newObjects[j];\n\n            if (_object.isSkinnedMesh) {\n              _object.bind(skeleton, controller.skin.bindMatrix);\n\n              _object.normalizeSkinWeights();\n            }\n\n            objects.push(_object);\n          }\n        } // instance lights\n\n\n        for (var _i5 = 0, _l4 = instanceLights.length; _i5 < _l4; _i5++) {\n          var instanceLight = getLight(instanceLights[_i5]);\n\n          if (instanceLight !== null) {\n            objects.push(instanceLight.clone());\n          }\n        } // instance geometries\n\n\n        for (var _i6 = 0, _l5 = instanceGeometries.length; _i6 < _l5; _i6++) {\n          var _instance = instanceGeometries[_i6]; // a single geometry instance in collada can lead to multiple object3Ds.\n          // this is the case when primitives are combined like triangles and lines\n\n          var _geometries = getGeometry(_instance.id);\n\n          var _newObjects = buildObjects(_geometries, _instance.materials);\n\n          for (var _j2 = 0, _jl = _newObjects.length; _j2 < _jl; _j2++) {\n            objects.push(_newObjects[_j2]);\n          }\n        } // instance nodes\n\n\n        for (var _i7 = 0, _l6 = instanceNodes.length; _i7 < _l6; _i7++) {\n          objects.push(getNode(instanceNodes[_i7]).clone());\n        }\n\n        var object;\n\n        if (nodes.length === 0 && objects.length === 1) {\n          object = objects[0];\n        } else {\n          object = type === 'JOINT' ? new Bone() : new Group();\n\n          for (var _i8 = 0; _i8 < objects.length; _i8++) {\n            object.add(objects[_i8]);\n          }\n        }\n\n        object.name = type === 'JOINT' ? data.sid : data.name;\n        object.matrix.copy(matrix);\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n        return object;\n      }\n\n      var fallbackMaterial = new MeshBasicMaterial({\n        color: 0xff00ff\n      });\n\n      function resolveMaterialBinding(keys, instanceMaterials) {\n        var materials = [];\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var id = instanceMaterials[keys[i]];\n\n          if (id === undefined) {\n            console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n            materials.push(fallbackMaterial);\n          } else {\n            materials.push(getMaterial(id));\n          }\n        }\n\n        return materials;\n      }\n\n      function buildObjects(geometries, instanceMaterials) {\n        var objects = [];\n\n        for (var type in geometries) {\n          var geometry = geometries[type];\n          var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n          if (materials.length === 0) {\n            if (type === 'lines' || type === 'linestrips') {\n              materials.push(new LineBasicMaterial());\n            } else {\n              materials.push(new MeshPhongMaterial());\n            }\n          } // regard skinning\n\n\n          var skinning = geometry.data.attributes.skinIndex !== undefined;\n\n          if (skinning) {\n            for (var i = 0, l = materials.length; i < l; i++) {\n              materials[i].skinning = true;\n            }\n          } // choose between a single or multi materials (material array)\n\n\n          var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n          var object = void 0;\n\n          switch (type) {\n            case 'lines':\n              object = new LineSegments(geometry.data, material);\n              break;\n\n            case 'linestrips':\n              object = new Line(geometry.data, material);\n              break;\n\n            case 'triangles':\n            case 'polylist':\n              if (skinning) {\n                object = new SkinnedMesh(geometry.data, material);\n              } else {\n                object = new Mesh(geometry.data, material);\n              }\n\n              break;\n          }\n\n          objects.push(object);\n        }\n\n        return objects;\n      }\n\n      function hasNode(id) {\n        return library.nodes[id] !== undefined;\n      }\n\n      function getNode(id) {\n        return getBuild(library.nodes[id], buildNode);\n      } // visual scenes\n\n\n      function parseVisualScene(xml) {\n        var data = {\n          name: xml.getAttribute('name'),\n          children: []\n        };\n        prepareNodes(xml);\n        var elements = getElementsByTagName(xml, 'node');\n\n        for (var i = 0; i < elements.length; i++) {\n          data.children.push(parseNode(elements[i]));\n        }\n\n        library.visualScenes[xml.getAttribute('id')] = data;\n      }\n\n      function buildVisualScene(data) {\n        var group = new Group();\n        group.name = data.name;\n        var children = data.children;\n\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          group.add(getNode(child.id));\n        }\n\n        return group;\n      }\n\n      function hasVisualScene(id) {\n        return library.visualScenes[id] !== undefined;\n      }\n\n      function getVisualScene(id) {\n        return getBuild(library.visualScenes[id], buildVisualScene);\n      } // scenes\n\n\n      function parseScene(xml) {\n        var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n        return getVisualScene(parseId(instance.getAttribute('url')));\n      }\n\n      function setupAnimations() {\n        var clips = library.clips;\n\n        if (isEmpty(clips) === true) {\n          if (isEmpty(library.animations) === false) {\n            // if there are animations but no clips, we create a default clip for playback\n            var tracks = [];\n\n            for (var id in library.animations) {\n              var animationTracks = getAnimation(id);\n\n              for (var i = 0, l = animationTracks.length; i < l; i++) {\n                tracks.push(animationTracks[i]);\n              }\n            }\n\n            animations.push(new AnimationClip('default', -1, tracks));\n          }\n        } else {\n          for (var _id in clips) {\n            animations.push(getAnimationClip(_id));\n          }\n        }\n      } // convert the parser error element into text with each child elements text\n      // separated by new lines.\n\n\n      function parserErrorToText(parserError) {\n        var result = '';\n        var stack = [parserError];\n\n        while (stack.length) {\n          var node = stack.shift();\n\n          if (node.nodeType === Node.TEXT_NODE) {\n            result += node.textContent;\n          } else {\n            result += '\\n';\n            stack.push.apply(stack, node.childNodes);\n          }\n        }\n\n        return result.trim();\n      }\n\n      if (text.length === 0) {\n        return {\n          scene: new Scene()\n        };\n      }\n\n      var xml = new DOMParser().parseFromString(text, 'application/xml');\n      var collada = getElementsByTagName(xml, 'COLLADA')[0];\n      var parserError = xml.getElementsByTagName('parsererror')[0];\n\n      if (parserError !== undefined) {\n        // Chrome will return parser error with a div in it\n        var errorElement = getElementsByTagName(parserError, 'div')[0];\n        var errorText;\n\n        if (errorElement) {\n          errorText = errorElement.textContent;\n        } else {\n          errorText = parserErrorToText(parserError);\n        }\n\n        console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n        return null;\n      } // metadata\n\n\n      var version = collada.getAttribute('version');\n      console.log('THREE.ColladaLoader: File version', version);\n      var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var tgaLoader;\n\n      if (TGALoader) {\n        tgaLoader = new TGALoader(this.manager);\n        tgaLoader.setPath(this.resourcePath || path);\n      } //\n\n\n      var animations = [];\n      var kinematics = {};\n      var count = 0; //\n\n      var library = {\n        animations: {},\n        clips: {},\n        controllers: {},\n        images: {},\n        effects: {},\n        materials: {},\n        cameras: {},\n        lights: {},\n        geometries: {},\n        nodes: {},\n        visualScenes: {},\n        kinematicsModels: {},\n        physicsModels: {},\n        kinematicsScenes: {}\n      };\n      parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n      parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n      parseLibrary(collada, 'library_controllers', 'controller', parseController);\n      parseLibrary(collada, 'library_images', 'image', parseImage);\n      parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n      parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n      parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n      parseLibrary(collada, 'library_lights', 'light', parseLight);\n      parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n      parseLibrary(collada, 'library_nodes', 'node', parseNode);\n      parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n      parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n      parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n      parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n      buildLibrary(library.animations, buildAnimation);\n      buildLibrary(library.clips, buildAnimationClip);\n      buildLibrary(library.controllers, buildController);\n      buildLibrary(library.images, buildImage);\n      buildLibrary(library.effects, buildEffect);\n      buildLibrary(library.materials, buildMaterial);\n      buildLibrary(library.cameras, buildCamera);\n      buildLibrary(library.lights, buildLight);\n      buildLibrary(library.geometries, buildGeometry);\n      buildLibrary(library.visualScenes, buildVisualScene);\n      setupAnimations();\n      setupKinematics();\n      var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n      scene.animations = animations;\n\n      if (asset.upAxis === 'Z_UP') {\n        scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      }\n\n      scene.scale.multiplyScalar(asset.unit);\n      return {\n        get animations() {\n          console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n          return animations;\n        },\n\n        kinematics: kinematics,\n        library: library,\n        scene: scene\n      };\n    }\n  }]);\n\n  return ColladaLoader;\n}(Loader);\n\nexport { ColladaLoader };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportal/node_modules/three-stdlib/loaders/ColladaLoader.js"],"names":["Loader","LoaderUtils","FileLoader","Vector3","Quaternion","Matrix4","MeshBasicMaterial","Scene","TextureLoader","Euler","MathUtils","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","MeshLambertMaterial","MeshPhongMaterial","DoubleSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","RepeatWrapping","ClampToEdgeWrapping","TGALoader","ColladaLoader","manager","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","undefined","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechnique","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","double_sided","side","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","pushVector","sourceStride","sourceArray","c","k","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError","result","stack","Node","TEXT_NODE","apply","scene","DOMParser","parseFromString","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"mappings":"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","sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, DoubleSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      const array = [];\n      const childNodes = xml.childNodes;\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName);\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      const data = {};\n      const target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      let parts = target.split('/');\n      const id = parts.shift();\n      let sid = parts.shift(); // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1;\n      const memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        const indices = sid.split('(');\n        sid = indices.shift();\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = []; // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      }\n\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations = data.animations;\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i]);\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      const data = {\n        sources: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            const id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            const offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        const vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      const data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid');\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      const extra = effect.profile.extra;\n      let material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name || '';\n\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null; // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n\n      const parameters = technique.parameters;\n\n      for (const key in parameters) {\n        const parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      let transparent = parameters['transparent'];\n      let transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = DoubleSide;\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      let camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name || '';\n      return camera;\n    }\n\n    function getCamera(id) {\n      const data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      let data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      let light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n\n        case 'point':\n          light = new PointLight();\n          break;\n\n        case 'spot':\n          light = new SpotLight();\n          break;\n\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      const data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        const id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            const offset = parseInt(child.getAttribute('offset'));\n            const set = parseInt(child.getAttribute('set'));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      const build = {};\n\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      let count = 0;\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives);\n\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position = {\n        array: [],\n        stride: 0\n      };\n      const normal = {\n        array: [],\n        stride: 0\n      };\n      const uv = {\n        array: [],\n        stride: 0\n      };\n      const uv2 = {\n        array: [],\n        stride: 0\n      };\n      const color = {\n        array: [],\n        stride: 0\n      };\n      const skinIndex = {\n        array: [],\n        stride: 4\n      };\n      const skinWeight = {\n        array: [],\n        stride: 4\n      };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs; // groups\n\n        let count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (const name in inputs) {\n          const input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride;\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) {\n        geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      }\n\n      if (normal.array.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      }\n\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        let index = 0;\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i];\n\n          if (count === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      let data;\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0];\n            const min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName\n      };\n      const array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transform element\n          const parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name');\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            const joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array, vector;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            const matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material');\n\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute('symbol');\n              const target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j];\n\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      const bones = [];\n      const boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse; // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      const objects = [];\n      const matrix = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes; // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      let object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    const fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined;\n\n        if (skinning) {\n          for (let i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        } // choose between a single or multi materials (material array)\n\n\n        const material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        let object;\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      const elements = getElementsByTagName(xml, 'node');\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      const clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          const tracks = [];\n\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n\n    function parserErrorToText(parserError) {\n      let result = '';\n      const stack = [parserError];\n\n      while (stack.length) {\n        const node = stack.shift();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n\n      return result.trim();\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n\n    const xml = new DOMParser().parseFromString(text, 'application/xml');\n    const collada = getElementsByTagName(xml, 'COLLADA')[0];\n    const parserError = xml.getElementsByTagName('parsererror')[0];\n\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      const errorElement = getElementsByTagName(parserError, 'div')[0];\n      let errorText;\n\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n\n    const version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    const animations = [];\n    let kinematics = {};\n    let count = 0; //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n\n}\n\nexport { ColladaLoader };\n"]},"metadata":{},"sourceType":"module"}