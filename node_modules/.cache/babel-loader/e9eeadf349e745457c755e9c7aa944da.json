{"ast":null,"code":"import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh, PlaneBufferGeometry } from 'three';\nimport potpack from 'potpack';\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\n\nclass ProgressiveLightMap {\n  constructor(renderer) {\n    let res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms; // Set the new Shader to this\n\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n\n\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob]; // If this object is a light, simply add it to the internal scene\n\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!');\n        continue;\n      }\n\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      } // Apply the lightmap to the object\n\n\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1000 + ob; // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object: object\n      });\n      this.compiled = false;\n    } // Pack the objects' lightmap UVs into the same global space\n\n\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv2 = objects[box.index].geometry.getAttribute('uv').clone();\n\n      for (let i = 0; i < uv2.array.length; i += uv2.itemSize) {\n        uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n        uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n\n      objects[box.index].geometry.setAttribute('uv2', uv2);\n      objects[box.index].geometry.getAttribute('uv2').needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n\n\n  update(camera) {\n    let blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (this.blurringPlane == null) {\n      return;\n    } // Store the original Render Target\n\n\n    const oldTarget = this.renderer.getRenderTarget(); // The blurring plane applies blur to the seams of the lightmap\n\n    this.blurringPlane.visible = blurEdges; // Steal the Object3D from the real world to our special dimension\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    } // Render once normally to initialize everything\n\n\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\n\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    } // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    } // Ping-pong two surface buffers for reading/writing\n\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera); // Restore the object's Real-time Material and add it back to the original world\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    } // Restore the original Render Target\n\n\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n\n\n  showDebugLightmap(visible) {\n    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!');\n        this.warned = true;\n      }\n\n      return;\n    }\n\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n\n    if (position != undefined) {\n      this.labelMesh.position.copy(position);\n    }\n\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n\n\n  _initializeBlurPlane(res) {\n    let lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1.0 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0\n    };\n\n    blurMaterial.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`; // Set the LightMap Accumulation Buffer\n\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms; // Set the new Shader to this\n\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n\n    this.blurringPlane = new Mesh(new PlaneBufferGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = 'Blurring Plane';\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n\n}\n\nexport { ProgressiveLightMap };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/misc/ProgressiveLightmap.js"],"names":["Scene","WebGLRenderTarget","FloatType","MeshPhongMaterial","MeshBasicMaterial","DoubleSide","PlaneGeometry","Mesh","PlaneBufferGeometry","potpack","ProgressiveLightMap","constructor","renderer","res","lightMapContainers","compiled","scene","background","tinyTarget","buffer1Active","firstUpdate","warned","format","test","navigator","userAgent","alfFloatType","progressiveLightMap1","type","progressiveLightMap2","uvMat","uniforms","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","previousShadowMap","value","texture","averagingWindow","userData","addObjectsToLightMap","objects","uv_boxes","padding","ob","length","object","isLight","attach","geometry","hasAttribute","console","warn","blurringPlane","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","dimensions","forEach","box","uv2","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","update","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","setRenderTarget","render","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","showDebugLightmap","position","undefined","labelMesh","labelMaterial","map","side","labelPlane","add","copy","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite"],"mappings":"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","sourcesContent":["import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh, PlaneBufferGeometry } from 'three';\nimport potpack from 'potpack';\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\n\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms; // Set the new Shader to this\n\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n\n\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob]; // If this object is a light, simply add it to the internal scene\n\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!');\n        continue;\n      }\n\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      } // Apply the lightmap to the object\n\n\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1000 + ob; // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object: object\n      });\n      this.compiled = false;\n    } // Pack the objects' lightmap UVs into the same global space\n\n\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv2 = objects[box.index].geometry.getAttribute('uv').clone();\n\n      for (let i = 0; i < uv2.array.length; i += uv2.itemSize) {\n        uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n        uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n\n      objects[box.index].geometry.setAttribute('uv2', uv2);\n      objects[box.index].geometry.getAttribute('uv2').needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n\n\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return;\n    } // Store the original Render Target\n\n\n    const oldTarget = this.renderer.getRenderTarget(); // The blurring plane applies blur to the seams of the lightmap\n\n    this.blurringPlane.visible = blurEdges; // Steal the Object3D from the real world to our special dimension\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    } // Render once normally to initialize everything\n\n\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\n\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    } // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    } // Ping-pong two surface buffers for reading/writing\n\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera); // Restore the object's Real-time Material and add it back to the original world\n\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    } // Restore the original Render Target\n\n\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n\n\n  showDebugLightmap(visible, position = undefined) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!');\n        this.warned = true;\n      }\n\n      return;\n    }\n\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n\n    if (position != undefined) {\n      this.labelMesh.position.copy(position);\n    }\n\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n\n\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1.0 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0\n    };\n\n    blurMaterial.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`; // Set the LightMap Accumulation Buffer\n\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms; // Set the new Shader to this\n\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n\n    this.blurringPlane = new Mesh(new PlaneBufferGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = 'Blurring Plane';\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n\n}\n\nexport { ProgressiveLightMap };\n"]},"metadata":{},"sourceType":"module"}