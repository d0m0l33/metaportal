{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { strToU8, zipSync } from 'fflate';\nimport { Mesh, MeshPhysicalMaterial } from 'three';\n\nclass USDZExporter {\n  constructor() {\n    _defineProperty(this, \"PRECISION\", 7);\n\n    _defineProperty(this, \"materials\", void 0);\n\n    _defineProperty(this, \"textures\", void 0);\n\n    _defineProperty(this, \"files\", void 0);\n\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n\n  async parse(scene) {\n    const modelFileName = 'model.usda'; // model file should be first in USDZ archive so we init it here\n\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible(object => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd';\n\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split('_')[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(resolve => canvas === null || canvas === void 0 ? void 0 : canvas.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1));\n\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] = new Uint8Array(await blob.arrayBuffer());\n      }\n    } // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\n    let offset = 0;\n\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n\n      if (file && typeof file.length === 'number') {\n        offset = file.length;\n      }\n    }\n\n    return zipSync(this.files, {\n      level: 0\n    });\n  }\n\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext('2d');\n      context === null || context === void 0 ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n\n      if (color !== undefined) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context === null || context === void 0 ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n\n        if (imagedata) {\n          const data = imagedata === null || imagedata === void 0 ? void 0 : imagedata.data;\n\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n\n          context === null || context === void 0 ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n\n      return canvas;\n    }\n  }\n\n  buildHeader() {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`;\n  }\n\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  } // Xform\n\n\n  buildXform(object, geometry, material) {\n    const name = 'Object_' + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n    }\n\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`;\n  }\n\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(array, 8)}, ${this.buildMatrixRow(array, 12)} )`;\n  }\n\n  buildMatrixRow(array, offset) {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n  } // Mesh\n\n\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n  }\n\n  buildMesh(geometry) {\n    const name = 'Geometry';\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n  }\n\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(', ');\n  }\n\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      // @ts-expect-error\n      return geometry.index.array.join(', ');\n    }\n\n    const array = [];\n    const length = geometry.attributes.position.count;\n\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n\n    return array.join(', ');\n  }\n\n  buildVector3Array(attribute, count) {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: Normals missing.');\n      return Array(count).fill('(0, 0, 0)').join(', ');\n    }\n\n    const array = [];\n    const data = attribute.array;\n\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[i + 2].toPrecision(this.PRECISION)})`);\n    }\n\n    return array.join(', ');\n  }\n\n  buildVector2Array(attribute, count) {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: UVs missing.');\n      return Array(count).fill('(0, 0)').join(', ');\n    }\n\n    const array = [];\n    const data = attribute.array;\n\n    for (let i = 0; i < data.length; i += 2) {\n      // @ts-expect-error\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`);\n    }\n\n    return array.join(', ');\n  } // Materials\n\n\n  buildMaterials(materials) {\n    const array = [];\n\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n\n    return `def \"Materials\"\n{\n${array.join('')}\n}\n`;\n  }\n\n  buildMaterial(material) {\n    // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n    const pad = '            ';\n    const inputs = [];\n    const samplers = [];\n\n    if (material.map !== null) {\n      inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.map, 'diffuse', material.color));\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`);\n    }\n\n    if (material.emissiveMap !== null) {\n      inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.emissiveMap, 'emissive'));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`);\n    }\n\n    if (material.normalMap !== null) {\n      inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.normalMap, 'normal'));\n    }\n\n    if (material.aoMap !== null) {\n      inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n      samplers.push(this.buildTexture(material, material.aoMap, 'occlusion'));\n    }\n\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n      samplers.push(this.buildTexture(material, material.roughnessMap, 'roughness'));\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n    }\n\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n      samplers.push(this.buildTexture(material, material.metalnessMap, 'metallic'));\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n    }\n\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n    }\n\n    return `\n  {\n      def Material \"Material_${material.id}\"\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join('\\n')}\n    }\n`;\n  }\n\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? '_' + color.getHexString() : '');\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n      }`;\n  }\n\n  buildColor(color) {\n    return `(${color.r}, ${color.g}, ${color.b})`;\n  }\n\n  buildVector2(vector) {\n    return `(${vector.x}, ${vector.y})`;\n  }\n\n}\n\nexport { USDZExporter };","map":{"version":3,"sources":["/Users/dominiclee/Desktop/ethprojs/metaportalpublic/node_modules/three-stdlib/exporters/USDZExporter.js"],"names":["_defineProperty","strToU8","zipSync","Mesh","MeshPhysicalMaterial","USDZExporter","constructor","materials","textures","files","parse","scene","modelFileName","output","buildHeader","traverseVisible","object","isMesh","material","isMeshStandardMaterial","geometry","geometryFileName","id","meshObject","buildMeshObject","buildUSDFileAsString","uuid","buildXform","buildMaterials","texture","color","split","isRGBA","format","canvas","imageToCanvas","image","blob","Promise","resolve","toBlob","Uint8Array","arrayBuffer","offset","filename","file","headerSize","length","offsetMod64","padLength","padding","extra","level","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","scale","Math","max","width","height","document","createElement","min","context","getContext","drawImage","undefined","hex","parseInt","r","g","b","imagedata","getImageData","data","i","putImageData","dataToInsert","name","transform","buildMatrix","matrixWorld","determinant","console","warn","matrix","array","elements","buildMatrixRow","mesh","buildMesh","attributes","count","position","buildMeshVertexCount","buildMeshVertexIndices","buildVector3Array","normal","buildVector2Array","uv","index","Array","fill","join","push","attribute","toPrecision","PRECISION","buildMaterial","pad","inputs","samplers","map","buildTexture","buildColor","emissiveMap","emissive","getHex","normalMap","aoMap","roughnessMap","roughness","metalnessMap","metalness","opacity","clearcoat","clearcoatRoughness","ior","mapType","getHexString","buildVector2","repeat","vector","x","y"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { strToU8, zipSync } from 'fflate';\nimport { Mesh, MeshPhysicalMaterial } from 'three';\n\nclass USDZExporter {\n  constructor() {\n    _defineProperty(this, \"PRECISION\", 7);\n\n    _defineProperty(this, \"materials\", void 0);\n\n    _defineProperty(this, \"textures\", void 0);\n\n    _defineProperty(this, \"files\", void 0);\n\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n\n  async parse(scene) {\n    const modelFileName = 'model.usda'; // model file should be first in USDZ archive so we init it here\n\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible(object => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd';\n\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split('_')[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(resolve => canvas === null || canvas === void 0 ? void 0 : canvas.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1));\n\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] = new Uint8Array(await blob.arrayBuffer());\n      }\n    } // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\n    let offset = 0;\n\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n\n      if (file && typeof file.length === 'number') {\n        offset = file.length;\n      }\n    }\n\n    return zipSync(this.files, {\n      level: 0\n    });\n  }\n\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext('2d');\n      context === null || context === void 0 ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n\n      if (color !== undefined) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context === null || context === void 0 ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n\n        if (imagedata) {\n          const data = imagedata === null || imagedata === void 0 ? void 0 : imagedata.data;\n\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n\n          context === null || context === void 0 ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n\n      return canvas;\n    }\n  }\n\n  buildHeader() {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`;\n  }\n\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  } // Xform\n\n\n  buildXform(object, geometry, material) {\n    const name = 'Object_' + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n    }\n\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`;\n  }\n\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(array, 8)}, ${this.buildMatrixRow(array, 12)} )`;\n  }\n\n  buildMatrixRow(array, offset) {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n  } // Mesh\n\n\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n  }\n\n  buildMesh(geometry) {\n    const name = 'Geometry';\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n  }\n\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(', ');\n  }\n\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      // @ts-expect-error\n      return geometry.index.array.join(', ');\n    }\n\n    const array = [];\n    const length = geometry.attributes.position.count;\n\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n\n    return array.join(', ');\n  }\n\n  buildVector3Array(attribute, count) {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: Normals missing.');\n      return Array(count).fill('(0, 0, 0)').join(', ');\n    }\n\n    const array = [];\n    const data = attribute.array;\n\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[i + 2].toPrecision(this.PRECISION)})`);\n    }\n\n    return array.join(', ');\n  }\n\n  buildVector2Array(attribute, count) {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: UVs missing.');\n      return Array(count).fill('(0, 0)').join(', ');\n    }\n\n    const array = [];\n    const data = attribute.array;\n\n    for (let i = 0; i < data.length; i += 2) {\n      // @ts-expect-error\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`);\n    }\n\n    return array.join(', ');\n  } // Materials\n\n\n  buildMaterials(materials) {\n    const array = [];\n\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n\n    return `def \"Materials\"\n{\n${array.join('')}\n}\n`;\n  }\n\n  buildMaterial(material) {\n    // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n    const pad = '            ';\n    const inputs = [];\n    const samplers = [];\n\n    if (material.map !== null) {\n      inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.map, 'diffuse', material.color));\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`);\n    }\n\n    if (material.emissiveMap !== null) {\n      inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.emissiveMap, 'emissive'));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`);\n    }\n\n    if (material.normalMap !== null) {\n      inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n      samplers.push(this.buildTexture(material, material.normalMap, 'normal'));\n    }\n\n    if (material.aoMap !== null) {\n      inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n      samplers.push(this.buildTexture(material, material.aoMap, 'occlusion'));\n    }\n\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n      samplers.push(this.buildTexture(material, material.roughnessMap, 'roughness'));\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n    }\n\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n      samplers.push(this.buildTexture(material, material.metalnessMap, 'metallic'));\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n    }\n\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n    }\n\n    return `\n  {\n      def Material \"Material_${material.id}\"\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join('\\n')}\n    }\n`;\n  }\n\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? '_' + color.getHexString() : '');\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n      }`;\n  }\n\n  buildColor(color) {\n    return `(${color.r}, ${color.g}, ${color.b})`;\n  }\n\n  buildVector2(vector) {\n    return `(${vector.x}, ${vector.y})`;\n  }\n\n}\n\nexport { USDZExporter };\n"]},"metadata":{},"sourceType":"module"}